<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::ComputeShaderInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1ComputeShaderInterface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classne_1_1ComputeShaderInterface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::ComputeShaderInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ComputeShaderInterface_8h_source.html">ComputeShaderInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::ComputeShaderInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1ComputeShaderInterface.png" usemap="#ne::ComputeShaderInterface_map" alt=""/>
  <map id="ne::ComputeShaderInterface_map" name="ne::ComputeShaderInterface_map">
<area href="classne_1_1GlslComputeShaderInterface.html" alt="ne::GlslComputeShaderInterface" shape="rect" coords="0,56,193,80"/>
<area href="classne_1_1HlslComputeShaderInterface.html" alt="ne::HlslComputeShaderInterface" shape="rect" coords="203,56,396,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27a4fbcd28a8b3caba0fe82fc9e20fb8"><td class="memItemLeft" align="right" valign="top"><a id="a27a4fbcd28a8b3caba0fe82fc9e20fb8" name="a27a4fbcd28a8b3caba0fe82fc9e20fb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeShaderInterface</b> (const <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &amp;)=delete</td></tr>
<tr class="separator:a27a4fbcd28a8b3caba0fe82fc9e20fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b35ad48c91567b9ed101dc09cc8b8b"><td class="memItemLeft" align="right" valign="top"><a id="a36b35ad48c91567b9ed101dc09cc8b8b" name="a36b35ad48c91567b9ed101dc09cc8b8b"></a>
<a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &amp;)=delete</td></tr>
<tr class="separator:a36b35ad48c91567b9ed101dc09cc8b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91277887a773e2aba5158ad0a53d16f9"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a91277887a773e2aba5158ad0a53d16f9">bindResource</a> (<a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *pResource, const std::string &amp;sShaderResourceName, ComputeResourceUsage usage, bool bUpdateOnlyCurrentFrameResourceDescriptors=false)=0</td></tr>
<tr class="separator:a91277887a773e2aba5158ad0a53d16f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0181a3c1bebad87d5824ba71ab73cf3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a0181a3c1bebad87d5824ba71ab73cf3d">submitForExecution</a> (unsigned int <a class="el" href="classne_1_1ComputeShaderInterface.html#a731c89afc984daccc2878980f5b97cdc">iThreadGroupCountX</a>, unsigned int <a class="el" href="classne_1_1ComputeShaderInterface.html#a1fe7ed137867517cef4af303b0a4d172">iThreadGroupCountY</a>, unsigned int <a class="el" href="classne_1_1ComputeShaderInterface.html#ab6713b855cc72f2c52e1bbc32aa8f014">iThreadGroupCountZ</a>)</td></tr>
<tr class="separator:a0181a3c1bebad87d5824ba71ab73cf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a573e7f0ac4191e37300041b96be65"><td class="memItemLeft" align="right" valign="top">ComputeExecutionGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a24a573e7f0ac4191e37300041b96be65">getExecutionGroup</a> () const</td></tr>
<tr class="separator:a24a573e7f0ac4191e37300041b96be65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117d4df5768fb441629262b698d2cd1"><td class="memItemLeft" align="right" valign="top">ComputeExecutionStage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a7117d4df5768fb441629262b698d2cd1">getExecutionStage</a> () const</td></tr>
<tr class="separator:a7117d4df5768fb441629262b698d2cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127554f5a4ba6616f68bcf61787a9498"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a127554f5a4ba6616f68bcf61787a9498">getComputeShaderName</a> () const</td></tr>
<tr class="separator:a127554f5a4ba6616f68bcf61787a9498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a736d157ba281acfba473e8ca66598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#af3a736d157ba281acfba473e8ca66598">getUsedPipeline</a> () const</td></tr>
<tr class="separator:af3a736d157ba281acfba473e8ca66598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad1cfd5a57d56a66433d3da5744f5092d"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#ad1cfd5a57d56a66433d3da5744f5092d">createUsingGraphicsQueue</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *<a class="el" href="classne_1_1ComputeShaderInterface.html#a45b8cf2fcac7d1fcf27a229daf4170d7">pRenderer</a>, const std::string &amp;sCompiledComputeShaderName, ComputeExecutionStage <a class="el" href="classne_1_1ComputeShaderInterface.html#a7963d75f4fa00078dc11da0a9bc8b9f6">executionStage</a>, ComputeExecutionGroup <a class="el" href="classne_1_1ComputeShaderInterface.html#a5a9b540d76e10789c209144e46dfbdbd">executionGroup</a>=ComputeExecutionGroup::FIRST)</td></tr>
<tr class="separator:ad1cfd5a57d56a66433d3da5744f5092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8f8f7fe121d6032e64d7094658f10f7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a8f8f7fe121d6032e64d7094658f10f7f">ComputeShaderInterface</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *<a class="el" href="classne_1_1ComputeShaderInterface.html#a45b8cf2fcac7d1fcf27a229daf4170d7">pRenderer</a>, const std::string &amp;<a class="el" href="classne_1_1ComputeShaderInterface.html#af5993988c3a9bda596bd0f6e98260fd1">sComputeShaderName</a>, ComputeExecutionStage <a class="el" href="classne_1_1ComputeShaderInterface.html#a7963d75f4fa00078dc11da0a9bc8b9f6">executionStage</a>, ComputeExecutionGroup <a class="el" href="classne_1_1ComputeShaderInterface.html#a5a9b540d76e10789c209144e46dfbdbd">executionGroup</a>)</td></tr>
<tr class="separator:a8f8f7fe121d6032e64d7094658f10f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e94e5fd200126e11e57baac6adda2f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a7e94e5fd200126e11e57baac6adda2f8">getRenderer</a> ()</td></tr>
<tr class="separator:a7e94e5fd200126e11e57baac6adda2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f98db82d4e0b1a9ab2127cea23c1cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a33f98db82d4e0b1a9ab2127cea23c1cf">getPipeline</a> () const</td></tr>
<tr class="separator:a33f98db82d4e0b1a9ab2127cea23c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b78b8d2ee0eb431952adc91bde0f529"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a3b78b8d2ee0eb431952adc91bde0f529">getThreadGroupCountX</a> () const</td></tr>
<tr class="separator:a3b78b8d2ee0eb431952adc91bde0f529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b90c488898283e8b9618283f90e244c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a4b90c488898283e8b9618283f90e244c">getThreadGroupCountY</a> () const</td></tr>
<tr class="separator:a4b90c488898283e8b9618283f90e244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc01e4dc8dc119c674b9f6393318be54"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#acc01e4dc8dc119c674b9f6393318be54">getThreadGroupCountZ</a> () const</td></tr>
<tr class="separator:acc01e4dc8dc119c674b9f6393318be54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a11355f0efb3b89792fb562512a63da5b"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a11355f0efb3b89792fb562512a63da5b">createRenderSpecificInterface</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *<a class="el" href="classne_1_1ComputeShaderInterface.html#a45b8cf2fcac7d1fcf27a229daf4170d7">pRenderer</a>, const std::string &amp;<a class="el" href="classne_1_1ComputeShaderInterface.html#af5993988c3a9bda596bd0f6e98260fd1">sComputeShaderName</a>, ComputeExecutionStage <a class="el" href="classne_1_1ComputeShaderInterface.html#a7963d75f4fa00078dc11da0a9bc8b9f6">executionStage</a>, ComputeExecutionGroup <a class="el" href="classne_1_1ComputeShaderInterface.html#a5a9b540d76e10789c209144e46dfbdbd">executionGroup</a>)</td></tr>
<tr class="separator:a11355f0efb3b89792fb562512a63da5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf3e809c7c7a335aba188bdd38865cb"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#afdf3e809c7c7a335aba188bdd38865cb">createPartiallyInitializedRenderSpecificInterface</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *<a class="el" href="classne_1_1ComputeShaderInterface.html#a45b8cf2fcac7d1fcf27a229daf4170d7">pRenderer</a>, const std::string &amp;<a class="el" href="classne_1_1ComputeShaderInterface.html#af5993988c3a9bda596bd0f6e98260fd1">sComputeShaderName</a>, ComputeExecutionStage <a class="el" href="classne_1_1ComputeShaderInterface.html#a7963d75f4fa00078dc11da0a9bc8b9f6">executionStage</a>, ComputeExecutionGroup <a class="el" href="classne_1_1ComputeShaderInterface.html#a5a9b540d76e10789c209144e46dfbdbd">executionGroup</a>)</td></tr>
<tr class="separator:afdf3e809c7c7a335aba188bdd38865cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a45b8cf2fcac7d1fcf27a229daf4170d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a45b8cf2fcac7d1fcf27a229daf4170d7">pRenderer</a> = nullptr</td></tr>
<tr class="separator:a45b8cf2fcac7d1fcf27a229daf4170d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4115168862b8aa468c9d7a93e488421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#ac4115168862b8aa468c9d7a93e488421">pPipeline</a></td></tr>
<tr class="separator:ac4115168862b8aa468c9d7a93e488421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731c89afc984daccc2878980f5b97cdc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a731c89afc984daccc2878980f5b97cdc">iThreadGroupCountX</a> = 0</td></tr>
<tr class="separator:a731c89afc984daccc2878980f5b97cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7ed137867517cef4af303b0a4d172"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a1fe7ed137867517cef4af303b0a4d172">iThreadGroupCountY</a> = 0</td></tr>
<tr class="separator:a1fe7ed137867517cef4af303b0a4d172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6713b855cc72f2c52e1bbc32aa8f014"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#ab6713b855cc72f2c52e1bbc32aa8f014">iThreadGroupCountZ</a> = 0</td></tr>
<tr class="separator:ab6713b855cc72f2c52e1bbc32aa8f014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7963d75f4fa00078dc11da0a9bc8b9f6"><td class="memItemLeft" align="right" valign="top">const ComputeExecutionStage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a7963d75f4fa00078dc11da0a9bc8b9f6">executionStage</a> = ComputeExecutionStage::AFTER_DEPTH_PREPASS</td></tr>
<tr class="separator:a7963d75f4fa00078dc11da0a9bc8b9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9b540d76e10789c209144e46dfbdbd"><td class="memItemLeft" align="right" valign="top">const ComputeExecutionGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#a5a9b540d76e10789c209144e46dfbdbd">executionGroup</a> = ComputeExecutionGroup::FIRST</td></tr>
<tr class="separator:a5a9b540d76e10789c209144e46dfbdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5993988c3a9bda596bd0f6e98260fd1"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ComputeShaderInterface.html#af5993988c3a9bda596bd0f6e98260fd1">sComputeShaderName</a></td></tr>
<tr class="separator:af5993988c3a9bda596bd0f6e98260fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Interface to configure and run a compute shader. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8f8f7fe121d6032e64d7094658f10f7f" name="a8f8f7fe121d6032e64d7094658f10f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8f7fe121d6032e64d7094658f10f7f">&#9670;&#160;</a></span>ComputeShaderInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ne::ComputeShaderInterface::ComputeShaderInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sComputeShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionStage&#160;</td>
          <td class="paramname"><em>executionStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionGroup&#160;</td>
          <td class="paramname"><em>executionGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initializes everything except for <a class="el" href="classne_1_1ComputeShaderInterface.html#ac4115168862b8aa468c9d7a93e488421">pPipeline</a> which is expected to be initialized right after object creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td>Used renderer. </td></tr>
    <tr><td class="paramname">sComputeShaderName</td><td>Name of the compiled compute shader to use. </td></tr>
    <tr><td class="paramname">executionStage</td><td>Determines when the shader will be executed. </td></tr>
    <tr><td class="paramname">executionGroup</td><td>Execution order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a91277887a773e2aba5158ad0a53d16f9" name="a91277887a773e2aba5158ad0a53d16f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91277887a773e2aba5158ad0a53d16f9">&#9670;&#160;</a></span>bindResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ComputeShaderInterface::bindResource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *&#160;</td>
          <td class="paramname"><em>pResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeResourceUsage&#160;</td>
          <td class="paramname"><em>usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUpdateOnlyCurrentFrameResourceDescriptors</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Binds the specified resource to be available in compute shaders.</p>
<dl class="section warning"><dt>Warning</dt><dd>This overload is used in cases where you cannot transfer resource ownership to the compute shader interface. In this case you must guarantee that the resource will not be deleted while this compute shader interface exists and while the GPU is processing this compute shader.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pResource</td><td>Resource to bind to compute shader. </td></tr>
    <tr><td class="paramname">sShaderResourceName</td><td>Resource name from shader. </td></tr>
    <tr><td class="paramname">usage</td><td>Resource usage. </td></tr>
    <tr><td class="paramname">bUpdateOnlyCurrentFrameResourceDescriptors</td><td>Specify <code>true</code> if you guarantee that you will bind a different GPU resource on the next frame, specify <code>false</code> if you are not sure if you will rebind the resource on the next frame or not. When <code>true</code> is specified only descriptors of the current frame resource will be updated (because descriptors of other frame resources might be in use and it's invalid to update them), when <code>false</code> descriptors of all frame resources will be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

<p>Implemented in <a class="el" href="classne_1_1GlslComputeShaderInterface.html#afc2c48e069ae78bf4487dd37a1ddc955">ne::GlslComputeShaderInterface</a>, and <a class="el" href="classne_1_1HlslComputeShaderInterface.html#a3766c12ba388a79f758f475b87e2f902">ne::HlslComputeShaderInterface</a>.</p>

</div>
</div>
<a id="afdf3e809c7c7a335aba188bdd38865cb" name="afdf3e809c7c7a335aba188bdd38865cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf3e809c7c7a335aba188bdd38865cb">&#9670;&#160;</a></span>createPartiallyInitializedRenderSpecificInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &gt; ne::ComputeShaderInterface::createPartiallyInitializedRenderSpecificInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sComputeShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionStage&#160;</td>
          <td class="paramname"><em>executionStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionGroup&#160;</td>
          <td class="paramname"><em>executionGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new interface and initializes everything except for <a class="el" href="classne_1_1ComputeShaderInterface.html#ac4115168862b8aa468c9d7a93e488421">pPipeline</a> which is expected to be initialized right after object creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td>Used renderer. </td></tr>
    <tr><td class="paramname">sComputeShaderName</td><td>Name of the compiled compute shader to use. </td></tr>
    <tr><td class="paramname">executionStage</td><td>Determines when the shader will be executed. </td></tr>
    <tr><td class="paramname">executionGroup</td><td>Determines execution group of this shader where shaders of the first group will be executed before shaders from the second group and so on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created interface. </dd></dl>

</div>
</div>
<a id="a11355f0efb3b89792fb562512a63da5b" name="a11355f0efb3b89792fb562512a63da5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11355f0efb3b89792fb562512a63da5b">&#9670;&#160;</a></span>createRenderSpecificInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ComputeShaderInterface::createRenderSpecificInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sComputeShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionStage&#160;</td>
          <td class="paramname"><em>executionStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionGroup&#160;</td>
          <td class="paramname"><em>executionGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new fully initialized render-specific compute shader interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td>Used renderer. </td></tr>
    <tr><td class="paramname">sComputeShaderName</td><td>Name of the compiled compute shader to use. </td></tr>
    <tr><td class="paramname">executionStage</td><td>Determines when the shader will be executed. </td></tr>
    <tr><td class="paramname">executionGroup</td><td>Determines execution group of this shader where shaders of the first group will be executed before shaders from the second group and so on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise created interface. </dd></dl>

</div>
</div>
<a id="ad1cfd5a57d56a66433d3da5744f5092d" name="ad1cfd5a57d56a66433d3da5744f5092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cfd5a57d56a66433d3da5744f5092d">&#9670;&#160;</a></span>createUsingGraphicsQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ComputeShaderInterface::createUsingGraphicsQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sCompiledComputeShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionStage&#160;</td>
          <td class="paramname"><em>executionStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionGroup&#160;</td>
          <td class="paramname"><em>executionGroup</em> = <code>ComputeExecutionGroup::FIRST</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new render-specific interface to a compute shader that will be run in the graphics queue (the same queue that the rendering uses), this compute shader will run synchronously to the rendering operations (on the GPU).</p>
<dl class="section remark"><dt>Remarks</dt><dd>You might want to run your compute shader in the graphics queue if you need to make sure that some rendering operation(s) are run strictly before or after the compute shader (for example if you need to calculate some data that the rendering will use then use the graphics queue).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td>Used renderer. </td></tr>
    <tr><td class="paramname">sCompiledComputeShaderName</td><td>Name of the compiled compute shader to later run. </td></tr>
    <tr><td class="paramname">executionStage</td><td>Determines when the shader will be executed. </td></tr>
    <tr><td class="paramname">executionGroup</td><td>Determines execution group of this shader where shaders of the first group will be executed before shaders from the second group and so on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise created interface. </dd></dl>

</div>
</div>
<a id="a127554f5a4ba6616f68bcf61787a9498" name="a127554f5a4ba6616f68bcf61787a9498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127554f5a4ba6616f68bcf61787a9498">&#9670;&#160;</a></span>getComputeShaderName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::ComputeShaderInterface::getComputeShaderName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns name of the compiled compute shader that this interface uses.</p>
<dl class="section return"><dt>Returns</dt><dd>Compute shader name. </dd></dl>

</div>
</div>
<a id="a24a573e7f0ac4191e37300041b96be65" name="a24a573e7f0ac4191e37300041b96be65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a573e7f0ac4191e37300041b96be65">&#9670;&#160;</a></span>getExecutionGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ComputeExecutionGroup ne::ComputeShaderInterface::getExecutionGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns execution group of this shader where shaders of the first group will be executed before shaders from the second group and so on.</p>
<dl class="section return"><dt>Returns</dt><dd>Execution group. </dd></dl>

</div>
</div>
<a id="a7117d4df5768fb441629262b698d2cd1" name="a7117d4df5768fb441629262b698d2cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117d4df5768fb441629262b698d2cd1">&#9670;&#160;</a></span>getExecutionStage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ComputeExecutionStage ne::ComputeShaderInterface::getExecutionStage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns execution stage of this shader.</p>
<dl class="section return"><dt>Returns</dt><dd>Execution stage. </dd></dl>

</div>
</div>
<a id="a33f98db82d4e0b1a9ab2127cea23c1cf" name="a33f98db82d4e0b1a9ab2127cea23c1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f98db82d4e0b1a9ab2127cea23c1cf">&#9670;&#160;</a></span>getPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * ne::ComputeShaderInterface::getPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns used compute pipeline.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Pipeline.html">Pipeline</a>. </dd></dl>

</div>
</div>
<a id="a7e94e5fd200126e11e57baac6adda2f8" name="a7e94e5fd200126e11e57baac6adda2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e94e5fd200126e11e57baac6adda2f8">&#9670;&#160;</a></span>getRenderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Renderer.html">Renderer</a> * ne::ComputeShaderInterface::getRenderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns used renderer.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete (free) returned pointer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-owning pointer to the renderer. </dd></dl>

</div>
</div>
<a id="a3b78b8d2ee0eb431952adc91bde0f529" name="a3b78b8d2ee0eb431952adc91bde0f529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b78b8d2ee0eb431952adc91bde0f529">&#9670;&#160;</a></span>getThreadGroupCountX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ne::ComputeShaderInterface::getThreadGroupCountX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of thread groups dispatched in the X direction.</p>
<dl class="section return"><dt>Returns</dt><dd>Group count. </dd></dl>

</div>
</div>
<a id="a4b90c488898283e8b9618283f90e244c" name="a4b90c488898283e8b9618283f90e244c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b90c488898283e8b9618283f90e244c">&#9670;&#160;</a></span>getThreadGroupCountY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ne::ComputeShaderInterface::getThreadGroupCountY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of thread groups dispatched in the Y direction.</p>
<dl class="section return"><dt>Returns</dt><dd>Group count. </dd></dl>

</div>
</div>
<a id="acc01e4dc8dc119c674b9f6393318be54" name="acc01e4dc8dc119c674b9f6393318be54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc01e4dc8dc119c674b9f6393318be54">&#9670;&#160;</a></span>getThreadGroupCountZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ne::ComputeShaderInterface::getThreadGroupCountZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of thread groups dispatched in the Z direction.</p>
<dl class="section return"><dt>Returns</dt><dd>Group count. </dd></dl>

</div>
</div>
<a id="af3a736d157ba281acfba473e8ca66598" name="af3a736d157ba281acfba473e8ca66598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a736d157ba281acfba473e8ca66598">&#9670;&#160;</a></span>getUsedPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * ne::ComputeShaderInterface::getUsedPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns compute pipeline that this shader is referencing.</p>
<dl class="section return"><dt>Returns</dt><dd>Compute pipeline (always valid pointer unless this object is being destroyed). </dd></dl>

</div>
</div>
<a id="a0181a3c1bebad87d5824ba71ab73cf3d" name="a0181a3c1bebad87d5824ba71ab73cf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0181a3c1bebad87d5824ba71ab73cf3d">&#9670;&#160;</a></span>submitForExecution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ComputeShaderInterface::submitForExecution </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iThreadGroupCountX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iThreadGroupCountY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iThreadGroupCountZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds this compute shader to the GPU queue to be executed.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function queues the shader to be executed only once, if you want to queue this shader again you need to call this function later (if using graphics queue - after a new frame is drawn, otherwise later when you need it). Calling this function again right after calling it the first time will do nothing if graphics queue is used but override the specified thread group counts, if compute queue is used it will queue it again (so it will be executed twice).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iThreadGroupCountX</td><td>The number of thread groups dispatched in the X direction. </td></tr>
    <tr><td class="paramname">iThreadGroupCountY</td><td>The number of thread groups dispatched in the Y direction. </td></tr>
    <tr><td class="paramname">iThreadGroupCountZ</td><td>The number of thread groups dispatched in the Z direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5a9b540d76e10789c209144e46dfbdbd" name="a5a9b540d76e10789c209144e46dfbdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9b540d76e10789c209144e46dfbdbd">&#9670;&#160;</a></span>executionGroup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ComputeExecutionGroup ne::ComputeShaderInterface::executionGroup = ComputeExecutionGroup::FIRST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Describes order of execution. </p>

</div>
</div>
<a id="a7963d75f4fa00078dc11da0a9bc8b9f6" name="a7963d75f4fa00078dc11da0a9bc8b9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7963d75f4fa00078dc11da0a9bc8b9f6">&#9670;&#160;</a></span>executionStage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ComputeExecutionStage ne::ComputeShaderInterface::executionStage = ComputeExecutionStage::AFTER_DEPTH_PREPASS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Describes when shader should be executed. </p>

</div>
</div>
<a id="a731c89afc984daccc2878980f5b97cdc" name="a731c89afc984daccc2878980f5b97cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731c89afc984daccc2878980f5b97cdc">&#9670;&#160;</a></span>iThreadGroupCountX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ne::ComputeShaderInterface::iThreadGroupCountX = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The number of thread groups dispatched in the X direction. </p>

</div>
</div>
<a id="a1fe7ed137867517cef4af303b0a4d172" name="a1fe7ed137867517cef4af303b0a4d172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe7ed137867517cef4af303b0a4d172">&#9670;&#160;</a></span>iThreadGroupCountY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ne::ComputeShaderInterface::iThreadGroupCountY = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The number of thread groups dispatched in the Y direction. </p>

</div>
</div>
<a id="ab6713b855cc72f2c52e1bbc32aa8f014" name="ab6713b855cc72f2c52e1bbc32aa8f014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6713b855cc72f2c52e1bbc32aa8f014">&#9670;&#160;</a></span>iThreadGroupCountZ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ne::ComputeShaderInterface::iThreadGroupCountZ = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The number of thread groups dispatched in the Z direction. </p>

</div>
</div>
<a id="ac4115168862b8aa468c9d7a93e488421" name="ac4115168862b8aa468c9d7a93e488421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4115168862b8aa468c9d7a93e488421">&#9670;&#160;</a></span>pPipeline</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a> ne::ComputeShaderInterface::pPipeline</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute pipeline that this interface is using. </p>

</div>
</div>
<a id="a45b8cf2fcac7d1fcf27a229daf4170d7" name="a45b8cf2fcac7d1fcf27a229daf4170d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b8cf2fcac7d1fcf27a229daf4170d7">&#9670;&#160;</a></span>pRenderer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Renderer.html">Renderer</a>* ne::ComputeShaderInterface::pRenderer = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Do not delete (free) this pointer. A non-owning pointer to the renderer. </p>

</div>
</div>
<a id="af5993988c3a9bda596bd0f6e98260fd1" name="af5993988c3a9bda596bd0f6e98260fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5993988c3a9bda596bd0f6e98260fd1">&#9670;&#160;</a></span>sComputeShaderName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string ne::ComputeShaderInterface::sComputeShaderName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the compiled compute shader to run. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/public/shader/<a class="el" href="ComputeShaderInterface_8h_source.html">ComputeShaderInterface.h</a></li>
<li>src/engine_lib/private/shader/general/ComputeShaderInterface.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
