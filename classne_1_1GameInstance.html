<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::GameInstance Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1GameInstance.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1GameInstance-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::GameInstance Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="GameInstance_8h_source.html">GameInstance.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::GameInstance:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1GameInstance.png" usemap="#ne::GameInstance_map" alt=""/>
  <map id="ne::GameInstance_map" name="ne::GameInstance_map">
<area href="classne_1_1EditorGameInstance.html" alt="ne::EditorGameInstance" shape="rect" coords="0,56,144,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f00c7df05113dc71320acdf378c24d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a7f00c7df05113dc71320acdf378c24d8">GameInstance</a> (<a class="el" href="classne_1_1Window.html">Window</a> *<a class="el" href="classne_1_1GameInstance.html#a4f65dca260b1f8581b1c30a2be4f5316">pGameWindow</a>, <a class="el" href="classne_1_1GameManager.html">GameManager</a> *<a class="el" href="classne_1_1GameInstance.html#ac13ef9e4f2be1010406d6e3d62d7a9de">pGameManager</a>, <a class="el" href="classne_1_1InputManager.html">InputManager</a> *<a class="el" href="classne_1_1GameInstance.html#a7e778278348dc1e1b27b1b2183d00625">pInputManager</a>)</td></tr>
<tr class="separator:a7f00c7df05113dc71320acdf378c24d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f6a81646772768249aeb4606cfb075"><td class="memItemLeft" align="right" valign="top"><a id="ab5f6a81646772768249aeb4606cfb075" name="ab5f6a81646772768249aeb4606cfb075"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GameInstance</b> (const <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> &amp;)=delete</td></tr>
<tr class="separator:ab5f6a81646772768249aeb4606cfb075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e24cd7eefb5911c3cddfec1759e783"><td class="memItemLeft" align="right" valign="top"><a id="a27e24cd7eefb5911c3cddfec1759e783" name="a27e24cd7eefb5911c3cddfec1759e783"></a>
<a class="el" href="classne_1_1GameInstance.html">GameInstance</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> &amp;)=delete</td></tr>
<tr class="separator:a27e24cd7eefb5911c3cddfec1759e783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3763b4fa0eedb9735d02a3face9f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a9f3763b4fa0eedb9735d02a3face9f5a">addDeferredTask</a> (const std::function&lt; void()&gt; &amp;task) const</td></tr>
<tr class="separator:a9f3763b4fa0eedb9735d02a3face9f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeabdd90b1b0bd2d15b04b01d009a2b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#afeabdd90b1b0bd2d15b04b01d009a2b4">addTaskToThreadPool</a> (const std::function&lt; void()&gt; &amp;task) const</td></tr>
<tr class="separator:afeabdd90b1b0bd2d15b04b01d009a2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0fca06776071d01c9e97909806df6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#aff0fca06776071d01c9e97909806df6a">createWorld</a> (const std::function&lt; void(const std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; &amp;)&gt; &amp;onCreated, size_t iWorldSize=<a class="el" href="classne_1_1Globals.html#a7179df5dd887fdc07ac727435cc2e9bc">Globals::getDefaultWorldSize</a>())</td></tr>
<tr class="separator:aff0fca06776071d01c9e97909806df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac06b2413452cc4d3e041159cc0edd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a9ac06b2413452cc4d3e041159cc0edd6">loadNodeTreeAsWorld</a> (const std::function&lt; void(const std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; &amp;)&gt; &amp;onLoaded, const std::filesystem::path &amp;pathToNodeTree, size_t iWorldSize=<a class="el" href="classne_1_1Globals.html#a7179df5dd887fdc07ac727435cc2e9bc">Globals::getDefaultWorldSize</a>())</td></tr>
<tr class="separator:a9ac06b2413452cc4d3e041159cc0edd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2b339ea3f41d6d71a36ce7c47acb5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a3b2b339ea3f41d6d71a36ce7c47acb5e">queueGarbageCollection</a> (bool bForce, const std::optional&lt; std::function&lt; void()&gt; &gt; &amp;onFinished={})</td></tr>
<tr class="separator:a3b2b339ea3f41d6d71a36ce7c47acb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc2960f6fd8aa93c95b6d7f7eb8ee69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#adcc2960f6fd8aa93c95b6d7f7eb8ee69">setGarbageCollectorRunInterval</a> (long long iGcRunIntervalInSec)</td></tr>
<tr class="separator:adcc2960f6fd8aa93c95b6d7f7eb8ee69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632031102f1943178d5b19d98407babe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a632031102f1943178d5b19d98407babe">executeShaderManagerSelfValidation</a> () const</td></tr>
<tr class="separator:a632031102f1943178d5b19d98407babe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1694c7d8efca6ba32e3caff863d8fdfe"><td class="memItemLeft" align="right" valign="top">sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a1694c7d8efca6ba32e3caff863d8fdfe">getWorldRootNode</a> () const</td></tr>
<tr class="separator:a1694c7d8efca6ba32e3caff863d8fdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16483867d51ac5521d747038f37172ba"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a16483867d51ac5521d747038f37172ba">getWorldTimeInSeconds</a> () const</td></tr>
<tr class="separator:a16483867d51ac5521d747038f37172ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c6911a64ab45b5d45b9d2e241618c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#ae9c6911a64ab45b5d45b9d2e241618c7">getWorldSize</a> () const</td></tr>
<tr class="separator:ae9c6911a64ab45b5d45b9d2e241618c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32886049aa6aa5c63bca94f60c179264"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a32886049aa6aa5c63bca94f60c179264">getTotalSpawnedNodeCount</a> ()</td></tr>
<tr class="separator:a32886049aa6aa5c63bca94f60c179264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c6a395c405626e8b9bd9f88bca48a0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a88c6a395c405626e8b9bd9f88bca48a0">getCalledEveryFrameNodeCount</a> ()</td></tr>
<tr class="separator:a88c6a395c405626e8b9bd9f88bca48a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1527a8de17aa14bc10fb321f5e80b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Window.html">Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#aab1527a8de17aa14bc10fb321f5e80b2">getWindow</a> () const</td></tr>
<tr class="separator:aab1527a8de17aa14bc10fb321f5e80b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c9104a81b6b32567972bdd09a175ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1CameraManager.html">CameraManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a20c9104a81b6b32567972bdd09a175ec">getCameraManager</a> () const</td></tr>
<tr class="separator:a20c9104a81b6b32567972bdd09a175ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1914730da5993e3f18f15ce5ee6dbc4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1InputManager.html">InputManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a1914730da5993e3f18f15ce5ee6dbc4e">getInputManager</a> () const</td></tr>
<tr class="separator:a1914730da5993e3f18f15ce5ee6dbc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e2423872298e507160249708f6bb1e"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a16e2423872298e507160249708f6bb1e">getGarbageCollectorRunIntervalInSec</a> ()</td></tr>
<tr class="separator:a16e2423872298e507160249708f6bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a87a26980f1331909ea81f47c550aca3e"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a87a26980f1331909ea81f47c550aca3e">getTotalApplicationTimeInSec</a> ()</td></tr>
<tr class="separator:a87a26980f1331909ea81f47c550aca3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abc2070d12e33c6658ff109040a20b324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Timer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#abc2070d12e33c6658ff109040a20b324">createTimer</a> (const std::string &amp;sTimerName)</td></tr>
<tr class="separator:abc2070d12e33c6658ff109040a20b324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e23df6476d30d752135ac6229e9b20f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a2e23df6476d30d752135ac6229e9b20f">stopAndDisableCreatedTimers</a> ()</td></tr>
<tr class="separator:a2e23df6476d30d752135ac6229e9b20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e6067d69f8f01c946e80d52397daee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a62e6067d69f8f01c946e80d52397daee">onGameStarted</a> ()</td></tr>
<tr class="separator:a62e6067d69f8f01c946e80d52397daee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c3f5c6e96408babf22b3a977f8c5e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a33c3f5c6e96408babf22b3a977f8c5e1">onBeforeNewFrame</a> (float timeSincePrevCallInSec)</td></tr>
<tr class="separator:a33c3f5c6e96408babf22b3a977f8c5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32b017f37cf76d44c6b2b4b9e36bf82"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#ac32b017f37cf76d44c6b2b4b9e36bf82">onKeyboardInput</a> (KeyboardKey key, <a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, bool bIsPressedDown)</td></tr>
<tr class="separator:ac32b017f37cf76d44c6b2b4b9e36bf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb8ba7f0f5601466ae1d5a6b59bd572"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a5eb8ba7f0f5601466ae1d5a6b59bd572">onMouseInput</a> (MouseButton button, <a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, bool bIsPressedDown)</td></tr>
<tr class="separator:a5eb8ba7f0f5601466ae1d5a6b59bd572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8684ad4a68801bc651b2b31b1031ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#aca8684ad4a68801bc651b2b31b1031ad">onMouseMove</a> (double xOffset, double yOffset)</td></tr>
<tr class="separator:aca8684ad4a68801bc651b2b31b1031ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5324001b1c186881e7f12232cef62f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#abf5324001b1c186881e7f12232cef62f">onMouseScrollMove</a> (int iOffset)</td></tr>
<tr class="separator:abf5324001b1c186881e7f12232cef62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e67e6624e5b7bb018f14a5adfa6db97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a1e67e6624e5b7bb018f14a5adfa6db97">onWindowFocusChanged</a> (bool bIsFocused)</td></tr>
<tr class="separator:a1e67e6624e5b7bb018f14a5adfa6db97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdb73a250e0af9c3ff2ce94ee020efc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a9cdb73a250e0af9c3ff2ce94ee020efc">onFramebufferSizeChanged</a> (int iWidth, int iHeight)</td></tr>
<tr class="separator:a9cdb73a250e0af9c3ff2ce94ee020efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861a62cb1bd5094ebdaac417f3196675"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a861a62cb1bd5094ebdaac417f3196675">onWindowClose</a> ()</td></tr>
<tr class="separator:a861a62cb1bd5094ebdaac417f3196675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9d328115f9ccfb0a2bcf59696b4706"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#aaf9d328115f9ccfb0a2bcf59696b4706">getActionEventBindings</a> ()</td></tr>
<tr class="separator:aaf9d328115f9ccfb0a2bcf59696b4706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae937d75eae2f65ede3f1e1409929d7a4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#ae937d75eae2f65ede3f1e1409929d7a4">getAxisEventBindings</a> ()</td></tr>
<tr class="separator:ae937d75eae2f65ede3f1e1409929d7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5bb595a982b111f00b5dea23e9ea44ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a5bb595a982b111f00b5dea23e9ea44ed">onInputActionEvent</a> (unsigned int iActionId, <a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, bool bIsPressedDown)</td></tr>
<tr class="separator:a5bb595a982b111f00b5dea23e9ea44ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0adc50099fca125b3ed972056ee671"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a1d0adc50099fca125b3ed972056ee671">onInputAxisEvent</a> (unsigned int iAxisEventId, <a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, float input)</td></tr>
<tr class="separator:a1d0adc50099fca125b3ed972056ee671"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9a2b201b1cad1e756f4ecfaa4c019d36"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a9a2b201b1cad1e756f4ecfaa4c019d36">mtxBindedActionEvents</a></td></tr>
<tr class="separator:a9a2b201b1cad1e756f4ecfaa4c019d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af280f5e74bace192c883afce7bbfa179"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#af280f5e74bace192c883afce7bbfa179">mtxBindedAxisEvents</a></td></tr>
<tr class="separator:af280f5e74bace192c883afce7bbfa179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d67eeab693b01a3feea546861566ee"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1Timer.html">Timer</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a57d67eeab693b01a3feea546861566ee">mtxCreatedTimers</a></td></tr>
<tr class="separator:a57d67eeab693b01a3feea546861566ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315aeac9a8ea882a15033ead66ffc8ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a315aeac9a8ea882a15033ead66ffc8ec">bAllowCreatingTimers</a> = true</td></tr>
<tr class="separator:a315aeac9a8ea882a15033ead66ffc8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f65dca260b1f8581b1c30a2be4f5316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Window.html">Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a4f65dca260b1f8581b1c30a2be4f5316">pGameWindow</a> = nullptr</td></tr>
<tr class="separator:a4f65dca260b1f8581b1c30a2be4f5316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13ef9e4f2be1010406d6e3d62d7a9de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1GameManager.html">GameManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#ac13ef9e4f2be1010406d6e3d62d7a9de">pGameManager</a> = nullptr</td></tr>
<tr class="separator:ac13ef9e4f2be1010406d6e3d62d7a9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e778278348dc1e1b27b1b2183d00625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1InputManager.html">InputManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GameInstance.html#a7e778278348dc1e1b27b1b2183d00625">pInputManager</a> = nullptr</td></tr>
<tr class="separator:a7e778278348dc1e1b27b1b2183d00625"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a140a2a29511147897abbb772733f6c2c"><td class="memItemLeft" align="right" valign="top"><a id="a140a2a29511147897abbb772733f6c2c" name="a140a2a29511147897abbb772733f6c2c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GameManager</b></td></tr>
<tr class="separator:a140a2a29511147897abbb772733f6c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main game class, exists while the game window is not closed (i.e. while the game is not closed).</p>
<p >Reacts to user inputs, window events and etc. Owned by Game object. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7f00c7df05113dc71320acdf378c24d8" name="a7f00c7df05113dc71320acdf378c24d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f00c7df05113dc71320acdf378c24d8">&#9670;&#160;</a></span>GameInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::GameInstance::GameInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Window.html">Window</a> *&#160;</td>
          <td class="paramname"><em>pGameWindow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1GameManager.html">GameManager</a> *&#160;</td>
          <td class="paramname"><em>pGameManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1InputManager.html">InputManager</a> *&#160;</td>
          <td class="paramname"><em>pInputManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor.</p>
<dl class="section remark"><dt>Remarks</dt><dd>There is no need to save window/input manager pointers in derived classes as the base class already saves these pointers and provides <a class="el" href="classne_1_1GameInstance.html#aab1527a8de17aa14bc10fb321f5e80b2">getWindow</a> and <a class="el" href="classne_1_1GameInstance.html#a1914730da5993e3f18f15ce5ee6dbc4e">getInputManager</a> functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGameWindow</td><td><a class="el" href="classne_1_1Window.html">Window</a> that owns this game instance. </td></tr>
    <tr><td class="paramname">pGameManager</td><td><a class="el" href="classne_1_1GameManager.html">GameManager</a> that owns this game instance. </td></tr>
    <tr><td class="paramname">pInputManager</td><td>Input manager of the owner Game object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f3763b4fa0eedb9735d02a3face9f5a" name="a9f3763b4fa0eedb9735d02a3face9f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3763b4fa0eedb9735d02a3face9f5a">&#9670;&#160;</a></span>addDeferredTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::addDeferredTask </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a function to be executed on the main thread next time <a class="el" href="classne_1_1GameInstance.html#a33c3f5c6e96408babf22b3a977f8c5e1">onBeforeNewFrame</a> is called.</p>
<dl class="section warning"><dt>Warning</dt><dd>Don't capture <code>gc</code> pointers in <code>std::function</code>, this is not supported and will cause memory leaks/crashes!</dd>
<dd>
If you are using member functions/fields inside of the task you need to make sure that the owner object of these member functions/fields will not be deleted until this task is finished. If you use <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> or <a class="el" href="classne_1_1Node.html">Node</a> member functions/fields inside of the task and submitting a deferred tasks from the main thread then ignore this warning, they are safe to use in deferred tasks and will not be deleted until the task is finished. If you are submitting a deferred task that operates on a GameInstance/Node from a non main thread then you need to do a few additional checks inside of your deferred task, for example: <div class="fragment"><div class="line"><span class="comment">// We are on a non-main thread inside of a node:</span></div>
<div class="line"><a class="code hl_function" href="classne_1_1GameInstance.html#a9f3763b4fa0eedb9735d02a3face9f5a">addDeferredTask</a>([<span class="keyword">this</span>, iNodeId](){ <span class="comment">// capturing `this` to use `Node` (self) functions, also</span></div>
<div class="line">capturing self ID</div>
<div class="line">    <span class="comment">// We are inside of a deferred task (on the main thread) and we don&#39;t know if the node (`this`)</span></div>
<div class="line">    <span class="comment">// was garbage collected or not because we submitted our task from a non-main thread.</span></div>
<div class="line">    <span class="comment">// REMEMBER: we can&#39;t capture `gc` pointers in `std::function`, this is not supported</span></div>
<div class="line">    <span class="comment">// and will cause memory leaks/crashes!</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_variable" href="classne_1_1GameInstance.html#ac13ef9e4f2be1010406d6e3d62d7a9de">pGameManager</a> = <a class="code hl_function" href="classne_1_1GameManager.html#a3d76df401f4711a33a9bb896d793923b">GameManager::get</a>(); <span class="comment">// using engine&#39;s private class `GameManager`</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// `pGameManager` is guaranteed to be valid inside of a deferred task.</span></div>
<div class="line">    <span class="comment">// Otherwise, if running this code outside of a deferred task you need to do 2 checks:</span></div>
<div class="line">    <span class="comment">// if (pGameManager == nullptr) return;</span></div>
<div class="line">    <span class="comment">// if (pGameManager-&gt;isBeingDestroyed()) return;</span></div>
<div class="line"> </div>
<div class="line">     <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classne_1_1GameInstance.html#ac13ef9e4f2be1010406d6e3d62d7a9de">pGameManager</a>-&gt;<a class="code hl_function" href="classne_1_1GameManager.html#af183d6afc41ca41a4687f3073504f0fe">isNodeSpawned</a>(iNodeId)){</div>
<div class="line">         <span class="comment">// Node was despawned and it may be dangerous to run the callback.</span></div>
<div class="line">         <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Can safely interact with `this` (self) - we are on the main thread.</span></div>
<div class="line">  });</div>
<div class="ttc" id="aclassne_1_1GameInstance_html_a9f3763b4fa0eedb9735d02a3face9f5a"><div class="ttname"><a href="classne_1_1GameInstance.html#a9f3763b4fa0eedb9735d02a3face9f5a">ne::GameInstance::addDeferredTask</a></div><div class="ttdeci">void addDeferredTask(const std::function&lt; void()&gt; &amp;task) const</div><div class="ttdef"><b>Definition:</b> GameInstance.cpp:100</div></div>
<div class="ttc" id="aclassne_1_1GameInstance_html_ac13ef9e4f2be1010406d6e3d62d7a9de"><div class="ttname"><a href="classne_1_1GameInstance.html#ac13ef9e4f2be1010406d6e3d62d7a9de">ne::GameInstance::pGameManager</a></div><div class="ttdeci">GameManager * pGameManager</div><div class="ttdef"><b>Definition:</b> GameInstance.h:525</div></div>
<div class="ttc" id="aclassne_1_1GameManager_html_a3d76df401f4711a33a9bb896d793923b"><div class="ttname"><a href="classne_1_1GameManager.html#a3d76df401f4711a33a9bb896d793923b">ne::GameManager::get</a></div><div class="ttdeci">static GameManager * get()</div><div class="ttdef"><b>Definition:</b> GameManager.cpp:299</div></div>
<div class="ttc" id="aclassne_1_1GameManager_html_af183d6afc41ca41a4687f3073504f0fe"><div class="ttname"><a href="classne_1_1GameManager.html#af183d6afc41ca41a4687f3073504f0fe">ne::GameManager::isNodeSpawned</a></div><div class="ttdeci">bool isNodeSpawned(size_t iNodeId)</div><div class="ttdef"><b>Definition:</b> GameManager.cpp:598</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In the task you don't need to check if the game is being destroyed, the engine makes sure all tasks are finished before the game is destroyed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Function to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeabdd90b1b0bd2d15b04b01d009a2b4" name="afeabdd90b1b0bd2d15b04b01d009a2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeabdd90b1b0bd2d15b04b01d009a2b4">&#9670;&#160;</a></span>addTaskToThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::addTaskToThreadPool </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a function to be executed on the thread pool.</p>
<dl class="section warning"><dt>Warning</dt><dd>Don't capture <code>gc</code> pointers in <code>std::function</code>, this is not supported and will cause memory leaks/crashes!</dd>
<dd>
If you are using a member functions/fields inside of the task you need to make sure that the owner object of these member functions/fields will not be deleted until this task is finished.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In the task you don't need to check if the game is being destroyed, the engine makes sure all tasks are finished before the game is destroyed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Function to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc2070d12e33c6658ff109040a20b324" name="abc2070d12e33c6658ff109040a20b324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2070d12e33c6658ff109040a20b324">&#9670;&#160;</a></span>createTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Timer.html">Timer</a> * ne::GameInstance::createTimer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sTimerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new timer and saves it inside of this <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not free (delete) returned pointer. </dd>
<dd>
Do not use returned pointer outside of this object as the timer is only guaranteed to live while the <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> (that created the timer) is living.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function will not work and will log an error if you would try to create a timer inside of the <a class="el" href="classne_1_1GameInstance.html#a861a62cb1bd5094ebdaac417f3196675">onWindowClose</a> function. </dd>
<dd>
This function exists to add some protection code to not shoot yourself in the foot, such as: <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> will automatically stop and disable created timers before <a class="el" href="classne_1_1GameInstance.html#a861a62cb1bd5094ebdaac417f3196675">onWindowClose</a> is called by using Timer::stop(true) so that you don't have to remember to stop created timers. Moreover, if you are using a callback function for the timer's timeout event it's guaranteed that this callback function will only be called while the object is valid. </dd>
<dd>
There is no <code>removeTimer</code> function but it may appear in the future (although there's really no point in removing a timer so don't care about it).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTimerName</td><td>Name of this timer (used for logging). Don't add "timer" word to your timer's name as it will be appended in the logs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if something went wrong, otherwise a non-owning pointer to the created timer that is guaranteed to be valid while this object is alive. </dd></dl>

</div>
</div>
<a id="aff0fca06776071d01c9e97909806df6a" name="aff0fca06776071d01c9e97909806df6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0fca06776071d01c9e97909806df6a">&#9670;&#160;</a></span>createWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::createWorld </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>onCreated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iWorldSize</em> = <code><a class="el" href="classne_1_1Globals.html#a7179df5dd887fdc07ac727435cc2e9bc">Globals::getDefaultWorldSize</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a deferred task (see <a class="el" href="classne_1_1GameInstance.html#a9f3763b4fa0eedb9735d02a3face9f5a">addDeferredTask</a>) to create a new world that contains only one node - root node.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you are holding any <code>gc</code> pointers to nodes in your game instance, make sure you clear them (set to <code>nullptr</code>) before calling this function.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Replaces the old world (if existed).</dd>
<dd>
Engine will execute all deferred tasks before changing the world (before destroying all nodes), so even if deferred tasks queue looks like this: ... &ndash; create/load world task &ndash; call node's member function task &ndash; ..., on <code>create/load world task</code> the engine will finish all other tasks and only when deferred tasks queue is empty start to create/load world so you don't need to care about the order of deferred tasks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">onCreated</td><td>Callback function that will be called on the main thread after the world is created. Contains optional error (if world creation failed) as the only argument. Use <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> member functions as callback functions for created worlds, because all nodes and other game objects will be destroyed while the world is changing. </td></tr>
    <tr><td class="paramname">iWorldSize</td><td>Size of the new world in game units. Must be power of 2 (128, 256, 512, 1024, 2048, etc.). <a class="el" href="classne_1_1World.html">World</a> size needs to be specified for internal purposes such as Directional Light shadow map size. You don't need to care why we need this information, you only need to know that if you leave world bounds lighting or physics may be incorrect (the editor or engine will warn you if something is leaving world bounds, pay attention to the logs). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a632031102f1943178d5b19d98407babe" name="a632031102f1943178d5b19d98407babe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632031102f1943178d5b19d98407babe">&#9670;&#160;</a></span>executeShaderManagerSelfValidation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::executeShaderManagerSelfValidation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Analyzes the current state to see if any shader-related errors have place (like unused shaders in memory or etc.). Fixes errors and reports them in log.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Generally should be called right before you let the player play the game (after all required nodes are spawned). </dd></dl>

</div>
</div>
<a id="aaf9d328115f9ccfb0a2bcf59696b4706" name="aaf9d328115f9ccfb0a2bcf59696b4706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9d328115f9ccfb0a2bcf59696b4706">&#9670;&#160;</a></span>getActionEventBindings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt; * ne::GameInstance::getActionEventBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns map of action events that this <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> is binded to (must be used with mutex). Binded callbacks will be automatically called when an action event is triggered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that nodes can also have their input event bindings and you may prefer to bind to input in specific nodes instead of binding to them in <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>. </dd>
<dd>
Only events in <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>'s <a class="el" href="classne_1_1InputManager.html">InputManager</a> (<a class="el" href="classne_1_1GameInstance.html#a1914730da5993e3f18f15ce5ee6dbc4e">GameInstance::getInputManager</a>) will be considered to trigger events in the node. </dd>
<dd>
Called after <a class="el" href="classne_1_1GameInstance.html#ac32b017f37cf76d44c6b2b4b9e36bf82">onKeyboardInput</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iForwardActionId = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pMtxActionEvents = <a class="code hl_function" href="classne_1_1GameInstance.html#aaf9d328115f9ccfb0a2bcf59696b4706">getActionEventBindings</a>();</div>
<div class="line"> </div>
<div class="line">std::scoped_lock guard(pMtxActionEvents-&gt;first);</div>
<div class="line">pMtxActionEvents-&gt;second[iForwardActionId] = [&amp;](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">bool</span></div>
<div class="line">bIsPressedDown) {</div>
<div class="line">    moveForward(modifiers, bIsPressedDown);</div>
<div class="line">};</div>
<div class="ttc" id="aclassne_1_1GameInstance_html_aaf9d328115f9ccfb0a2bcf59696b4706"><div class="ttname"><a href="classne_1_1GameInstance.html#aaf9d328115f9ccfb0a2bcf59696b4706">ne::GameInstance::getActionEventBindings</a></div><div class="ttdeci">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(KeyboardModifiers, bool)&gt; &gt; &gt; * getActionEventBindings()</div><div class="ttdef"><b>Definition:</b> GameInstance.cpp:136</div></div>
<div class="ttc" id="aclassne_1_1KeyboardModifiers_html"><div class="ttname"><a href="classne_1_1KeyboardModifiers.html">ne::KeyboardModifiers</a></div><div class="ttdef"><b>Definition:</b> KeyboardKey.hpp:10</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Binded action events. </dd></dl>

</div>
</div>
<a id="ae937d75eae2f65ede3f1e1409929d7a4" name="ae937d75eae2f65ede3f1e1409929d7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae937d75eae2f65ede3f1e1409929d7a4">&#9670;&#160;</a></span>getAxisEventBindings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt; * ne::GameInstance::getAxisEventBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns map of axis events that this <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> is binded to (must be used with mutex). Binded callbacks will be automatically called when an axis event is triggered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that nodes can also have their input event bindings and you may prefer to bind to input in specific nodes instead of binding to them in <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>. </dd>
<dd>
Only events in <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>'s <a class="el" href="classne_1_1InputManager.html">InputManager</a> (<a class="el" href="classne_1_1GameInstance.html#a1914730da5993e3f18f15ce5ee6dbc4e">GameInstance::getInputManager</a>) will be considered to trigger events in the node. </dd>
<dd>
Called after <a class="el" href="classne_1_1GameInstance.html#ac32b017f37cf76d44c6b2b4b9e36bf82">onKeyboardInput</a>.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> iForwardAxisEventId = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pMtxAxisEvents = <a class="code hl_function" href="classne_1_1GameInstance.html#ae937d75eae2f65ede3f1e1409929d7a4">getAxisEventBindings</a>();</div>
<div class="line"> </div>
<div class="line">std::scoped_lock guard(pMtxAxisEvents-&gt;first);</div>
<div class="line">pMtxAxisEvents-&gt;second[iForwardAxisEventId] = [&amp;](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">float</span> input) {</div>
<div class="line">    moveForward(modifiers, input);</div>
<div class="line">};</div>
<div class="ttc" id="aclassne_1_1GameInstance_html_ae937d75eae2f65ede3f1e1409929d7a4"><div class="ttname"><a href="classne_1_1GameInstance.html#ae937d75eae2f65ede3f1e1409929d7a4">ne::GameInstance::getAxisEventBindings</a></div><div class="ttdeci">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(KeyboardModifiers, float)&gt; &gt; &gt; * getAxisEventBindings()</div><div class="ttdef"><b>Definition:</b> GameInstance.cpp:143</div></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Input parameter is a value in range [-1.0f; 1.0f] that describes input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Binded action events. </dd></dl>

</div>
</div>
<a id="a88c6a395c405626e8b9bd9f88bca48a0" name="a88c6a395c405626e8b9bd9f88bca48a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c6a395c405626e8b9bd9f88bca48a0">&#9670;&#160;</a></span>getCalledEveryFrameNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::GameInstance::getCalledEveryFrameNodeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the current amount of spawned nodes that are marked as "should be called every frame".</p>
<dl class="section return"><dt>Returns</dt><dd>Amount of spawned nodes that should be called every frame. </dd></dl>

</div>
</div>
<a id="a20c9104a81b6b32567972bdd09a175ec" name="a20c9104a81b6b32567972bdd09a175ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c9104a81b6b32567972bdd09a175ec">&#9670;&#160;</a></span>getCameraManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1CameraManager.html">CameraManager</a> * ne::GameInstance::getCameraManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a reference to the camera manager this game is using.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the camera manager, should not be deleted. </dd></dl>

</div>
</div>
<a id="a16e2423872298e507160249708f6bb1e" name="a16e2423872298e507160249708f6bb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e2423872298e507160249708f6bb1e">&#9670;&#160;</a></span>getGarbageCollectorRunIntervalInSec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long ne::GameInstance::getGarbageCollectorRunIntervalInSec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the current interval after which we need to run garbage collector again.</p>
<dl class="section return"><dt>Returns</dt><dd>Interval in seconds. </dd></dl>

</div>
</div>
<a id="a1914730da5993e3f18f15ce5ee6dbc4e" name="a1914730da5993e3f18f15ce5ee6dbc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1914730da5993e3f18f15ce5ee6dbc4e">&#9670;&#160;</a></span>getInputManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1InputManager.html">InputManager</a> * ne::GameInstance::getInputManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a reference to the input manager this game instance is using. Input manager allows binding IDs with multiple input keys that you can receive in <a class="el" href="classne_1_1GameInstance.html#a5bb595a982b111f00b5dea23e9ea44ed">onInputActionEvent</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the input manager, should not be deleted. </dd></dl>

</div>
</div>
<a id="a87a26980f1331909ea81f47c550aca3e" name="a87a26980f1331909ea81f47c550aca3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a26980f1331909ea81f47c550aca3e">&#9670;&#160;</a></span>getTotalApplicationTimeInSec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ne::GameInstance::getTotalApplicationTimeInSec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the time in seconds that has passed since the very first window was created.</p>
<dl class="section return"><dt>Returns</dt><dd>Time in seconds. </dd></dl>

</div>
</div>
<a id="a32886049aa6aa5c63bca94f60c179264" name="a32886049aa6aa5c63bca94f60c179264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32886049aa6aa5c63bca94f60c179264">&#9670;&#160;</a></span>getTotalSpawnedNodeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::GameInstance::getTotalSpawnedNodeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns total amount of currently spawned nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Total nodes spawned right now. </dd></dl>

</div>
</div>
<a id="aab1527a8de17aa14bc10fb321f5e80b2" name="aab1527a8de17aa14bc10fb321f5e80b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1527a8de17aa14bc10fb321f5e80b2">&#9670;&#160;</a></span>getWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Window.html">Window</a> * ne::GameInstance::getWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a reference to the window this game instance is using.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the window, should not be deleted. </dd></dl>

</div>
</div>
<a id="a1694c7d8efca6ba32e3caff863d8fdfe" name="a1694c7d8efca6ba32e3caff863d8fdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1694c7d8efca6ba32e3caff863d8fdfe">&#9670;&#160;</a></span>getWorldRootNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; ne::GameInstance::getWorldRootNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a pointer to world's root node.</p>
<dl class="section return"><dt>Returns</dt><dd>nullptr if world is not created or was destroyed (see <a class="el" href="classne_1_1GameInstance.html#aff0fca06776071d01c9e97909806df6a">createWorld</a>), otherwise world's root node. </dd></dl>

</div>
</div>
<a id="ae9c6911a64ab45b5d45b9d2e241618c7" name="ae9c6911a64ab45b5d45b9d2e241618c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c6911a64ab45b5d45b9d2e241618c7">&#9670;&#160;</a></span>getWorldSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::GameInstance::getWorldSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns world size in game units.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1World.html">World</a> size. </dd></dl>

</div>
</div>
<a id="a16483867d51ac5521d747038f37172ba" name="a16483867d51ac5521d747038f37172ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16483867d51ac5521d747038f37172ba">&#9670;&#160;</a></span>getWorldTimeInSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ne::GameInstance::getWorldTimeInSeconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns time since world creation (in seconds).</p>
<dl class="section return"><dt>Returns</dt><dd>Zero if world is not created (see <a class="el" href="classne_1_1GameInstance.html#aff0fca06776071d01c9e97909806df6a">createWorld</a>), otherwise time since world creation (in seconds). </dd></dl>

</div>
</div>
<a id="a9ac06b2413452cc4d3e041159cc0edd6" name="a9ac06b2413452cc4d3e041159cc0edd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac06b2413452cc4d3e041159cc0edd6">&#9670;&#160;</a></span>loadNodeTreeAsWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::loadNodeTreeAsWorld </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>onLoaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathToNodeTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iWorldSize</em> = <code><a class="el" href="classne_1_1Globals.html#a7179df5dd887fdc07ac727435cc2e9bc">Globals::getDefaultWorldSize</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a deferred task (see <a class="el" href="classne_1_1GameInstance.html#a9f3763b4fa0eedb9735d02a3face9f5a">addDeferredTask</a>) to load and deserialize a node tree to be used as the new world.</p>
<p ><a class="el" href="classne_1_1Node.html">Node</a> tree's root node will be used as world's root node.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you are holding any <code>gc</code> pointers to nodes in game instance, make sure you set <code>nullptr</code> to them before calling this function.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Replaces the old world (if existed).</dd>
<dd>
Engine will execute all deferred tasks before changing the world (before destroying all nodes), so even if deferred tasks queue looks like this: ... &ndash; create/load world task &ndash; call node's member function task &ndash; ..., on <code>create/load world task</code> the engine will finish all other tasks and only when deferred tasks queue is empty start to create/load world so you don't need to care about the order of deferred tasks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">onLoaded</td><td>Callback function that will be called on the main thread after the world is loaded. Contains optional error (if world loading failed) as the only argument. Use <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> member functions as callback functions for loaded worlds, because all nodes and other game objects will be destroyed while the world is changing. </td></tr>
    <tr><td class="paramname">pathToNodeTree</td><td>Path to the file that contains a node tree to load, the ".toml" extension will be automatically added if not specified. </td></tr>
    <tr><td class="paramname">iWorldSize</td><td>Size of the world in game units. Must be power of 2 (128, 256, 512, 1024, 2048, etc.). <a class="el" href="classne_1_1World.html">World</a> size needs to be specified for internal purposes such as Directional Light shadow map size. You don't need to care why we need this information, you only need to know that if you leave world bounds lighting or physics may be incorrect (the editor or engine will warn you if something is leaving world bounds, pay attention to the logs). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33c3f5c6e96408babf22b3a977f8c5e1" name="a33c3f5c6e96408babf22b3a977f8c5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c3f5c6e96408babf22b3a977f8c5e1">&#9670;&#160;</a></span>onBeforeNewFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onBeforeNewFrame </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timeSincePrevCallInSec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called before a new frame is rendered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Called before nodes that should be called every frame.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeSincePrevCallInSec</td><td>Time in seconds that has passed since the last call to this function. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classne_1_1EditorGameInstance.html#a98db763ad2e5b24ba9bb24c5192fb1c5">ne::EditorGameInstance</a>.</p>

</div>
</div>
<a id="a9cdb73a250e0af9c3ff2ce94ee020efc" name="a9cdb73a250e0af9c3ff2ce94ee020efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdb73a250e0af9c3ff2ce94ee020efc">&#9670;&#160;</a></span>onFramebufferSizeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onFramebufferSizeChanged </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the framebuffer size was changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iWidth</td><td>New width of the framebuffer (in pixels). </td></tr>
    <tr><td class="paramname">iHeight</td><td>New height of the framebuffer (in pixels). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62e6067d69f8f01c946e80d52397daee" name="a62e6067d69f8f01c946e80d52397daee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e6067d69f8f01c946e80d52397daee">&#9670;&#160;</a></span>onGameStarted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onGameStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>'s constructor is finished and created <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> object was saved in <a class="el" href="classne_1_1GameManager.html">GameManager</a> (that owns <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>).</p>
<p >At this point you can create and interact with the game world and etc. </p>

<p>Reimplemented in <a class="el" href="classne_1_1EditorGameInstance.html#aab5506f886d0c72aa81728232ef7b3b5">ne::EditorGameInstance</a>.</p>

</div>
</div>
<a id="a5bb595a982b111f00b5dea23e9ea44ed" name="a5bb595a982b111f00b5dea23e9ea44ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb595a982b111f00b5dea23e9ea44ed">&#9670;&#160;</a></span>onInputActionEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::onInputActionEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iActionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsPressedDown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when a window that owns this game instance receives user input and the input key exists as an action event in the <a class="el" href="classne_1_1InputManager.html">InputManager</a>. Called after <a class="el" href="classne_1_1GameInstance.html#ac32b017f37cf76d44c6b2b4b9e36bf82">onKeyboardInput</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iActionId</td><td>Unique ID of the input action event (from input manager). </td></tr>
    <tr><td class="paramname">modifiers</td><td>Keyboard modifier keys. </td></tr>
    <tr><td class="paramname">bIsPressedDown</td><td>Whether the key down event occurred or key up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d0adc50099fca125b3ed972056ee671" name="a1d0adc50099fca125b3ed972056ee671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0adc50099fca125b3ed972056ee671">&#9670;&#160;</a></span>onInputAxisEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::onInputAxisEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iAxisEventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when a window that owns this game instance receives user input and the input key exists as an axis event in the <a class="el" href="classne_1_1InputManager.html">InputManager</a>. Called after <a class="el" href="classne_1_1GameInstance.html#ac32b017f37cf76d44c6b2b4b9e36bf82">onKeyboardInput</a> and after <a class="el" href="classne_1_1GameInstance.html#a5bb595a982b111f00b5dea23e9ea44ed">onInputActionEvent</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iAxisEventId</td><td>Unique ID of the input axis event (from input manager). </td></tr>
    <tr><td class="paramname">modifiers</td><td>Keyboard modifier keys. </td></tr>
    <tr><td class="paramname">input</td><td>A value in range [-1.0f; 1.0f] that describes input. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac32b017f37cf76d44c6b2b4b9e36bf82" name="ac32b017f37cf76d44c6b2b4b9e36bf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32b017f37cf76d44c6b2b4b9e36bf82">&#9670;&#160;</a></span>onKeyboardInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onKeyboardInput </td>
          <td>(</td>
          <td class="paramtype">KeyboardKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsPressedDown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the window receives keyboard input. Called before <a class="el" href="classne_1_1GameInstance.html#a5bb595a982b111f00b5dea23e9ea44ed">onInputActionEvent</a>. Prefer to use <a class="el" href="classne_1_1GameInstance.html#a5bb595a982b111f00b5dea23e9ea44ed">onInputActionEvent</a> instead of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Keyboard key. </td></tr>
    <tr><td class="paramname">modifiers</td><td>Keyboard modifier keys. </td></tr>
    <tr><td class="paramname">bIsPressedDown</td><td>Whether the key down event occurred or key up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5eb8ba7f0f5601466ae1d5a6b59bd572" name="a5eb8ba7f0f5601466ae1d5a6b59bd572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb8ba7f0f5601466ae1d5a6b59bd572">&#9670;&#160;</a></span>onMouseInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onMouseInput </td>
          <td>(</td>
          <td class="paramtype">MouseButton&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsPressedDown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the window receives mouse input. Called before <a class="el" href="classne_1_1GameInstance.html#a5bb595a982b111f00b5dea23e9ea44ed">onInputActionEvent</a>. Prefer to use <a class="el" href="classne_1_1GameInstance.html#a5bb595a982b111f00b5dea23e9ea44ed">onInputActionEvent</a> instead of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">button</td><td>Mouse button. </td></tr>
    <tr><td class="paramname">modifiers</td><td>Keyboard modifier keys. </td></tr>
    <tr><td class="paramname">bIsPressedDown</td><td>Whether the button down event occurred or button up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca8684ad4a68801bc651b2b31b1031ad" name="aca8684ad4a68801bc651b2b31b1031ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8684ad4a68801bc651b2b31b1031ad">&#9670;&#160;</a></span>onMouseMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onMouseMove </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the window received mouse movement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xOffset</td><td>Mouse X movement delta in pixels (plus if moved to the right, minus if moved to the left). </td></tr>
    <tr><td class="paramname">yOffset</td><td>Mouse Y movement delta in pixels (plus if moved up, minus if moved down). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf5324001b1c186881e7f12232cef62f" name="abf5324001b1c186881e7f12232cef62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5324001b1c186881e7f12232cef62f">&#9670;&#160;</a></span>onMouseScrollMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onMouseScrollMove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iOffset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the window receives mouse scroll movement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iOffset</td><td>Movement offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a861a62cb1bd5094ebdaac417f3196675" name="a861a62cb1bd5094ebdaac417f3196675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861a62cb1bd5094ebdaac417f3196675">&#9670;&#160;</a></span>onWindowClose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onWindowClose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the window that owns this game instance was requested to close (no new frames will be rendered).</p>
<p >Prefer to have your destructor logic here, because after this function is finished the world will be destroyed and will be inaccessible (<code>nullptr</code>). </p>

</div>
</div>
<a id="a1e67e6624e5b7bb018f14a5adfa6db97" name="a1e67e6624e5b7bb018f14a5adfa6db97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e67e6624e5b7bb018f14a5adfa6db97">&#9670;&#160;</a></span>onWindowFocusChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::GameInstance::onWindowFocusChanged </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsFocused</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the window focus was changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIsFocused</td><td>Whether the window has gained or lost the focus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b2b339ea3f41d6d71a36ce7c47acb5e" name="a3b2b339ea3f41d6d71a36ce7c47acb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2b339ea3f41d6d71a36ce7c47acb5e">&#9670;&#160;</a></span>queueGarbageCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::queueGarbageCollection </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bForce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::function&lt; void()&gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>onFinished</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Queues a request to run a garbage collection as a deferred task on the main thread using <a class="el" href="classne_1_1GameInstance.html#a9f3763b4fa0eedb9735d02a3face9f5a">addDeferredTask</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Typically you don't need to call this function as garbage collection is executed regularly (see <a class="el" href="classne_1_1GameInstance.html#adcc2960f6fd8aa93c95b6d7f7eb8ee69">setGarbageCollectorRunInterval</a>) but you can still call it anyway.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bForce</td><td>Force run garbage collection even if the last garbage collection was run not so long ago. </td></tr>
    <tr><td class="paramname">onFinished</td><td>Optional callback that will be triggered on the main thread when garbage collection is finished (queued as <a class="el" href="classne_1_1GameInstance.html#a9f3763b4fa0eedb9735d02a3face9f5a">addDeferredTask</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc2960f6fd8aa93c95b6d7f7eb8ee69" name="adcc2960f6fd8aa93c95b6d7f7eb8ee69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc2960f6fd8aa93c95b6d7f7eb8ee69">&#9670;&#160;</a></span>setGarbageCollectorRunInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::setGarbageCollectorRunInterval </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>iGcRunIntervalInSec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Modifies the interval after which we need to run garbage collector again. The current value can be retrieved using <a class="el" href="classne_1_1GameInstance.html#a16e2423872298e507160249708f6bb1e">getGarbageCollectorRunIntervalInSec</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Interval should be in range [30; 300] seconds (otherwise it will be clamped).</dd>
<dd>
Note that garbage collection will also be executed additionally in some special cases, such as when <a class="el" href="classne_1_1World.html">World</a> is being destructed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGcRunIntervalInSec</td><td>Interval in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e23df6476d30d752135ac6229e9b20f" name="a2e23df6476d30d752135ac6229e9b20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e23df6476d30d752135ac6229e9b20f">&#9670;&#160;</a></span>stopAndDisableCreatedTimers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GameInstance::stopAndDisableCreatedTimers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called by owner object to stop and disable all created timers, additionally does not allows creating any more timers. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a315aeac9a8ea882a15033ead66ffc8ec" name="a315aeac9a8ea882a15033ead66ffc8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315aeac9a8ea882a15033ead66ffc8ec">&#9670;&#160;</a></span>bAllowCreatingTimers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::GameInstance::bAllowCreatingTimers = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Whether <a class="el" href="classne_1_1GameInstance.html#abc2070d12e33c6658ff109040a20b324">createTimer</a> works or not. </p>

</div>
</div>
<a id="a9a2b201b1cad1e756f4ecfaa4c019d36" name="a9a2b201b1cad1e756f4ecfaa4c019d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2b201b1cad1e756f4ecfaa4c019d36">&#9670;&#160;</a></span>mtxBindedActionEvents</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, std::unordered_map&lt;unsigned int, std::function&lt;void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt; ne::GameInstance::mtxBindedActionEvents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Map of action events that this <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> is binded to. Must be used with mutex. </p>

</div>
</div>
<a id="af280f5e74bace192c883afce7bbfa179" name="af280f5e74bace192c883afce7bbfa179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af280f5e74bace192c883afce7bbfa179">&#9670;&#160;</a></span>mtxBindedAxisEvents</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, std::unordered_map&lt;unsigned int, std::function&lt;void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt; ne::GameInstance::mtxBindedAxisEvents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Map of axis events that this <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> is binded to. Must be used with mutex. </p>

</div>
</div>
<a id="a57d67eeab693b01a3feea546861566ee" name="a57d67eeab693b01a3feea546861566ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d67eeab693b01a3feea546861566ee">&#9670;&#160;</a></span>mtxCreatedTimers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, std::vector&lt;std::unique_ptr&lt;<a class="el" href="classne_1_1Timer.html">Timer</a>&gt; &gt; &gt; ne::GameInstance::mtxCreatedTimers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Timers creates via <a class="el" href="classne_1_1GameInstance.html#abc2070d12e33c6658ff109040a20b324">createTimer</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Don't remove/erase timers from this array because in callback validator's deferred task we will use the timer to check its state so we need to make sure that stopped timer will not be deleted while the object exists. </dd></dl>

</div>
</div>
<a id="ac13ef9e4f2be1010406d6e3d62d7a9de" name="ac13ef9e4f2be1010406d6e3d62d7a9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13ef9e4f2be1010406d6e3d62d7a9de">&#9670;&#160;</a></span>pGameManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1GameManager.html">GameManager</a>* ne::GameInstance::pGameManager = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Do not delete. Owner of this object. </p>

</div>
</div>
<a id="a4f65dca260b1f8581b1c30a2be4f5316" name="a4f65dca260b1f8581b1c30a2be4f5316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f65dca260b1f8581b1c30a2be4f5316">&#9670;&#160;</a></span>pGameWindow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Window.html">Window</a>* ne::GameInstance::pGameWindow = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Do not delete. Owner of <a class="el" href="classne_1_1GameInstance.html#ac13ef9e4f2be1010406d6e3d62d7a9de">pGameManager</a> object. </p>

</div>
</div>
<a id="a7e778278348dc1e1b27b1b2183d00625" name="a7e778278348dc1e1b27b1b2183d00625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e778278348dc1e1b27b1b2183d00625">&#9670;&#160;</a></span>pInputManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1InputManager.html">InputManager</a>* ne::GameInstance::pInputManager = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Do not delete. Input manager of the <a class="el" href="classne_1_1GameInstance.html#ac13ef9e4f2be1010406d6e3d62d7a9de">pGameManager</a> object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/public/game/<a class="el" href="GameInstance_8h_source.html">GameInstance.h</a></li>
<li>src/engine_lib/private/game/GameInstance.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1GameInstance.html">GameInstance</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
