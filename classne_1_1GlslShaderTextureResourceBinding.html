<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::GlslShaderTextureResourceBinding Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1GlslShaderTextureResourceBinding.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1GlslShaderTextureResourceBinding-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::GlslShaderTextureResourceBinding Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="GlslShaderTextureResourceBinding_8h_source.html">GlslShaderTextureResourceBinding.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::GlslShaderTextureResourceBinding:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1GlslShaderTextureResourceBinding.png" usemap="#ne::GlslShaderTextureResourceBinding_map" alt=""/>
  <map id="ne::GlslShaderTextureResourceBinding_map" name="ne::GlslShaderTextureResourceBinding_map">
<area href="classne_1_1ShaderTextureResourceBinding.html" alt="ne::ShaderTextureResourceBinding" shape="rect" coords="0,56,232,80"/>
<area href="classne_1_1ShaderResourceBindingBase.html" alt="ne::ShaderResourceBindingBase" shape="rect" coords="0,0,232,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1GlslShaderTextureResourceBinding_1_1PushConstantIndices.html">PushConstantIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01eb6c04b78151d3402cbdedea9867dc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#a01eb6c04b78151d3402cbdedea9867dc">getPathToTextureResource</a> ()</td></tr>
<tr class="separator:a01eb6c04b78151d3402cbdedea9867dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145dda4a9f6868404db29cd0b1588621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#a145dda4a9f6868404db29cd0b1588621">copyResourceIndexToPushConstants</a> (<a class="el" href="classne_1_1PipelineShaderConstantsManager.html">PipelineShaderConstantsManager</a> *pPushConstantsManager, <a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *pUsedPipeline)</td></tr>
<tr class="separator:a145dda4a9f6868404db29cd0b1588621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63076ba6c94ff19e3b1268b77be8041"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#af63076ba6c94ff19e3b1268b77be8041">useNewTexture</a> (std::unique_ptr&lt; <a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a> &gt; pTextureToUse) override</td></tr>
<tr class="separator:af63076ba6c94ff19e3b1268b77be8041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b72c64b7d785dce01fde577c3988c9f"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#a4b72c64b7d785dce01fde577c3988c9f">changeUsedPipelines</a> (const std::unordered_set&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * &gt; &amp;pipelinesToUse) override</td></tr>
<tr class="separator:a4b72c64b7d785dce01fde577c3988c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4e143f594bbe46d08065f0b8bd03ca"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderTextureResourceBinding.html#add4e143f594bbe46d08065f0b8bd03ca">useNewTexture</a> (std::unique_ptr&lt; <a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a> &gt; pTextureToUse)=0</td></tr>
<tr class="separator:add4e143f594bbe46d08065f0b8bd03ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1ShaderResourceBindingBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1ShaderResourceBindingBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1ShaderResourceBindingBase.html">ne::ShaderResourceBindingBase</a></td></tr>
<tr class="memitem:a994a141941a81fd2058c36f144c1685f inherit pub_methods_classne_1_1ShaderResourceBindingBase"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderResourceBindingBase.html#a994a141941a81fd2058c36f144c1685f">changeUsedPipelines</a> (const std::unordered_set&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * &gt; &amp;pipelinesToUse)=0</td></tr>
<tr class="separator:a994a141941a81fd2058c36f144c1685f inherit pub_methods_classne_1_1ShaderResourceBindingBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741dd05156bdd35eed54ab3e549b448c inherit pub_methods_classne_1_1ShaderResourceBindingBase"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderResourceBindingBase.html#a741dd05156bdd35eed54ab3e549b448c">getShaderResourceName</a> () const</td></tr>
<tr class="separator:a741dd05156bdd35eed54ab3e549b448c inherit pub_methods_classne_1_1ShaderResourceBindingBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad1944b0ed6f014801b6bfcf117d82808"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#ad1944b0ed6f014801b6bfcf117d82808">GlslShaderTextureResourceBinding</a> (const std::string &amp;sResourceName, std::unique_ptr&lt; <a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a> &gt; pTextureToUse, std::unordered_map&lt; <a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *, <a class="el" href="structne_1_1GlslShaderTextureResourceBinding_1_1PushConstantIndices.html">PushConstantIndices</a> &gt; pushConstantIndices)</td></tr>
<tr class="separator:ad1944b0ed6f014801b6bfcf117d82808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcec2ee9f7c94f9dad2bbe1637a7505"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#acdcec2ee9f7c94f9dad2bbe1637a7505">onAfterAllPipelinesRefreshedResources</a> () override</td></tr>
<tr class="separator:acdcec2ee9f7c94f9dad2bbe1637a7505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classne_1_1ShaderTextureResourceBinding"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classne_1_1ShaderTextureResourceBinding')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classne_1_1ShaderTextureResourceBinding.html">ne::ShaderTextureResourceBinding</a></td></tr>
<tr class="memitem:aa9ee18e305ac2dd28e568b26547ed002 inherit pro_methods_classne_1_1ShaderTextureResourceBinding"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderTextureResourceBinding.html#aa9ee18e305ac2dd28e568b26547ed002">ShaderTextureResourceBinding</a> (const std::string &amp;<a class="el" href="classne_1_1ShaderResourceBindingBase.html#a9f8fc5fdd024fa41de9e601b633ab649">sShaderResourceName</a>)</td></tr>
<tr class="separator:aa9ee18e305ac2dd28e568b26547ed002 inherit pro_methods_classne_1_1ShaderTextureResourceBinding"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classne_1_1ShaderResourceBindingBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classne_1_1ShaderResourceBindingBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classne_1_1ShaderResourceBindingBase.html">ne::ShaderResourceBindingBase</a></td></tr>
<tr class="memitem:a605b56970e874418a368dda9eca826ef inherit pro_methods_classne_1_1ShaderResourceBindingBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderResourceBindingBase.html#a605b56970e874418a368dda9eca826ef">ShaderResourceBindingBase</a> (const std::string &amp;<a class="el" href="classne_1_1ShaderResourceBindingBase.html#a9f8fc5fdd024fa41de9e601b633ab649">sShaderResourceName</a>)</td></tr>
<tr class="separator:a605b56970e874418a368dda9eca826ef inherit pro_methods_classne_1_1ShaderResourceBindingBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb20e00c70013812394fc38f24677c8 inherit pro_methods_classne_1_1ShaderResourceBindingBase"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderResourceBindingBase.html#aeeb20e00c70013812394fc38f24677c8">onAfterAllPipelinesRefreshedResources</a> ()=0</td></tr>
<tr class="separator:aeeb20e00c70013812394fc38f24677c8 inherit pro_methods_classne_1_1ShaderResourceBindingBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a3c821a0fa63e7de55ec3c83cd917f2ba"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderTextureResourceBinding.html">ShaderTextureResourceBinding</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#a3c821a0fa63e7de55ec3c83cd917f2ba">create</a> (const std::string &amp;<a class="el" href="classne_1_1ShaderResourceBindingBase.html#a9f8fc5fdd024fa41de9e601b633ab649">sShaderResourceName</a>, const std::unordered_set&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * &gt; &amp;pipelinesToUse, std::unique_ptr&lt; <a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a> &gt; pTextureToUse)</td></tr>
<tr class="separator:a3c821a0fa63e7de55ec3c83cd917f2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd12447a47da8fc586344fa986bef8d4"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderArrayIndex.html">ShaderArrayIndex</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#afd12447a47da8fc586344fa986bef8d4">getTextureIndexInShaderArray</a> (const std::string &amp;<a class="el" href="classne_1_1ShaderResourceBindingBase.html#a9f8fc5fdd024fa41de9e601b633ab649">sShaderResourceName</a>, <a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *pPipelineToLookIn)</td></tr>
<tr class="separator:afd12447a47da8fc586344fa986bef8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7122799f95a484576f9cc952d29bc4fb"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#a7122799f95a484576f9cc952d29bc4fb">bindTextureToShaderDescriptorArray</a> (const std::string &amp;<a class="el" href="classne_1_1ShaderResourceBindingBase.html#a9f8fc5fdd024fa41de9e601b633ab649">sShaderResourceName</a>, <a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *pPipelineWithDescriptors, <a class="el" href="classne_1_1VulkanResource.html">VulkanResource</a> *pTexture, unsigned int iIndexIntoShaderArray)</td></tr>
<tr class="separator:a7122799f95a484576f9cc952d29bc4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad8d3fed85b5b7719de489029a716260a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::mutex, std::unique_ptr&lt; <a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#ad8d3fed85b5b7719de489029a716260a">mtxUsedTexture</a></td></tr>
<tr class="separator:ad8d3fed85b5b7719de489029a716260a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9761cda29f21727e708d17bcfbe524d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; <a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *, <a class="el" href="structne_1_1GlslShaderTextureResourceBinding_1_1PushConstantIndices.html">PushConstantIndices</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#aa9761cda29f21727e708d17bcfbe524d">mtxPushConstantIndices</a></td></tr>
<tr class="separator:aa9761cda29f21727e708d17bcfbe524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa187ebc79a4389a950fa2551ab7160f9"><td class="memItemLeft" align="right" valign="top"><a id="aa187ebc79a4389a950fa2551ab7160f9" name="aa187ebc79a4389a950fa2551ab7160f9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderTextureResourceBindingManager</b></td></tr>
<tr class="separator:aa187ebc79a4389a950fa2551ab7160f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >References some texture from shader code. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad1944b0ed6f014801b6bfcf117d82808" name="ad1944b0ed6f014801b6bfcf117d82808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1944b0ed6f014801b6bfcf117d82808">&#9670;&#160;</a></span>GlslShaderTextureResourceBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ne::GlslShaderTextureResourceBinding::GlslShaderTextureResourceBinding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>pTextureToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *, <a class="el" href="structne_1_1GlslShaderTextureResourceBinding_1_1PushConstantIndices.html">PushConstantIndices</a> &gt;&#160;</td>
          <td class="paramname"><em>pushConstantIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initializes the resource.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Used internally, for outside usage prefer to use <a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html#a3c821a0fa63e7de55ec3c83cd917f2ba">create</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sResourceName</td><td>Name of the resource we are referencing (should be exactly the same as the resource name written in the shader file we are referencing). </td></tr>
    <tr><td class="paramname">pTextureToUse</td><td>Texture that should be binded to a descriptor in shader array. </td></tr>
    <tr><td class="paramname">pushConstantIndices</td><td>Indices of push constants (per-pipeline) to copy texture index to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7122799f95a484576f9cc952d29bc4fb" name="a7122799f95a484576f9cc952d29bc4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7122799f95a484576f9cc952d29bc4fb">&#9670;&#160;</a></span>bindTextureToShaderDescriptorArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::GlslShaderTextureResourceBinding::bindTextureToShaderDescriptorArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *&#160;</td>
          <td class="paramname"><em>pPipelineWithDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1VulkanResource.html">VulkanResource</a> *&#160;</td>
          <td class="paramname"><em>pTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iIndexIntoShaderArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Binds the specified image view to the sampler descriptor of the specified pipeline for binding that corresponds to the specified shader resource name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the shader resource to get binding index in descriptor set. </td></tr>
    <tr><td class="paramname">pPipelineWithDescriptors</td><td><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> which descriptors to use. </td></tr>
    <tr><td class="paramname">pTexture</td><td>Texture to bind. </td></tr>
    <tr><td class="paramname">iIndexIntoShaderArray</td><td>Index to a descriptor (in the shader texture array) to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a4b72c64b7d785dce01fde577c3988c9f" name="a4b72c64b7d785dce01fde577c3988c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b72c64b7d785dce01fde577c3988c9f">&#9670;&#160;</a></span>changeUsedPipelines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::GlslShaderTextureResourceBinding::changeUsedPipelines </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelinesToUse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called to make the resource to discard currently used pipelines and bind/reference other pipelines.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the caller is using some mutex to protect this shader resource from being used in the <code>draw</code> function while this function is not finished (i.e. make sure the CPU will not queue a new frame while this function is not finished).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For example, for this function can be called from a mesh node that changed its geometry and thus added/removed some material slots, or if some material that mesh node is using changed its pipeline.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelinesToUse</td><td>Pipelines to use instead of the current ones.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

<p>Implements <a class="el" href="classne_1_1ShaderResourceBindingBase.html#a994a141941a81fd2058c36f144c1685f">ne::ShaderResourceBindingBase</a>.</p>

</div>
</div>
<a id="a145dda4a9f6868404db29cd0b1588621" name="a145dda4a9f6868404db29cd0b1588621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145dda4a9f6868404db29cd0b1588621">&#9670;&#160;</a></span>copyResourceIndexToPushConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::GlslShaderTextureResourceBinding::copyResourceIndexToPushConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1PipelineShaderConstantsManager.html">PipelineShaderConstantsManager</a> *&#160;</td>
          <td class="paramname"><em>pPushConstantsManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *&#160;</td>
          <td class="paramname"><em>pUsedPipeline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Copies resource index (into shader arrays) to a push constant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPushConstantsManager</td><td>Push constants manager. </td></tr>
    <tr><td class="paramname">pUsedPipeline</td><td>Current pipeline. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c821a0fa63e7de55ec3c83cd917f2ba" name="a3c821a0fa63e7de55ec3c83cd917f2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c821a0fa63e7de55ec3c83cd917f2ba">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderTextureResourceBinding.html">ShaderTextureResourceBinding</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::GlslShaderTextureResourceBinding::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelinesToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>pTextureToUse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a GLSL shader resource for referencing texture in shader array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the resource we are referencing (should be exactly the same as the resource name written in the shader file we are referencing). </td></tr>
    <tr><td class="paramname">pipelinesToUse</td><td>Pipelines that use shader/parameters we are referencing. </td></tr>
    <tr><td class="paramname">pTextureToUse</td><td>Texture that should be binded to a descriptor in shader array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise created shader resource. </dd></dl>

</div>
</div>
<a id="a01eb6c04b78151d3402cbdedea9867dc" name="a01eb6c04b78151d3402cbdedea9867dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01eb6c04b78151d3402cbdedea9867dc">&#9670;&#160;</a></span>getPathToTextureResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::GlslShaderTextureResourceBinding::getPathToTextureResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns path to a file/directory that stores used texture resource.</p>
<dl class="section return"><dt>Returns</dt><dd>Path relative to the <code>res</code> directory. </dd></dl>

</div>
</div>
<a id="afd12447a47da8fc586344fa986bef8d4" name="afd12447a47da8fc586344fa986bef8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd12447a47da8fc586344fa986bef8d4">&#9670;&#160;</a></span>getTextureIndexInShaderArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderArrayIndex.html">ShaderArrayIndex</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::GlslShaderTextureResourceBinding::getTextureIndexInShaderArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a> *&#160;</td>
          <td class="paramname"><em>pPipelineToLookIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Asks the index manager for an index into the requested shader array resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the shader array resource defined in GLSL. </td></tr>
    <tr><td class="paramname">pPipelineToLookIn</td><td><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> to look for an index manager that will provide the index into shader array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise received index into shader array. </dd></dl>

</div>
</div>
<a id="acdcec2ee9f7c94f9dad2bbe1637a7505" name="acdcec2ee9f7c94f9dad2bbe1637a7505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdcec2ee9f7c94f9dad2bbe1637a7505">&#9670;&#160;</a></span>onAfterAllPipelinesRefreshedResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::GlslShaderTextureResourceBinding::onAfterAllPipelinesRefreshedResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from pipeline manager to notify that all pipelines released their internal resources and now restored them so their internal resources (for example push constants) might be different now and shader resource now needs to check that everything that it needs is still there and possibly re-bind to pipeline's descriptors since these might have been also re-created.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

<p>Implements <a class="el" href="classne_1_1ShaderResourceBindingBase.html#aeeb20e00c70013812394fc38f24677c8">ne::ShaderResourceBindingBase</a>.</p>

</div>
</div>
<a id="af63076ba6c94ff19e3b1268b77be8041" name="af63076ba6c94ff19e3b1268b77be8041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63076ba6c94ff19e3b1268b77be8041">&#9670;&#160;</a></span>useNewTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::GlslShaderTextureResourceBinding::useNewTexture </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>pTextureToUse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Makes the shader resource to reference the new (specified) texture.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the caller is using some mutex to protect this shader resource from being used in the <code>draw</code> function while this function is not finished (i.e. make sure the CPU will not queue a new frame while this function is not finished).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTextureToUse</td><td>Texture to reference.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

<p>Implements <a class="el" href="classne_1_1ShaderTextureResourceBinding.html#add4e143f594bbe46d08065f0b8bd03ca">ne::ShaderTextureResourceBinding</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa9761cda29f21727e708d17bcfbe524d" name="aa9761cda29f21727e708d17bcfbe524d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9761cda29f21727e708d17bcfbe524d">&#9670;&#160;</a></span>mtxPushConstantIndices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, std::unordered_map&lt;<a class="el" href="classne_1_1VulkanPipeline.html">VulkanPipeline</a>*, <a class="el" href="structne_1_1GlslShaderTextureResourceBinding_1_1PushConstantIndices.html">PushConstantIndices</a>&gt; &gt; ne::GlslShaderTextureResourceBinding::mtxPushConstantIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Index of push constant (per-pipeline) to copy index into shader array. </p>

</div>
</div>
<a id="ad8d3fed85b5b7719de489029a716260a" name="ad8d3fed85b5b7719de489029a716260a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d3fed85b5b7719de489029a716260a">&#9670;&#160;</a></span>mtxUsedTexture</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::mutex, std::unique_ptr&lt;<a class="el" href="classne_1_1TextureHandle.html">TextureHandle</a>&gt; &gt; ne::GlslShaderTextureResourceBinding::mtxUsedTexture</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Texture that we bind to descriptor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/private/shader/glsl/resource/binding/texture/<a class="el" href="GlslShaderTextureResourceBinding_8h_source.html">GlslShaderTextureResourceBinding.h</a></li>
<li>src/engine_lib/private/shader/glsl/resource/binding/texture/GlslShaderTextureResourceBinding.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1GlslShaderTextureResourceBinding.html">GlslShaderTextureResourceBinding</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
