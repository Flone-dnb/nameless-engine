<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::Material Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1Material.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1Material-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::Material Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Material_8h_source.html">Material.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::Material:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1Material.png" usemap="#ne::Material_map" alt=""/>
  <map id="ne::Material_map" name="ne::Material_map">
<area href="classne_1_1Serializable.html" alt="ne::Serializable" shape="rect" coords="0,56,98,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1Material_1_1GpuResources.html">GpuResources</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1Material_1_1InternalResources.html">InternalResources</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1Material_1_1MaterialShaderConstants.html">MaterialShaderConstants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0970484073a752aed3a6704a85be04b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a0970484073a752aed3a6704a85be04b4">Material</a> ()</td></tr>
<tr class="separator:a0970484073a752aed3a6704a85be04b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e048e4fa4548a394c146727286c5987"><td class="memItemLeft" align="right" valign="top"><a id="a6e048e4fa4548a394c146727286c5987" name="a6e048e4fa4548a394c146727286c5987"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Material</b> (const <a class="el" href="classne_1_1Material.html">Material</a> &amp;)=delete</td></tr>
<tr class="separator:a6e048e4fa4548a394c146727286c5987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8462b492623fc9140a25a13fa65635cb"><td class="memItemLeft" align="right" valign="top"><a id="a8462b492623fc9140a25a13fa65635cb" name="a8462b492623fc9140a25a13fa65635cb"></a>
<a class="el" href="classne_1_1Material.html">Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1Material.html">Material</a> &amp;)=delete</td></tr>
<tr class="separator:a8462b492623fc9140a25a13fa65635cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1abba43e7ecc07d1740bc75872c050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a5e1abba43e7ecc07d1740bc75872c050">setEnableTransparency</a> (bool bEnable)</td></tr>
<tr class="separator:a5e1abba43e7ecc07d1740bc75872c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3ef9edcab7dc00f3449fcefee66bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a3f3ef9edcab7dc00f3449fcefee66bea">setDiffuseColor</a> (const glm::vec3 &amp;<a class="el" href="classne_1_1Material.html#a24db045bd570219481d2a2e2c7fa99f4">diffuseColor</a>)</td></tr>
<tr class="separator:a3f3ef9edcab7dc00f3449fcefee66bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c6e1c40cc75ce6e8f93b30c60ad8f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a44c6e1c40cc75ce6e8f93b30c60ad8f3">setDiffuseTexture</a> (const std::string &amp;sTextureResourcePathRelativeRes)</td></tr>
<tr class="separator:a44c6e1c40cc75ce6e8f93b30c60ad8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fa00d994567a8e00e010bca321253d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ac7fa00d994567a8e00e010bca321253d">setSpecularColor</a> (const glm::vec3 &amp;<a class="el" href="classne_1_1Material.html#a5d4c5f42d34b2bd22969db838551373b">specularColor</a>)</td></tr>
<tr class="separator:ac7fa00d994567a8e00e010bca321253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120643a43142cb24e81bbec6dd8f6dc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a120643a43142cb24e81bbec6dd8f6dc2">setRoughness</a> (float <a class="el" href="classne_1_1Material.html#a75f8887c5bab282d23e95d6c5077f66b">roughness</a>)</td></tr>
<tr class="separator:a120643a43142cb24e81bbec6dd8f6dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1e2ef9f66f9f8e69658de3bb3fb491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a2c1e2ef9f66f9f8e69658de3bb3fb491">setOpacity</a> (float <a class="el" href="classne_1_1Material.html#a0baf76cad634fde0115a9285f51771c1">opacity</a>=1.0F)</td></tr>
<tr class="separator:a2c1e2ef9f66f9f8e69658de3bb3fb491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88305277fcf45b2d54ffdb0e7de731d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a88305277fcf45b2d54ffdb0e7de731d2">isTransparencyEnabled</a> ()</td></tr>
<tr class="separator:a88305277fcf45b2d54ffdb0e7de731d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe13b5a88171864d83f787303b87ebe"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#aafe13b5a88171864d83f787303b87ebe">getDiffuseColor</a> () const</td></tr>
<tr class="separator:aafe13b5a88171864d83f787303b87ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18626e7a64af061617da9fd328a6e3b"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#af18626e7a64af061617da9fd328a6e3b">getSpecularColor</a> () const</td></tr>
<tr class="separator:af18626e7a64af061617da9fd328a6e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6d5d76aa52f5e312a871edba8d001f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#aae6d5d76aa52f5e312a871edba8d001f">getPathToDiffuseTextureResource</a> ()</td></tr>
<tr class="separator:aae6d5d76aa52f5e312a871edba8d001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f38075d473d23e8255a0cab5e3126e2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a0f38075d473d23e8255a0cab5e3126e2">getRoughness</a> () const</td></tr>
<tr class="separator:a0f38075d473d23e8255a0cab5e3126e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0467877a11e184dc5f0627dd1cbd02d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ad0467877a11e184dc5f0627dd1cbd02d">getOpacity</a> () const</td></tr>
<tr class="separator:ad0467877a11e184dc5f0627dd1cbd02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22972cb7fc8c34cd1e25794604c6f88f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::mutex, <a class="el" href="structne_1_1MeshNodesThatUseThisMaterial.html">MeshNodesThatUseThisMaterial</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a22972cb7fc8c34cd1e25794604c6f88f">getSpawnedMeshNodesThatUseThisMaterial</a> ()</td></tr>
<tr class="separator:a22972cb7fc8c34cd1e25794604c6f88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5109eeb024a2f06e7bdd6a739118ca"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a7a5109eeb024a2f06e7bdd6a739118ca">getMaterialName</a> () const</td></tr>
<tr class="separator:a7a5109eeb024a2f06e7bdd6a739118ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5fc8093b532caee4ab8293f4964198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#acb5fc8093b532caee4ab8293f4964198">isUsingTransparency</a> () const</td></tr>
<tr class="separator:acb5fc8093b532caee4ab8293f4964198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72f306a7b3eb645832d4b850108110a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ae72f306a7b3eb645832d4b850108110a">getColorPipeline</a> () const</td></tr>
<tr class="separator:ae72f306a7b3eb645832d4b850108110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b40a74637b5be997eb63c999773f52e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a0b40a74637b5be997eb63c999773f52e">getDepthOnlyPipeline</a> () const</td></tr>
<tr class="separator:a0b40a74637b5be997eb63c999773f52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1879f119b0b281dd2f421a135bb74329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a1879f119b0b281dd2f421a135bb74329">getShadowMappingDirectionalSpotPipeline</a> () const</td></tr>
<tr class="separator:a1879f119b0b281dd2f421a135bb74329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdabd9fd25213f1c33138d978ddafdd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#afdabd9fd25213f1c33138d978ddafdd1">getShadowMappingPointPipeline</a> () const</td></tr>
<tr class="separator:afdabd9fd25213f1c33138d978ddafdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ad940792aec3452dc12e8af8ef1f21"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1Material_1_1GpuResources.html">GpuResources</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a37ad940792aec3452dc12e8af8ef1f21">getMaterialGpuResources</a> ()</td></tr>
<tr class="separator:a37ad940792aec3452dc12e8af8ef1f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c74feacb9365a1dffd9499374403bd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a37c74feacb9365a1dffd9499374403bd">getVertexShaderName</a> () const</td></tr>
<tr class="separator:a37c74feacb9365a1dffd9499374403bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819dd3b1497a89dc06e811b12329181d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a819dd3b1497a89dc06e811b12329181d">getPixelShaderName</a> () const</td></tr>
<tr class="separator:a819dd3b1497a89dc06e811b12329181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a2b1c9ee24ea69f0b6231eff5a262e348 inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a2b1c9ee24ea69f0b6231eff5a262e348">serialize</a> (std::filesystem::path pathToFile, bool bEnableBackup, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={})</td></tr>
<tr class="separator:a2b1c9ee24ea69f0b6231eff5a262e348 inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a79714019d1b40ce8d063b920bbdcf inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af0a79714019d1b40ce8d063b920bbdcf">serialize</a> (toml::value &amp;tomlData, const std::string &amp;sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:af0a79714019d1b40ce8d063b920bbdcf inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99dd41bee3fdcea40c80bf317cc590d inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#aa99dd41bee3fdcea40c80bf317cc590d">serialize</a> (toml::value &amp;tomlData, <a class="el" href="classne_1_1Serializable.html">Serializable</a> *pOriginalObject, std::string sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:aa99dd41bee3fdcea40c80bf317cc590d inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0404cdf34dc3fb25b7932a87ed9ade38 inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a0404cdf34dc3fb25b7932a87ed9ade38">getPathDeserializedFromRelativeToRes</a> () const</td></tr>
<tr class="separator:a0404cdf34dc3fb25b7932a87ed9ade38 inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad3f8b2e84ad7f53c3a100894bfd6c3e2"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ad3f8b2e84ad7f53c3a100894bfd6c3e2">getCurrentAliveMaterialCount</a> ()</td></tr>
<tr class="separator:ad3f8b2e84ad7f53c3a100894bfd6c3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b008d630640dbfc2281ed97e979ecd"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1Material.html">Material</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ac3b008d630640dbfc2281ed97e979ecd">create</a> (const std::string &amp;<a class="el" href="classne_1_1Material.html#a58ded283439b569c213839ef49e820a9">sVertexShaderName</a>, const std::string &amp;<a class="el" href="classne_1_1Material.html#a30a5becd28841cfc24365e2d55a77de6">sPixelShaderName</a>, bool <a class="el" href="classne_1_1Material.html#ace5bae8c52442a43d2c2f03501989d08">bUseTransparency</a>, const std::string &amp;<a class="el" href="classne_1_1Material.html#a89b5b82ea6d591ab0c434a7d2d1a8015">sMaterialName</a>=&quot;Material&quot;)</td></tr>
<tr class="separator:ac3b008d630640dbfc2281ed97e979ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a6cd50b9cef87748dede76ba3ef125e43 inherit pub_static_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::pair&lt; std::set&lt; std::string &gt;, toml::value &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a6cd50b9cef87748dede76ba3ef125e43">getIdsFromFile</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a6cd50b9cef87748dede76ba3ef125e43 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f76ea78f80fb43e5e481277a930b364 inherit pub_static_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a1f76ea78f80fb43e5e481277a930b364">serializeMultiple</a> (std::filesystem::path pathToFile, std::vector&lt; <a class="el" href="structne_1_1SerializableObjectInformation.html">SerializableObjectInformation</a> &gt; vObjects, bool bEnableBackup)</td></tr>
<tr class="separator:a1f76ea78f80fb43e5e481277a930b364 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a> (const std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a3162d0dbc003bfcef8c0ae0846b32f77">deserialize</a> (const std::filesystem::path &amp;pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes)</td></tr>
<tr class="separator:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a32a58a89522b5cca64db7b6750a73a19">deserialize</a> (std::filesystem::path pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#afb8e66a57cc108fca4d35ae40de8e22a">deserialize</a> (const std::filesystem::path &amp;pathToFile, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::same_as&lt;SmartPointer, sgc::GcPtr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; std::vector&lt; <a class="el" href="structne_1_1DeserializedObjectInformation.html">DeserializedObjectInformation</a>&lt; SmartPointer &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a5d16d519e3d326cbdc101e78ca1a2478">deserializeMultiple</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af67ef936c5d20e2f861430b48c69c95a">deserialize</a> (const toml::value &amp;tomlData, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, std::string sEntityId=&quot;&quot;, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={})</td></tr>
<tr class="separator:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7946faee0b5231b38196c9cc8c2dffd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a7946faee0b5231b38196c9cc8c2dffd4">onAfterDeserialized</a> () override</td></tr>
<tr class="separator:a7946faee0b5231b38196c9cc8c2dffd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00002d59e5d0dcda6e53c20b59947150"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a00002d59e5d0dcda6e53c20b59947150">onAfterDeserialized</a> ()</td></tr>
<tr class="separator:a00002d59e5d0dcda6e53c20b59947150"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af88101c98cc96028ca9cfb4f6fbebf96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#af88101c98cc96028ca9cfb4f6fbebf96">Material</a> (const std::string &amp;<a class="el" href="classne_1_1Material.html#a58ded283439b569c213839ef49e820a9">sVertexShaderName</a>, const std::string &amp;<a class="el" href="classne_1_1Material.html#a30a5becd28841cfc24365e2d55a77de6">sPixelShaderName</a>, bool <a class="el" href="classne_1_1Material.html#ace5bae8c52442a43d2c2f03501989d08">bUseTransparency</a>, <a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> *<a class="el" href="classne_1_1Material.html#a217c2e878ea6111089fea8b9d6372b9d">pPipelineManager</a>, const std::string &amp;<a class="el" href="classne_1_1Material.html#a89b5b82ea6d591ab0c434a7d2d1a8015">sMaterialName</a>=&quot;Material&quot;)</td></tr>
<tr class="separator:af88101c98cc96028ca9cfb4f6fbebf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f72b3b50221e37374506f7a4c344422"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a1f72b3b50221e37374506f7a4c344422">onMeshNodeSpawning</a> (<a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *pMeshNode, const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;indexBufferToDisplay)</td></tr>
<tr class="separator:a1f72b3b50221e37374506f7a4c344422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39df1e140902043bd534cb3279d3d665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a39df1e140902043bd534cb3279d3d665">onSpawnedMeshNodeStartedUsingMaterial</a> (<a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *pMeshNode, const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;indexBufferToDisplay)</td></tr>
<tr class="separator:a39df1e140902043bd534cb3279d3d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dca5d184d1079603751789ef76edc62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a5dca5d184d1079603751789ef76edc62">onSpawnedMeshNodeRecreatedIndexBuffer</a> (<a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *pMeshNode, const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;deletedIndexBuffer, const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;newIndexBuffer)</td></tr>
<tr class="separator:a5dca5d184d1079603751789ef76edc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f4e887a2fda3da02f4875eb60053ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a05f4e887a2fda3da02f4875eb60053ec">onSpawnedMeshNodeChangedVisibility</a> (<a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *pMeshNode, bool bOldVisibility)</td></tr>
<tr class="separator:a05f4e887a2fda3da02f4875eb60053ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba3060536452524bb96ae049d050289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a6ba3060536452524bb96ae049d050289">onSpawnedMeshNodeStoppedUsingMaterial</a> (<a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *pMeshNode, const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;indexBufferDisplayed)</td></tr>
<tr class="separator:a6ba3060536452524bb96ae049d050289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e3a6939b7619716744eadb2a7a0723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#af1e3a6939b7619716744eadb2a7a0723">onMeshNodeDespawning</a> (<a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *pMeshNode, const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;indexBufferDisplayed)</td></tr>
<tr class="separator:af1e3a6939b7619716744eadb2a7a0723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6582e8a2f026a45c61396bfe8f1feb"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#adf6582e8a2f026a45c61396bfe8f1feb">initializePipelines</a> ()</td></tr>
<tr class="separator:adf6582e8a2f026a45c61396bfe8f1feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94a42c86625c72a14036cae1e2db707"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ad94a42c86625c72a14036cae1e2db707">resetPipelines</a> ()</td></tr>
<tr class="separator:ad94a42c86625c72a14036cae1e2db707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad098fa1bc60126bee59d73a9ba5a55a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ad098fa1bc60126bee59d73a9ba5a55a4">allocateShaderResources</a> ()</td></tr>
<tr class="separator:ad098fa1bc60126bee59d73a9ba5a55a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3395d21390030fd5e0b7da98b96b751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ac3395d21390030fd5e0b7da98b96b751">deallocateShaderResources</a> ()</td></tr>
<tr class="separator:ac3395d21390030fd5e0b7da98b96b751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd758e7acff200a7b93ca29304cbbcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a1bd758e7acff200a7b93ca29304cbbcd">setShaderCpuWriteResourceBinding</a> (const std::string &amp;sShaderResourceName, size_t iResourceSizeInBytes, const std::function&lt; void *()&gt; &amp;onStartedUpdatingResource, const std::function&lt; void()&gt; &amp;onFinishedUpdatingResource)</td></tr>
<tr class="separator:a1bd758e7acff200a7b93ca29304cbbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799ecf3e2da01410a1823f6132a12fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a799ecf3e2da01410a1823f6132a12fa9">setShaderTextureResourceBinding</a> (const std::string &amp;sShaderResourceName, const std::string &amp;sPathToTextureResourceRelativeRes)</td></tr>
<tr class="separator:a799ecf3e2da01410a1823f6132a12fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2092ab1b66f459ce1b690e053488a5aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a2092ab1b66f459ce1b690e053488a5aa">markShaderCpuWriteResourceAsNeedsUpdate</a> (const std::string &amp;sShaderResourceName)</td></tr>
<tr class="separator:a2092ab1b66f459ce1b690e053488a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55308869a89ec874f334de5843030c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a55308869a89ec874f334de5843030c85">updateToNewPipeline</a> ()</td></tr>
<tr class="separator:a55308869a89ec874f334de5843030c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c2abbb8c345c5a1b2e121a20f68175"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a82c2abbb8c345c5a1b2e121a20f68175">onStartUpdatingShaderMeshConstants</a> ()</td></tr>
<tr class="separator:a82c2abbb8c345c5a1b2e121a20f68175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4f2a67629155070efdac11fbdae46e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#acc4f2a67629155070efdac11fbdae46e">onFinishedUpdatingShaderMeshConstants</a> ()</td></tr>
<tr class="separator:acc4f2a67629155070efdac11fbdae46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b10095374d989f99a568299b663ea1b"><td class="memItemLeft" align="right" valign="top">std::set&lt; ShaderMacro &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a9b10095374d989f99a568299b663ea1b">getVertexShaderMacrosForCurrentState</a> ()</td></tr>
<tr class="separator:a9b10095374d989f99a568299b663ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab749c0e8cae5d47f5a78b3617d538f52"><td class="memItemLeft" align="right" valign="top">std::set&lt; ShaderMacro &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ab749c0e8cae5d47f5a78b3617d538f52">getPixelShaderMacrosForCurrentState</a> ()</td></tr>
<tr class="separator:ab749c0e8cae5d47f5a78b3617d538f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a4d8b157a95a2ee1968b2fe9994be623c"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; <a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> *, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a4d8b157a95a2ee1968b2fe9994be623c">getPipelineManagerForNewMaterial</a> (const std::string &amp;<a class="el" href="classne_1_1Material.html#a58ded283439b569c213839ef49e820a9">sVertexShaderName</a>, const std::string &amp;<a class="el" href="classne_1_1Material.html#a30a5becd28841cfc24365e2d55a77de6">sPixelShaderName</a>)</td></tr>
<tr class="separator:a4d8b157a95a2ee1968b2fe9994be623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4b40c304da2d5ca6098d421fc60116ef"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::mutex, <a class="el" href="structne_1_1MeshNodesThatUseThisMaterial.html">MeshNodesThatUseThisMaterial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a4b40c304da2d5ca6098d421fc60116ef">mtxSpawnedMeshNodesThatUseThisMaterial</a></td></tr>
<tr class="separator:a4b40c304da2d5ca6098d421fc60116ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b5deaf64d3c2e268338b3ca2653d67"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1Material_1_1InternalResources.html">InternalResources</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ac9b5deaf64d3c2e268338b3ca2653d67">mtxInternalResources</a></td></tr>
<tr class="separator:ac9b5deaf64d3c2e268338b3ca2653d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ecb1cda7f941de8a208c79a731fb35"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1Material_1_1GpuResources.html">GpuResources</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a03ecb1cda7f941de8a208c79a731fb35">mtxGpuResources</a></td></tr>
<tr class="separator:a03ecb1cda7f941de8a208c79a731fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9064b25a8c5ada13136dcfeb073da7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1Material_1_1MaterialShaderConstants.html">MaterialShaderConstants</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a3f9064b25a8c5ada13136dcfeb073da7">mtxShaderMaterialDataConstants</a></td></tr>
<tr class="separator:a3f9064b25a8c5ada13136dcfeb073da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217c2e878ea6111089fea8b9d6372b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a217c2e878ea6111089fea8b9d6372b9d">pPipelineManager</a> = nullptr</td></tr>
<tr class="separator:a217c2e878ea6111089fea8b9d6372b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ded283439b569c213839ef49e820a9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a58ded283439b569c213839ef49e820a9">sVertexShaderName</a></td></tr>
<tr class="separator:a58ded283439b569c213839ef49e820a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a5becd28841cfc24365e2d55a77de6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a30a5becd28841cfc24365e2d55a77de6">sPixelShaderName</a></td></tr>
<tr class="separator:a30a5becd28841cfc24365e2d55a77de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b5b82ea6d591ab0c434a7d2d1a8015"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a89b5b82ea6d591ab0c434a7d2d1a8015">sMaterialName</a></td></tr>
<tr class="separator:a89b5b82ea6d591ab0c434a7d2d1a8015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528b72a37e76f4ba18789a0292d06304"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a528b72a37e76f4ba18789a0292d06304">sDiffuseTexturePathRelativeRes</a></td></tr>
<tr class="separator:a528b72a37e76f4ba18789a0292d06304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24db045bd570219481d2a2e2c7fa99f4"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a24db045bd570219481d2a2e2c7fa99f4">diffuseColor</a> = glm::vec3(1.0F, 1.0F, 1.0F)</td></tr>
<tr class="separator:a24db045bd570219481d2a2e2c7fa99f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4c5f42d34b2bd22969db838551373b"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a5d4c5f42d34b2bd22969db838551373b">specularColor</a> = glm::vec3(1.0F, 1.0F, 1.0F)</td></tr>
<tr class="separator:a5d4c5f42d34b2bd22969db838551373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f8887c5bab282d23e95d6c5077f66b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a75f8887c5bab282d23e95d6c5077f66b">roughness</a> = 0.7F</td></tr>
<tr class="separator:a75f8887c5bab282d23e95d6c5077f66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baf76cad634fde0115a9285f51771c1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a0baf76cad634fde0115a9285f51771c1">opacity</a> = 0.6F</td></tr>
<tr class="separator:a0baf76cad634fde0115a9285f51771c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5bae8c52442a43d2c2f03501989d08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#ace5bae8c52442a43d2c2f03501989d08">bUseTransparency</a> = false</td></tr>
<tr class="separator:ace5bae8c52442a43d2c2f03501989d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d185e1b454c6b6b5f6f0e363d311fc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a4d185e1b454c6b6b5f6f0e363d311fc3">bIsShaderResourcesAllocated</a> = false</td></tr>
<tr class="separator:a4d185e1b454c6b6b5f6f0e363d311fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a93d6ef4a29ecadfcbf5bcd74f6758be7"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a93d6ef4a29ecadfcbf5bcd74f6758be7">sMaterialShaderBufferName</a> = &quot;materialData&quot;</td></tr>
<tr class="separator:a93d6ef4a29ecadfcbf5bcd74f6758be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038cf865bb15bfb6860cbad3e4d556c7"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Material.html#a038cf865bb15bfb6860cbad3e4d556c7">sMaterialShaderDiffuseTextureName</a> = &quot;diffuseTextures&quot;</td></tr>
<tr class="separator:a038cf865bb15bfb6860cbad3e4d556c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adc1c289083fa48118a3b06b20684f786"><td class="memItemLeft" align="right" valign="top"><a id="adc1c289083fa48118a3b06b20684f786" name="adc1c289083fa48118a3b06b20684f786"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MeshNode</b></td></tr>
<tr class="separator:adc1c289083fa48118a3b06b20684f786"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Defines visual aspects of a mesh. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0970484073a752aed3a6704a85be04b4" name="a0970484073a752aed3a6704a85be04b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0970484073a752aed3a6704a85be04b4">&#9670;&#160;</a></span>Material() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::Material::Material </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates uninitialized material, only used for deserialization, instead use <a class="el" href="classne_1_1Material.html#ac3b008d630640dbfc2281ed97e979ecd">create</a>. </p>

</div>
</div>
<a id="af88101c98cc96028ca9cfb4f6fbebf96" name="af88101c98cc96028ca9cfb4f6fbebf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88101c98cc96028ca9cfb4f6fbebf96">&#9670;&#160;</a></span>Material() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ne::Material::Material </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sVertexShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sPixelShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseTransparency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> *&#160;</td>
          <td class="paramname"><em>pPipelineManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sMaterialName</em> = <code>&quot;Material&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new material with the specified name.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This constructor should only be used internally (only by this class), use <a class="el" href="classne_1_1Material.html#ac3b008d630640dbfc2281ed97e979ecd">create</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sVertexShaderName</td><td>Name of the vertex shader that this material is using. </td></tr>
    <tr><td class="paramname">sPixelShaderName</td><td>Name of the pixel shader that this material is using. </td></tr>
    <tr><td class="paramname">bUseTransparency</td><td>Whether this material will use transparency or not. </td></tr>
    <tr><td class="paramname">pPipelineManager</td><td><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> manager that the renderer owns. </td></tr>
    <tr><td class="paramname">sMaterialName</td><td>Name of this material. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad098fa1bc60126bee59d73a9ba5a55a4" name="ad098fa1bc60126bee59d73a9ba5a55a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad098fa1bc60126bee59d73a9ba5a55a4">&#9670;&#160;</a></span>allocateShaderResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::allocateShaderResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates shader resources such as material's constant buffer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Should be called after pipeline was initialized. </dd></dl>

</div>
</div>
<a id="ac3b008d630640dbfc2281ed97e979ecd" name="ac3b008d630640dbfc2281ed97e979ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b008d630640dbfc2281ed97e979ecd">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1Material.html">Material</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Material::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sVertexShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sPixelShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseTransparency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sMaterialName</em> = <code>&quot;Material&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new material that uses the specified shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sVertexShaderName</td><td>Name of the compiled vertex shader (see <a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">ShaderManager::compileShaders</a>) to use. </td></tr>
    <tr><td class="paramname">sPixelShaderName</td><td>Name of the compiled pixel shader (see <a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">ShaderManager::compileShaders</a>) to use. </td></tr>
    <tr><td class="paramname">bUseTransparency</td><td>Whether this material should enable transparency after being created or not (see <a class="el" href="classne_1_1Material.html#a5e1abba43e7ecc07d1740bc75872c050">setEnableTransparency</a>). </td></tr>
    <tr><td class="paramname">sMaterialName</td><td>Name of this material.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise created material. </dd></dl>

</div>
</div>
<a id="ac3395d21390030fd5e0b7da98b96b751" name="ac3395d21390030fd5e0b7da98b96b751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3395d21390030fd5e0b7da98b96b751">&#9670;&#160;</a></span>deallocateShaderResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::deallocateShaderResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deallocates shader resources after <a class="el" href="classne_1_1Material.html#ad098fa1bc60126bee59d73a9ba5a55a4">allocateShaderResources</a> was called.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Should be called before pipeline is cleared. </dd></dl>

</div>
</div>
<a id="ae72f306a7b3eb645832d4b850108110a" name="ae72f306a7b3eb645832d4b850108110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72f306a7b3eb645832d4b850108110a">&#9670;&#160;</a></span>getColorPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * ne::Material::getColorPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns pipeline with pixel/fragment shader enabled (this pipeline is considered to be the main pipeline while others might be optional).</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete returned pointer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if pipeline was not initialized yet, otherwise used pipeline. </dd></dl>

</div>
</div>
<a id="ad3f8b2e84ad7f53c3a100894bfd6c3e2" name="ad3f8b2e84ad7f53c3a100894bfd6c3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f8b2e84ad7f53c3a100894bfd6c3e2">&#9670;&#160;</a></span>getCurrentAliveMaterialCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::Material::getCurrentAliveMaterialCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns total amount of currently alive material objects.</p>
<dl class="section return"><dt>Returns</dt><dd>Total amount of alive materials. </dd></dl>

</div>
</div>
<a id="a0b40a74637b5be997eb63c999773f52e" name="a0b40a74637b5be997eb63c999773f52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b40a74637b5be997eb63c999773f52e">&#9670;&#160;</a></span>getDepthOnlyPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * ne::Material::getDepthOnlyPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns pipeline that only has vertex shader (used for depth only passes).</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete returned pointer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if pipeline was not initialized yet or if <a class="el" href="classne_1_1Material.html#acb5fc8093b532caee4ab8293f4964198">isUsingTransparency</a> is enabled, otherwise used pipeline. </dd></dl>

</div>
</div>
<a id="aafe13b5a88171864d83f787303b87ebe" name="aafe13b5a88171864d83f787303b87ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe13b5a88171864d83f787303b87ebe">&#9670;&#160;</a></span>getDiffuseColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::Material::getDiffuseColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns fill color of this material.</p>
<dl class="section return"><dt>Returns</dt><dd>Color in the RGB format. </dd></dl>

</div>
</div>
<a id="a37ad940792aec3452dc12e8af8ef1f21" name="a37ad940792aec3452dc12e8af8ef1f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ad940792aec3452dc12e8af8ef1f21">&#9670;&#160;</a></span>getMaterialGpuResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1Material_1_1GpuResources.html">GpuResources</a> &gt; * ne::Material::getMaterialGpuResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns GPU resources that this material uses.</p>
<dl class="section return"><dt>Returns</dt><dd>GPU resources. </dd></dl>

</div>
</div>
<a id="a7a5109eeb024a2f06e7bdd6a739118ca" name="a7a5109eeb024a2f06e7bdd6a739118ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5109eeb024a2f06e7bdd6a739118ca">&#9670;&#160;</a></span>getMaterialName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Material::getMaterialName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns material name.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Material.html">Material</a> name. </dd></dl>

</div>
</div>
<a id="ad0467877a11e184dc5f0627dd1cbd02d" name="ad0467877a11e184dc5f0627dd1cbd02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0467877a11e184dc5f0627dd1cbd02d">&#9670;&#160;</a></span>getOpacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ne::Material::getOpacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns opacity of this material.</p>
<dl class="section return"><dt>Returns</dt><dd>Value in range [0.0F; 1.0F]. </dd></dl>

</div>
</div>
<a id="aae6d5d76aa52f5e312a871edba8d001f" name="aae6d5d76aa52f5e312a871edba8d001f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6d5d76aa52f5e312a871edba8d001f">&#9670;&#160;</a></span>getPathToDiffuseTextureResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Material::getPathToDiffuseTextureResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns path to a file/directory that stores currently used diffuse texture of this material.</p>
<dl class="section return"><dt>Returns</dt><dd>Empty if no diffuse texture is set, otherwise path to a file/directory relative to the <code>res</code> directory. </dd></dl>

</div>
</div>
<a id="a4d8b157a95a2ee1968b2fe9994be623c" name="a4d8b157a95a2ee1968b2fe9994be623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8b157a95a2ee1968b2fe9994be623c">&#9670;&#160;</a></span>getPipelineManagerForNewMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; <a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> *, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Material::getPipelineManagerForNewMaterial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sVertexShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sPixelShaderName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns pipeline manager.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Generally called before creating a new material to get pipeline manager and also check that selected shader names indeed exist.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sVertexShaderName</td><td>Name of the vertex shader that the material is using. </td></tr>
    <tr><td class="paramname">sPixelShaderName</td><td>Name of the pixel shader that the material is using.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise pipeline manager. </dd></dl>

</div>
</div>
<a id="ab749c0e8cae5d47f5a78b3617d538f52" name="ab749c0e8cae5d47f5a78b3617d538f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab749c0e8cae5d47f5a78b3617d538f52">&#9670;&#160;</a></span>getPixelShaderMacrosForCurrentState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; ShaderMacro &gt; ne::Material::getPixelShaderMacrosForCurrentState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Analyzes <a class="el" href="classne_1_1Material.html#ac9b5deaf64d3c2e268338b3ca2653d67">mtxInternalResources</a> and returns pixel/fragment shader macros that should be enabled to support the material's features.</p>
<dl class="section return"><dt>Returns</dt><dd>Macros. </dd></dl>

</div>
</div>
<a id="a819dd3b1497a89dc06e811b12329181d" name="a819dd3b1497a89dc06e811b12329181d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819dd3b1497a89dc06e811b12329181d">&#9670;&#160;</a></span>getPixelShaderName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Material::getPixelShaderName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns name of the pixel shader that this material uses.</p>
<dl class="section return"><dt>Returns</dt><dd>Pixel shader name. </dd></dl>

</div>
</div>
<a id="a0f38075d473d23e8255a0cab5e3126e2" name="a0f38075d473d23e8255a0cab5e3126e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f38075d473d23e8255a0cab5e3126e2">&#9670;&#160;</a></span>getRoughness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ne::Material::getRoughness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns roughness of this material.</p>
<dl class="section return"><dt>Returns</dt><dd>Value in range [0.0F; 1.0F]. </dd></dl>

</div>
</div>
<a id="a1879f119b0b281dd2f421a135bb74329" name="a1879f119b0b281dd2f421a135bb74329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1879f119b0b281dd2f421a135bb74329">&#9670;&#160;</a></span>getShadowMappingDirectionalSpotPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * ne::Material::getShadowMappingDirectionalSpotPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns pipeline that only has vertex shader and depth bias enabled, used for shadow passes of directional and spot lights.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete returned pointer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if pipeline was not initialized yet or if <a class="el" href="classne_1_1Material.html#acb5fc8093b532caee4ab8293f4964198">isUsingTransparency</a> is enabled, otherwise used pipeline. </dd></dl>

</div>
</div>
<a id="afdabd9fd25213f1c33138d978ddafdd1" name="afdabd9fd25213f1c33138d978ddafdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdabd9fd25213f1c33138d978ddafdd1">&#9670;&#160;</a></span>getShadowMappingPointPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> * ne::Material::getShadowMappingPointPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns pipeline that only has vertex shader and depth bias enabled, used for shadow passes of point lights.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete returned pointer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if pipeline was not initialized yet or if <a class="el" href="classne_1_1Material.html#acb5fc8093b532caee4ab8293f4964198">isUsingTransparency</a> is enabled, otherwise used pipeline. </dd></dl>

</div>
</div>
<a id="a22972cb7fc8c34cd1e25794604c6f88f" name="a22972cb7fc8c34cd1e25794604c6f88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22972cb7fc8c34cd1e25794604c6f88f">&#9670;&#160;</a></span>getSpawnedMeshNodesThatUseThisMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::mutex, <a class="el" href="structne_1_1MeshNodesThatUseThisMaterial.html">MeshNodesThatUseThisMaterial</a> &gt; * ne::Material::getSpawnedMeshNodesThatUseThisMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns array of mesh nodes that currently use this material. Must be used with mutex.</p>
<dl class="section return"><dt>Returns</dt><dd>Array of mesh nodes. </dd></dl>

</div>
</div>
<a id="af18626e7a64af061617da9fd328a6e3b" name="af18626e7a64af061617da9fd328a6e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18626e7a64af061617da9fd328a6e3b">&#9670;&#160;</a></span>getSpecularColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::Material::getSpecularColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns reflected color of this material.</p>
<dl class="section return"><dt>Returns</dt><dd>Color in the RGB format. </dd></dl>

</div>
</div>
<a id="a9b10095374d989f99a568299b663ea1b" name="a9b10095374d989f99a568299b663ea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b10095374d989f99a568299b663ea1b">&#9670;&#160;</a></span>getVertexShaderMacrosForCurrentState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; ShaderMacro &gt; ne::Material::getVertexShaderMacrosForCurrentState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Analyzes <a class="el" href="classne_1_1Material.html#ac9b5deaf64d3c2e268338b3ca2653d67">mtxInternalResources</a> and returns vertex shader macros that should be enabled to support the material's features.</p>
<dl class="section return"><dt>Returns</dt><dd>Macros. </dd></dl>

</div>
</div>
<a id="a37c74feacb9365a1dffd9499374403bd" name="a37c74feacb9365a1dffd9499374403bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c74feacb9365a1dffd9499374403bd">&#9670;&#160;</a></span>getVertexShaderName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Material::getVertexShaderName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns name of the vertex shader that this material uses.</p>
<dl class="section return"><dt>Returns</dt><dd>Vertex shader name. </dd></dl>

</div>
</div>
<a id="adf6582e8a2f026a45c61396bfe8f1feb" name="adf6582e8a2f026a45c61396bfe8f1feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6582e8a2f026a45c61396bfe8f1feb">&#9670;&#160;</a></span>initializePipelines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Material::initializePipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initializes pipelines that the material needs.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Expects that pipelines are not initialized.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a88305277fcf45b2d54ffdb0e7de731d2" name="a88305277fcf45b2d54ffdb0e7de731d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88305277fcf45b2d54ffdb0e7de731d2">&#9670;&#160;</a></span>isTransparencyEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Material::isTransparencyEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tells whether transparency on this material is enabled or not.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if enabled, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="acb5fc8093b532caee4ab8293f4964198" name="acb5fc8093b532caee4ab8293f4964198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5fc8093b532caee4ab8293f4964198">&#9670;&#160;</a></span>isUsingTransparency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Material::isUsingTransparency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tells whether this material uses transparency or not.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether this material uses transparency or not. </dd></dl>

</div>
</div>
<a id="a2092ab1b66f459ce1b690e053488a5aa" name="a2092ab1b66f459ce1b690e053488a5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2092ab1b66f459ce1b690e053488a5aa">&#9670;&#160;</a></span>markShaderCpuWriteResourceAsNeedsUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::markShaderCpuWriteResourceAsNeedsUpdate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Looks for binding created using <a class="el" href="classne_1_1Material.html#a1bd758e7acff200a7b93ca29304cbbcd">setShaderCpuWriteResourceBinding</a> and notifies the engine that there is new (updated) data for shader CPU write resource to copy to the GPU to be used by shaders.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You don't need to check if the pipeline is initialized or not before calling this function, if the binding does not exist or some other condition is not met this call will be silently ignored without any errors.</dd>
<dd>
Note that the callbacks that you have specified in <a class="el" href="classne_1_1Material.html#a1bd758e7acff200a7b93ca29304cbbcd">setShaderCpuWriteResourceBinding</a> will not be called inside of this function, moreover they are most likely to be called in the next frame(s) (most likely multiple times) when the engine is ready to copy the data to the GPU, so if the resource's data is used by multiple threads in your code, make sure to use mutex or other synchronization primitive in your callbacks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the shader CPU write resource (should be exactly the same as the resource name written in the shader file we are referencing). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7946faee0b5231b38196c9cc8c2dffd4" name="a7946faee0b5231b38196c9cc8c2dffd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7946faee0b5231b38196c9cc8c2dffd4">&#9670;&#160;</a></span>onAfterDeserialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::onAfterDeserialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after the object was successfully deserialized. Used to execute post-deserialization logic.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented from <a class="el" href="classne_1_1Serializable.html#a00002d59e5d0dcda6e53c20b59947150">ne::Serializable</a>.</p>

</div>
</div>
<a id="acc4f2a67629155070efdac11fbdae46e" name="acc4f2a67629155070efdac11fbdae46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4f2a67629155070efdac11fbdae46e">&#9670;&#160;</a></span>onFinishedUpdatingShaderMeshConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::onFinishedUpdatingShaderMeshConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after finished copying data from <a class="el" href="classne_1_1Material.html#a3f9064b25a8c5ada13136dcfeb073da7">mtxShaderMaterialDataConstants</a>. </p>

</div>
</div>
<a id="af1e3a6939b7619716744eadb2a7a0723" name="af1e3a6939b7619716744eadb2a7a0723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e3a6939b7619716744eadb2a7a0723">&#9670;&#160;</a></span>onMeshNodeDespawning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::onMeshNodeDespawning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *&#160;</td>
          <td class="paramname"><em>pMeshNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexBufferDisplayed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from <a class="el" href="classne_1_1MeshNode.html">MeshNode</a> when a spawned mesh node that uses this material is being despawned.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the mesh will not change its visibility while calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMeshNode</td><td>Spawned mesh node that is being despawned. </td></tr>
    <tr><td class="paramname">indexBufferDisplayed</td><td>Index buffer that this material was displaying. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f72b3b50221e37374506f7a4c344422" name="a1f72b3b50221e37374506f7a4c344422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f72b3b50221e37374506f7a4c344422">&#9670;&#160;</a></span>onMeshNodeSpawning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::onMeshNodeSpawning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *&#160;</td>
          <td class="paramname"><em>pMeshNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexBufferToDisplay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from <a class="el" href="classne_1_1MeshNode.html">MeshNode</a> when a mesh node that uses this material is being spawned.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the mesh will not change its visibility while calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMeshNode</td><td>Mesh node that is currently being spawned. </td></tr>
    <tr><td class="paramname">indexBufferToDisplay</td><td>Index buffer that this material should display. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05f4e887a2fda3da02f4875eb60053ec" name="a05f4e887a2fda3da02f4875eb60053ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f4e887a2fda3da02f4875eb60053ec">&#9670;&#160;</a></span>onSpawnedMeshNodeChangedVisibility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::onSpawnedMeshNodeChangedVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *&#160;</td>
          <td class="paramname"><em>pMeshNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOldVisibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from <a class="el" href="classne_1_1MeshNode.html">MeshNode</a> when a spawned mesh node changed its visibility.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the mesh will not change its visibility while calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMeshNode</td><td>Spawned mesh node that is using this material. </td></tr>
    <tr><td class="paramname">bOldVisibility</td><td>Old visibility of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dca5d184d1079603751789ef76edc62" name="a5dca5d184d1079603751789ef76edc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dca5d184d1079603751789ef76edc62">&#9670;&#160;</a></span>onSpawnedMeshNodeRecreatedIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::onSpawnedMeshNodeRecreatedIndexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *&#160;</td>
          <td class="paramname"><em>pMeshNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>deletedIndexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>newIndexBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from <a class="el" href="classne_1_1MeshNode.html">MeshNode</a> when a spawned mesh node re-created some index buffer and now wants to notify the material about it.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the mesh will not change its visibility while calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMeshNode</td><td>Spawned mesh node that is using this material. </td></tr>
    <tr><td class="paramname">deletedIndexBuffer</td><td>Index buffer that was deleted. </td></tr>
    <tr><td class="paramname">newIndexBuffer</td><td>Index buffer that this material should display now. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39df1e140902043bd534cb3279d3d665" name="a39df1e140902043bd534cb3279d3d665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39df1e140902043bd534cb3279d3d665">&#9670;&#160;</a></span>onSpawnedMeshNodeStartedUsingMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::onSpawnedMeshNodeStartedUsingMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *&#160;</td>
          <td class="paramname"><em>pMeshNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexBufferToDisplay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from <a class="el" href="classne_1_1MeshNode.html">MeshNode</a> when a spawned mesh node changed its material and started using this material now.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the mesh will not change its visibility while calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMeshNode</td><td>Spawned mesh node that is using this material. </td></tr>
    <tr><td class="paramname">indexBufferToDisplay</td><td>Index buffer that this material should display. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ba3060536452524bb96ae049d050289" name="a6ba3060536452524bb96ae049d050289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba3060536452524bb96ae049d050289">&#9670;&#160;</a></span>onSpawnedMeshNodeStoppedUsingMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::onSpawnedMeshNodeStoppedUsingMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1MeshNode.html">MeshNode</a> *&#160;</td>
          <td class="paramname"><em>pMeshNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexBufferDisplayed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from <a class="el" href="classne_1_1MeshNode.html">MeshNode</a> when a spawned mesh node changed its material and now no longer using this material.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the mesh will not change its visibility while calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMeshNode</td><td>Spawned mesh node that stopped using this material. </td></tr>
    <tr><td class="paramname">indexBufferDisplayed</td><td>Index buffer that this material was displaying. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82c2abbb8c345c5a1b2e121a20f68175" name="a82c2abbb8c345c5a1b2e121a20f68175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c2abbb8c345c5a1b2e121a20f68175">&#9670;&#160;</a></span>onStartUpdatingShaderMeshConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * ne::Material::onStartUpdatingShaderMeshConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called to copy data from <a class="el" href="classne_1_1Material.html#a3f9064b25a8c5ada13136dcfeb073da7">mtxShaderMaterialDataConstants</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to data in <a class="el" href="classne_1_1Material.html#a3f9064b25a8c5ada13136dcfeb073da7">mtxShaderMaterialDataConstants</a>. </dd></dl>

</div>
</div>
<a id="ad94a42c86625c72a14036cae1e2db707" name="ad94a42c86625c72a14036cae1e2db707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94a42c86625c72a14036cae1e2db707">&#9670;&#160;</a></span>resetPipelines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::resetPipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Clears (sets to <code>nullptr</code>) all used pipelines. </p>

</div>
</div>
<a id="a3f3ef9edcab7dc00f3449fcefee66bea" name="a3f3ef9edcab7dc00f3449fcefee66bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3ef9edcab7dc00f3449fcefee66bea">&#9670;&#160;</a></span>setDiffuseColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::setDiffuseColor </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>diffuseColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets material's fill color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diffuseColor</td><td>Color in the RGB format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44c6e1c40cc75ce6e8f93b30c60ad8f3" name="a44c6e1c40cc75ce6e8f93b30c60ad8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c6e1c40cc75ce6e8f93b30c60ad8f3">&#9670;&#160;</a></span>setDiffuseTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::setDiffuseTexture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sTextureResourcePathRelativeRes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets material's diffuse texture.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="comment">// Specify path to a directory that stores DDS and KTX files with player&#39;s diffuse texture.</span></div>
<div class="line">pMaterial-&gt;setDiffuseTexture(<span class="stringliteral">&quot;game/player/textures/diffuse&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTextureResourcePathRelativeRes</td><td>Path to a texture resource (file/directory) relative to <code>res</code> directory that this material should now use. Specify empty string to clear the current diffuse texture (if any is set) and don't use diffuse texture at all. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e1abba43e7ecc07d1740bc75872c050" name="a5e1abba43e7ecc07d1740bc75872c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1abba43e7ecc07d1740bc75872c050">&#9670;&#160;</a></span>setEnableTransparency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::setEnableTransparency </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enables/disables transparency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>Whether to enable transparency or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c1e2ef9f66f9f8e69658de3bb3fb491" name="a2c1e2ef9f66f9f8e69658de3bb3fb491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1e2ef9f66f9f8e69658de3bb3fb491">&#9670;&#160;</a></span>setOpacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::setOpacity </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em> = <code>1.0F</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets material's opacity.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Only works if the material has transparency enabled (see <a class="el" href="classne_1_1Material.html#ac3b008d630640dbfc2281ed97e979ecd">create</a> or <a class="el" href="classne_1_1Material.html#a5e1abba43e7ecc07d1740bc75872c050">setEnableTransparency</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opacity</td><td>Value in range [0.0F; 1.0F], will be clamped if outside of this range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a120643a43142cb24e81bbec6dd8f6dc2" name="a120643a43142cb24e81bbec6dd8f6dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120643a43142cb24e81bbec6dd8f6dc2">&#9670;&#160;</a></span>setRoughness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::setRoughness </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>roughness</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets factor that defines how much specular light will be reflected (i.e. how rough or smooth the surface is).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roughness</td><td>Value in range [0.0F; 1.0F], will be clamped if outside of this range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bd758e7acff200a7b93ca29304cbbcd" name="a1bd758e7acff200a7b93ca29304cbbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd758e7acff200a7b93ca29304cbbcd">&#9670;&#160;</a></span>setShaderCpuWriteResourceBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::setShaderCpuWriteResourceBinding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iResourceSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void *()&gt; &amp;&#160;</td>
          <td class="paramname"><em>onStartedUpdatingResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>onFinishedUpdatingResource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Setups callbacks for a shader resource (buffer or a texture from the shader code) with CPU write access to copy the data from the CPU to the GPU to be used by the shaders.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Call this function in <a class="el" href="classne_1_1Material.html#ad098fa1bc60126bee59d73a9ba5a55a4">allocateShaderResources</a> to bind to shader resources, all bindings will be automatically removed in <a class="el" href="classne_1_1Material.html#ac3395d21390030fd5e0b7da98b96b751">deallocateShaderResources</a>.</dd>
<dd>
When data of a resource that you registered was updated on the CPU side you need to call <a class="el" href="classne_1_1Material.html#a2092ab1b66f459ce1b690e053488a5aa">markShaderCpuWriteResourceAsNeedsUpdate</a> so that update callbacks will be called and updated data will be copied to the GPU to be used by shaders. Note that you don't need to call <a class="el" href="classne_1_1Material.html#a2092ab1b66f459ce1b690e053488a5aa">markShaderCpuWriteResourceAsNeedsUpdate</a> for resources you have not registered yourself. Also note that all registered resources are marked as "need update" by default so you don't have to call <a class="el" href="classne_1_1Material.html#a2092ab1b66f459ce1b690e053488a5aa">markShaderCpuWriteResourceAsNeedsUpdate</a> right after calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the resource we are referencing (should be exactly the same as the resource name written in the shader file we are referencing). </td></tr>
    <tr><td class="paramname">iResourceSizeInBytes</td><td>Size of the data that this resource will contain. Note that the specified size will most likely be padded (changed) to be a multiple of 256 because of the hardware requirement for shader constant buffers. </td></tr>
    <tr><td class="paramname">onStartedUpdatingResource</td><td>Function that will be called when the engine has started copying data to the GPU. Function returns pointer to new (updated) data of the specified resource that will be copied to the GPU. </td></tr>
    <tr><td class="paramname">onFinishedUpdatingResource</td><td>Function that will be called when the engine has finished copying resource data to the GPU (usually used for unlocking mutexes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a799ecf3e2da01410a1823f6132a12fa9" name="a799ecf3e2da01410a1823f6132a12fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799ecf3e2da01410a1823f6132a12fa9">&#9670;&#160;</a></span>setShaderTextureResourceBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::setShaderTextureResourceBinding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sPathToTextureResourceRelativeRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Setups a shader resource binding that references a texture that will be used in shaders when this material is rendered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Call this function in <a class="el" href="classne_1_1Material.html#ad098fa1bc60126bee59d73a9ba5a55a4">allocateShaderResources</a> to bind to shader resources, all bindings will be automatically removed in <a class="el" href="classne_1_1Material.html#ac3395d21390030fd5e0b7da98b96b751">deallocateShaderResources</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the resource we are referencing (should be exactly the same as the resource name written in the shader file we are referencing). </td></tr>
    <tr><td class="paramname">sPathToTextureResourceRelativeRes</td><td>Path to the directory with texture resource to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7fa00d994567a8e00e010bca321253d" name="ac7fa00d994567a8e00e010bca321253d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fa00d994567a8e00e010bca321253d">&#9670;&#160;</a></span>setSpecularColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::setSpecularColor </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>specularColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets material's reflected color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">specularColor</td><td>Color in the RGB format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55308869a89ec874f334de5843030c85" name="a55308869a89ec874f334de5843030c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55308869a89ec874f334de5843030c85">&#9670;&#160;</a></span>updateToNewPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Material::updateToNewPipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Releases all shader resources, requests a new pipeline according to currently defined shader macros, allocates all shader resources and notifies all mesh nodes that use this material. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4d185e1b454c6b6b5f6f0e363d311fc3" name="a4d185e1b454c6b6b5f6f0e363d311fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d185e1b454c6b6b5f6f0e363d311fc3">&#9670;&#160;</a></span>bIsShaderResourcesAllocated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Material::bIsShaderResourcesAllocated = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Whether <a class="el" href="classne_1_1Material.html#ad098fa1bc60126bee59d73a9ba5a55a4">allocateShaderResources</a> was called or not. </p>

</div>
</div>
<a id="ace5bae8c52442a43d2c2f03501989d08" name="ace5bae8c52442a43d2c2f03501989d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5bae8c52442a43d2c2f03501989d08">&#9670;&#160;</a></span>bUseTransparency</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Material::bUseTransparency = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Whether this material will use transparency or not. </p>

</div>
</div>
<a id="a24db045bd570219481d2a2e2c7fa99f4" name="a24db045bd570219481d2a2e2c7fa99f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24db045bd570219481d2a2e2c7fa99f4">&#9670;&#160;</a></span>diffuseColor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::Material::diffuseColor = glm::vec3(1.0F, 1.0F, 1.0F)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Fill color. </p>

</div>
</div>
<a id="a03ecb1cda7f941de8a208c79a731fb35" name="a03ecb1cda7f941de8a208c79a731fb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ecb1cda7f941de8a208c79a731fb35">&#9670;&#160;</a></span>mtxGpuResources</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1Material_1_1GpuResources.html">GpuResources</a>&gt; ne::Material::mtxGpuResources</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores GPU resources used by this material. </p>

</div>
</div>
<a id="ac9b5deaf64d3c2e268338b3ca2653d67" name="ac9b5deaf64d3c2e268338b3ca2653d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b5deaf64d3c2e268338b3ca2653d67">&#9670;&#160;</a></span>mtxInternalResources</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1Material_1_1InternalResources.html">InternalResources</a>&gt; ne::Material::mtxInternalResources</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Internal data. </p>

</div>
</div>
<a id="a3f9064b25a8c5ada13136dcfeb073da7" name="a3f9064b25a8c5ada13136dcfeb073da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9064b25a8c5ada13136dcfeb073da7">&#9670;&#160;</a></span>mtxShaderMaterialDataConstants</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1Material_1_1MaterialShaderConstants.html">MaterialShaderConstants</a>&gt; ne::Material::mtxShaderMaterialDataConstants</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores data for constant buffer used by shaders. </p>

</div>
</div>
<a id="a4b40c304da2d5ca6098d421fc60116ef" name="a4b40c304da2d5ca6098d421fc60116ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b40c304da2d5ca6098d421fc60116ef">&#9670;&#160;</a></span>mtxSpawnedMeshNodesThatUseThisMaterial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::mutex, <a class="el" href="structne_1_1MeshNodesThatUseThisMaterial.html">MeshNodesThatUseThisMaterial</a>&gt; ne::Material::mtxSpawnedMeshNodesThatUseThisMaterial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Array of spawned mesh nodes that use this material. Must be used with mutex. </p>

</div>
</div>
<a id="a0baf76cad634fde0115a9285f51771c1" name="a0baf76cad634fde0115a9285f51771c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baf76cad634fde0115a9285f51771c1">&#9670;&#160;</a></span>opacity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ne::Material::opacity = 0.6F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Opacity in range [0.0; 1.0].</p>
<dl class="section remark"><dt>Remarks</dt><dd>Only used when <a class="el" href="classne_1_1Material.html#ace5bae8c52442a43d2c2f03501989d08">bUseTransparency</a> is enabled. </dd></dl>

</div>
</div>
<a id="a217c2e878ea6111089fea8b9d6372b9d" name="a217c2e878ea6111089fea8b9d6372b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217c2e878ea6111089fea8b9d6372b9d">&#9670;&#160;</a></span>pPipelineManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a>* ne::Material::pPipelineManager = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Do not delete (free) this pointer. <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> manager that the renderer owns. </p>

</div>
</div>
<a id="a75f8887c5bab282d23e95d6c5077f66b" name="a75f8887c5bab282d23e95d6c5077f66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f8887c5bab282d23e95d6c5077f66b">&#9670;&#160;</a></span>roughness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ne::Material::roughness = 0.7F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Defines how much specular light will be reflected. Value in range [0.0F; 1.0F]. </p>

</div>
</div>
<a id="a528b72a37e76f4ba18789a0292d06304" name="a528b72a37e76f4ba18789a0292d06304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528b72a37e76f4ba18789a0292d06304">&#9670;&#160;</a></span>sDiffuseTexturePathRelativeRes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Material::sDiffuseTexturePathRelativeRes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Empty if diffuse texture is not used, otherwise path to used diffuse texture relative to <code>res</code> directory. </p>

</div>
</div>
<a id="a89b5b82ea6d591ab0c434a7d2d1a8015" name="a89b5b82ea6d591ab0c434a7d2d1a8015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b5b82ea6d591ab0c434a7d2d1a8015">&#9670;&#160;</a></span>sMaterialName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Material::sMaterialName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of this material. </p>

</div>
</div>
<a id="a93d6ef4a29ecadfcbf5bcd74f6758be7" name="a93d6ef4a29ecadfcbf5bcd74f6758be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d6ef4a29ecadfcbf5bcd74f6758be7">&#9670;&#160;</a></span>sMaterialShaderBufferName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto ne::Material::sMaterialShaderBufferName = &quot;materialData&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the buffer used to store material data in shaders. </p>

</div>
</div>
<a id="a038cf865bb15bfb6860cbad3e4d556c7" name="a038cf865bb15bfb6860cbad3e4d556c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038cf865bb15bfb6860cbad3e4d556c7">&#9670;&#160;</a></span>sMaterialShaderDiffuseTextureName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto ne::Material::sMaterialShaderDiffuseTextureName = &quot;diffuseTextures&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the resource used to store diffuse textures in shaders. </p>

</div>
</div>
<a id="a5d4c5f42d34b2bd22969db838551373b" name="a5d4c5f42d34b2bd22969db838551373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4c5f42d34b2bd22969db838551373b">&#9670;&#160;</a></span>specularColor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::Material::specularColor = glm::vec3(1.0F, 1.0F, 1.0F)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reflected color. </p>

</div>
</div>
<a id="a30a5becd28841cfc24365e2d55a77de6" name="a30a5becd28841cfc24365e2d55a77de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a5becd28841cfc24365e2d55a77de6">&#9670;&#160;</a></span>sPixelShaderName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Material::sPixelShaderName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the pixel shader that this material is using. </p>

</div>
</div>
<a id="a58ded283439b569c213839ef49e820a9" name="a58ded283439b569c213839ef49e820a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ded283439b569c213839ef49e820a9">&#9670;&#160;</a></span>sVertexShaderName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Material::sVertexShaderName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the vertex shader that this material is using. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/public/material/<a class="el" href="Material_8h_source.html">Material.h</a></li>
<li>src/engine_lib/private/material/Material.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1Material.html">Material</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
