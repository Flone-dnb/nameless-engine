<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::MeshNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1MeshNode.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1MeshNode-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::MeshNode Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="MeshNode_8h_source.html">MeshNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::MeshNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1MeshNode.png" usemap="#ne::MeshNode_map" alt=""/>
  <map id="ne::MeshNode_map" name="ne::MeshNode_map">
<area href="classne_1_1SpatialNode.html" alt="ne::SpatialNode" shape="rect" coords="0,168,100,192"/>
<area href="classne_1_1Node.html" alt="ne::Node" shape="rect" coords="0,112,100,136"/>
<area href="classne_1_1Serializable.html" alt="ne::Serializable" shape="rect" coords="0,56,100,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1MeshNode_1_1GpuResources.html">GpuResources</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1MeshNode_1_1MeshShaderConstants.html">MeshShaderConstants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ed41a6566e750963f8cb3f8f5eb1963"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a6ed41a6566e750963f8cb3f8f5eb1963">MeshNode</a> (const std::string &amp;<a class="el" href="classne_1_1Node.html#abf5d0aa8bddaf3927e80dddb787fbe26">sNodeName</a>)</td></tr>
<tr class="separator:a6ed41a6566e750963f8cb3f8f5eb1963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600afde2008f201682f59751d175efb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a600afde2008f201682f59751d175efb7">setMaterial</a> (std::unique_ptr&lt; <a class="el" href="classne_1_1Material.html">Material</a> &gt; pMaterial, size_t iMaterialSlot=0)</td></tr>
<tr class="separator:a600afde2008f201682f59751d175efb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9fc27cf88ec1ec90d732b8fe71737c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a4e9fc27cf88ec1ec90d732b8fe71737c">setMeshData</a> (const <a class="el" href="classne_1_1MeshData.html">MeshData</a> &amp;<a class="el" href="classne_1_1MeshNode.html#a3b250fb570ed3679ac1e52c84e6455a3">meshData</a>)</td></tr>
<tr class="separator:a4e9fc27cf88ec1ec90d732b8fe71737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4e8cd51eaf440c9a77a715d8543e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a0d4e8cd51eaf440c9a77a715d8543e24">setMeshData</a> (<a class="el" href="classne_1_1MeshData.html">MeshData</a> &amp;&amp;<a class="el" href="classne_1_1MeshNode.html#a3b250fb570ed3679ac1e52c84e6455a3">meshData</a>)</td></tr>
<tr class="separator:a0d4e8cd51eaf440c9a77a715d8543e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9e3c1ba2be62c9f806bb2b7eae78e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#add9e3c1ba2be62c9f806bb2b7eae78e2">onMeshDataChanged</a> ()</td></tr>
<tr class="separator:add9e3c1ba2be62c9f806bb2b7eae78e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf28d800c9aaaaa16f20ff190a913667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#aaf28d800c9aaaaa16f20ff190a913667">setIsVisible</a> (bool bVisible)</td></tr>
<tr class="separator:aaf28d800c9aaaaa16f20ff190a913667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cb60dfc8713be834295480cbeb4414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Material.html">Material</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a83cb60dfc8713be834295480cbeb4414">getMaterial</a> (size_t iMaterialSlot=0)</td></tr>
<tr class="separator:a83cb60dfc8713be834295480cbeb4414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8911af4b77829e58ed0d59466d2ba18a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a8911af4b77829e58ed0d59466d2ba18a">getAvailableMaterialSlotCount</a> ()</td></tr>
<tr class="separator:a8911af4b77829e58ed0d59466d2ba18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27eb0a143ae98c2419c2e5eef36df9cf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex *, <a class="el" href="classne_1_1MeshData.html">MeshData</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a27eb0a143ae98c2419c2e5eef36df9cf">getMeshData</a> ()</td></tr>
<tr class="separator:a27eb0a143ae98c2419c2e5eef36df9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f15c8ce01a9270e58ab56518bfe7098"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1MeshNode_1_1GpuResources.html">GpuResources</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a3f15c8ce01a9270e58ab56518bfe7098">getMeshGpuResources</a> ()</td></tr>
<tr class="separator:a3f15c8ce01a9270e58ab56518bfe7098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea00de98b55c7e4a6f0ad6abe9db77f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1MeshNode_1_1MeshShaderConstants.html">MeshShaderConstants</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#aaea00de98b55c7e4a6f0ad6abe9db77f">getMeshShaderConstants</a> ()</td></tr>
<tr class="separator:aaea00de98b55c7e4a6f0ad6abe9db77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6295e3796e64c6fb4d4552e46cf9f14a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structne_1_1AABB.html">AABB</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a6295e3796e64c6fb4d4552e46cf9f14a">getAABB</a> ()</td></tr>
<tr class="separator:a6295e3796e64c6fb4d4552e46cf9f14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec40629a5cb70acb3aa3172349e6440"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a4ec40629a5cb70acb3aa3172349e6440">isVisible</a> () const</td></tr>
<tr class="separator:a4ec40629a5cb70acb3aa3172349e6440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1SpatialNode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1SpatialNode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1SpatialNode.html">ne::SpatialNode</a></td></tr>
<tr class="memitem:ac02b39a7177a89acf9613d4b1bb9f203 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#ac02b39a7177a89acf9613d4b1bb9f203">SpatialNode</a> (const std::string &amp;<a class="el" href="classne_1_1Node.html#abf5d0aa8bddaf3927e80dddb787fbe26">sNodeName</a>)</td></tr>
<tr class="separator:ac02b39a7177a89acf9613d4b1bb9f203 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d5413bbb88c9b259e8e9e48a271ab6 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a15d5413bbb88c9b259e8e9e48a271ab6">setRelativeLocation</a> (const glm::vec3 &amp;location)</td></tr>
<tr class="separator:a15d5413bbb88c9b259e8e9e48a271ab6 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32914b6236f0d2675736be0f1ea1cac2 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a32914b6236f0d2675736be0f1ea1cac2">setRelativeRotation</a> (const glm::vec3 &amp;rotation)</td></tr>
<tr class="separator:a32914b6236f0d2675736be0f1ea1cac2 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf859b09995cfac54203d12d5527627 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aecf859b09995cfac54203d12d5527627">setRelativeScale</a> (const glm::vec3 &amp;scale)</td></tr>
<tr class="separator:aecf859b09995cfac54203d12d5527627 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5505c98b284aaf4037e8bf2e31305f2b inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a5505c98b284aaf4037e8bf2e31305f2b">setWorldLocation</a> (const glm::vec3 &amp;location)</td></tr>
<tr class="separator:a5505c98b284aaf4037e8bf2e31305f2b inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2f513f7406d324c9927af5fec07c26 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#afb2f513f7406d324c9927af5fec07c26">setWorldRotation</a> (const glm::vec3 &amp;rotation)</td></tr>
<tr class="separator:afb2f513f7406d324c9927af5fec07c26 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c51087d2b8e3bd43ca218de57a7cca inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a95c51087d2b8e3bd43ca218de57a7cca">setWorldScale</a> (const glm::vec3 &amp;scale)</td></tr>
<tr class="separator:a95c51087d2b8e3bd43ca218de57a7cca inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb558a9f20e9501a3d8a4b0f4a769f2c inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aeb558a9f20e9501a3d8a4b0f4a769f2c">getRelativeLocation</a> () const</td></tr>
<tr class="separator:aeb558a9f20e9501a3d8a4b0f4a769f2c inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ebb64994069549f09f5148d890fb9 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a277ebb64994069549f09f5148d890fb9">getRelativeRotation</a> () const</td></tr>
<tr class="separator:a277ebb64994069549f09f5148d890fb9 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b030ce699a74fd273d64affd7c34963 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a2b030ce699a74fd273d64affd7c34963">getRelativeScale</a> () const</td></tr>
<tr class="separator:a2b030ce699a74fd273d64affd7c34963 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e2381f0d40f43e050cfa9ac2c2d9fa inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a50e2381f0d40f43e050cfa9ac2c2d9fa">getRelativeRotationMatrix</a> ()</td></tr>
<tr class="separator:a50e2381f0d40f43e050cfa9ac2c2d9fa inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd42888d6bb7d5ff7e82bd61ed8f8c2 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#acbd42888d6bb7d5ff7e82bd61ed8f8c2">getWorldLocation</a> ()</td></tr>
<tr class="separator:acbd42888d6bb7d5ff7e82bd61ed8f8c2 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c06e3d090b282f172c0978c8ddeb17 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#af1c06e3d090b282f172c0978c8ddeb17">getWorldRotation</a> ()</td></tr>
<tr class="separator:af1c06e3d090b282f172c0978c8ddeb17 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e77c912ebf8f0877addcee649fdffe1 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::quat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a9e77c912ebf8f0877addcee649fdffe1">getWorldRotationQuaternion</a> ()</td></tr>
<tr class="separator:a9e77c912ebf8f0877addcee649fdffe1 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac522941554b6f4f97f5eb1a2e29d31a inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aac522941554b6f4f97f5eb1a2e29d31a">getWorldScale</a> ()</td></tr>
<tr class="separator:aac522941554b6f4f97f5eb1a2e29d31a inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bba3a225a35cd40d5f04c98506aa4e inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#ac8bba3a225a35cd40d5f04c98506aa4e">getWorldForwardDirection</a> ()</td></tr>
<tr class="separator:ac8bba3a225a35cd40d5f04c98506aa4e inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2594545f207a1a4972eade6172cca66c inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a2594545f207a1a4972eade6172cca66c">getWorldRightDirection</a> ()</td></tr>
<tr class="separator:a2594545f207a1a4972eade6172cca66c inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95209d6c7572ee121505191652ed529b inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a95209d6c7572ee121505191652ed529b">getWorldUpDirection</a> ()</td></tr>
<tr class="separator:a95209d6c7572ee121505191652ed529b inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9becf3737c72d57008bbc87d37aea546 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a9becf3737c72d57008bbc87d37aea546">getWorldMatrix</a> ()</td></tr>
<tr class="separator:a9becf3737c72d57008bbc87d37aea546 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa361d4f17cb0cac78ad7f4b1f33d2c05 inherit pub_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aa361d4f17cb0cac78ad7f4b1f33d2c05">getClosestSpatialParent</a> ()</td></tr>
<tr class="separator:aa361d4f17cb0cac78ad7f4b1f33d2c05 inherit pub_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1Node.html">ne::Node</a></td></tr>
<tr class="memitem:a869b03190702ccef1f85bad536bf1a4b inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a869b03190702ccef1f85bad536bf1a4b">Node</a> ()</td></tr>
<tr class="separator:a869b03190702ccef1f85bad536bf1a4b inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e8ff8b016048cb83b9bbfbe822a7e7 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a21e8ff8b016048cb83b9bbfbe822a7e7">Node</a> (const std::string &amp;sName)</td></tr>
<tr class="separator:a21e8ff8b016048cb83b9bbfbe822a7e7 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099cb0edca54481c58a99389d2f983bf inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a099cb0edca54481c58a99389d2f983bf" name="a099cb0edca54481c58a99389d2f983bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (const <a class="el" href="classne_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:a099cb0edca54481c58a99389d2f983bf inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09610eec6599d25609c9c6c383ee49c0 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a09610eec6599d25609c9c6c383ee49c0" name="a09610eec6599d25609c9c6c383ee49c0"></a>
<a class="el" href="classne_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:a09610eec6599d25609c9c6c383ee49c0 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab095a12cd5b7f615b096e7d3db219c1b inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="ab095a12cd5b7f615b096e7d3db219c1b" name="ab095a12cd5b7f615b096e7d3db219c1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (<a class="el" href="classne_1_1Node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab095a12cd5b7f615b096e7d3db219c1b inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee6453dd5914d7250770af98e59a5eb inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a3ee6453dd5914d7250770af98e59a5eb" name="a3ee6453dd5914d7250770af98e59a5eb"></a>
<a class="el" href="classne_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classne_1_1Node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3ee6453dd5914d7250770af98e59a5eb inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79642d37ba8f7a42e6bbb43285f8b0fb inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a79642d37ba8f7a42e6bbb43285f8b0fb">~Node</a> () override</td></tr>
<tr class="separator:a79642d37ba8f7a42e6bbb43285f8b0fb inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75cedd320fd643ad154bdceb4b0aad1 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa75cedd320fd643ad154bdceb4b0aad1">setNodeName</a> (const std::string &amp;sName)</td></tr>
<tr class="separator:aa75cedd320fd643ad154bdceb4b0aad1 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e2afe27909c7d87d39c048999ab190 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa4e2afe27909c7d87d39c048999ab190">detachFromParentAndDespawn</a> ()</td></tr>
<tr class="separator:aa4e2afe27909c7d87d39c048999ab190 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a921f5e7fe4deb183e7910be557b1da inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a3a921f5e7fe4deb183e7910be557b1da">addChildNode</a> (const sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &amp;pNode, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> locationRule=AttachmentRule::KEEP_WORLD, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> rotationRule=AttachmentRule::KEEP_WORLD, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> scaleRule=AttachmentRule::KEEP_WORLD)</td></tr>
<tr class="separator:a3a921f5e7fe4deb183e7910be557b1da inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cb324f9de9b495f7bc223356540a44 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ad8cb324f9de9b495f7bc223356540a44">setSerialize</a> (bool <a class="el" href="classne_1_1Node.html#a7fe9ac405df914997905a4de2045c12b">bSerialize</a>)</td></tr>
<tr class="separator:ad8cb324f9de9b495f7bc223356540a44 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9b140812be7a938906e36f6e6188b inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a40e9b140812be7a938906e36f6e6188b">serializeNodeTree</a> (const std::filesystem::path &amp;pathToFile, bool bEnableBackup)</td></tr>
<tr class="separator:a40e9b140812be7a938906e36f6e6188b inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3b419efa656af7bf82b3e85532ceed inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aaf3b419efa656af7bf82b3e85532ceed">getNodeName</a> () const</td></tr>
<tr class="separator:aaf3b419efa656af7bf82b3e85532ceed inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470c2e53992a75304574a6c3c80a87d2 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a470c2e53992a75304574a6c3c80a87d2">getWorldRootNode</a> ()</td></tr>
<tr class="separator:a470c2e53992a75304574a6c3c80a87d2 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561de14810416e06b506a6c970c296e7 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a561de14810416e06b506a6c970c296e7">getParentNode</a> ()</td></tr>
<tr class="separator:a561de14810416e06b506a6c970c296e7 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874ddce54dfd82fcda801cb799bb1b85 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcVector&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a874ddce54dfd82fcda801cb799bb1b85">getChildNodes</a> ()</td></tr>
<tr class="separator:a874ddce54dfd82fcda801cb799bb1b85 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4ff3174738477037de125dff1a0707 inherit pub_methods_classne_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; <br />
requires std::derived_from&lt;NodeType, <a class="el" href="classne_1_1Node.html">Node</a>&gt;</td></tr>
<tr class="memitem:acc4ff3174738477037de125dff1a0707 inherit pub_methods_classne_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">sgc::GcPtr&lt; NodeType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#acc4ff3174738477037de125dff1a0707">getParentNodeOfType</a> (const std::string &amp;sParentNodeName=&quot;&quot;)</td></tr>
<tr class="separator:acc4ff3174738477037de125dff1a0707 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b03a7b88779e86fd7df6f158892c86b inherit pub_methods_classne_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; <br />
requires std::derived_from&lt;NodeType, <a class="el" href="classne_1_1Node.html">Node</a>&gt;</td></tr>
<tr class="memitem:a7b03a7b88779e86fd7df6f158892c86b inherit pub_methods_classne_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">sgc::GcPtr&lt; NodeType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7b03a7b88779e86fd7df6f158892c86b">getChildNodeOfType</a> (const std::string &amp;sChildNodeName=&quot;&quot;)</td></tr>
<tr class="separator:a7b03a7b88779e86fd7df6f158892c86b inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5711513fe69f2771c6fc6bf84379768 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">TickGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ae5711513fe69f2771c6fc6bf84379768">getTickGroup</a> () const</td></tr>
<tr class="separator:ae5711513fe69f2771c6fc6bf84379768 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbae38dafd4765e9026028bd004b31c inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5cbae38dafd4765e9026028bd004b31c">getNodeId</a> () const</td></tr>
<tr class="separator:a5cbae38dafd4765e9026028bd004b31c inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0a06a7b62617e293529f2e0f89cd81 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#afe0a06a7b62617e293529f2e0f89cd81">isCalledEveryFrame</a> ()</td></tr>
<tr class="separator:afe0a06a7b62617e293529f2e0f89cd81 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab524a575030ca4f5a505c800680bcbb8 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab524a575030ca4f5a505c800680bcbb8">isReceivingInput</a> ()</td></tr>
<tr class="separator:ab524a575030ca4f5a505c800680bcbb8 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452b5f388d94b20c652ae661caca5fd inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab452b5f388d94b20c652ae661caca5fd">isSpawned</a> ()</td></tr>
<tr class="separator:ab452b5f388d94b20c652ae661caca5fd inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f66ab4ad5300e502fe964e8717f642 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab4f66ab4ad5300e502fe964e8717f642">isParentOf</a> (<a class="el" href="classne_1_1Node.html">Node</a> *pNode)</td></tr>
<tr class="separator:ab4f66ab4ad5300e502fe964e8717f642 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d48dcaa587589d0242d523d62bd9d27 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7d48dcaa587589d0242d523d62bd9d27">isChildOf</a> (<a class="el" href="classne_1_1Node.html">Node</a> *pNode)</td></tr>
<tr class="separator:a7d48dcaa587589d0242d523d62bd9d27 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0a97f3a5893d137ef01aa155426706 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aca0a97f3a5893d137ef01aa155426706">isSerialized</a> () const</td></tr>
<tr class="separator:aca0a97f3a5893d137ef01aa155426706 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a2b1c9ee24ea69f0b6231eff5a262e348 inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a2b1c9ee24ea69f0b6231eff5a262e348">serialize</a> (std::filesystem::path pathToFile, bool bEnableBackup, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={})</td></tr>
<tr class="separator:a2b1c9ee24ea69f0b6231eff5a262e348 inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a79714019d1b40ce8d063b920bbdcf inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af0a79714019d1b40ce8d063b920bbdcf">serialize</a> (toml::value &amp;tomlData, const std::string &amp;sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:af0a79714019d1b40ce8d063b920bbdcf inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99dd41bee3fdcea40c80bf317cc590d inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#aa99dd41bee3fdcea40c80bf317cc590d">serialize</a> (toml::value &amp;tomlData, <a class="el" href="classne_1_1Serializable.html">Serializable</a> *pOriginalObject, std::string sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:aa99dd41bee3fdcea40c80bf317cc590d inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0404cdf34dc3fb25b7932a87ed9ade38 inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a0404cdf34dc3fb25b7932a87ed9ade38">getPathDeserializedFromRelativeToRes</a> () const</td></tr>
<tr class="separator:a0404cdf34dc3fb25b7932a87ed9ade38 inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae2c7e2a2dcad5b88a2636e212ca87503"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#ae2c7e2a2dcad5b88a2636e212ca87503">getMeshShaderConstantBufferName</a> ()</td></tr>
<tr class="separator:ae2c7e2a2dcad5b88a2636e212ca87503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classne_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classne_1_1Node')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classne_1_1Node.html">ne::Node</a></td></tr>
<tr class="memitem:a881561ee518c6b936d7b973c89b26b62 inherit pub_static_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a881561ee518c6b936d7b973c89b26b62">getAliveNodeCount</a> ()</td></tr>
<tr class="separator:a881561ee518c6b936d7b973c89b26b62 inherit pub_static_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45ecbcfa73932f521f10154cd65e35 inherit pub_static_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7b45ecbcfa73932f521f10154cd65e35">deserializeNodeTree</a> (const std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:a7b45ecbcfa73932f521f10154cd65e35 inherit pub_static_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeb90fc6bd28ec3b54e9f8f641c3574 inherit pub_static_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a2aeb90fc6bd28ec3b54e9f8f641c3574">getGameInstance</a> ()</td></tr>
<tr class="separator:a2aeb90fc6bd28ec3b54e9f8f641c3574 inherit pub_static_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a6cd50b9cef87748dede76ba3ef125e43 inherit pub_static_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::pair&lt; std::set&lt; std::string &gt;, toml::value &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a6cd50b9cef87748dede76ba3ef125e43">getIdsFromFile</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a6cd50b9cef87748dede76ba3ef125e43 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f76ea78f80fb43e5e481277a930b364 inherit pub_static_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a1f76ea78f80fb43e5e481277a930b364">serializeMultiple</a> (std::filesystem::path pathToFile, std::vector&lt; <a class="el" href="structne_1_1SerializableObjectInformation.html">SerializableObjectInformation</a> &gt; vObjects, bool bEnableBackup)</td></tr>
<tr class="separator:a1f76ea78f80fb43e5e481277a930b364 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a> (const std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a3162d0dbc003bfcef8c0ae0846b32f77">deserialize</a> (const std::filesystem::path &amp;pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes)</td></tr>
<tr class="separator:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a32a58a89522b5cca64db7b6750a73a19">deserialize</a> (std::filesystem::path pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#afb8e66a57cc108fca4d35ae40de8e22a">deserialize</a> (const std::filesystem::path &amp;pathToFile, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::same_as&lt;SmartPointer, sgc::GcPtr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; std::vector&lt; <a class="el" href="structne_1_1DeserializedObjectInformation.html">DeserializedObjectInformation</a>&lt; SmartPointer &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a5d16d519e3d326cbdc101e78ca1a2478">deserializeMultiple</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af67ef936c5d20e2f861430b48c69c95a">deserialize</a> (const toml::value &amp;tomlData, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, std::string sEntityId=&quot;&quot;, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={})</td></tr>
<tr class="separator:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a453c3a079be0120c8c9fb7cd3a5a6899"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a453c3a079be0120c8c9fb7cd3a5a6899">onAfterDeserialized</a> () override</td></tr>
<tr class="separator:a453c3a079be0120c8c9fb7cd3a5a6899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7127ccc4f7cc62ab5f74583920ee93ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a7127ccc4f7cc62ab5f74583920ee93ee">onSpawning</a> () override</td></tr>
<tr class="separator:a7127ccc4f7cc62ab5f74583920ee93ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53861da301908fac9900bd11073b745f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a53861da301908fac9900bd11073b745f">onDespawning</a> () override</td></tr>
<tr class="separator:a53861da301908fac9900bd11073b745f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b459c63b02d3f8fa269ba17d93bf5e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a74b459c63b02d3f8fa269ba17d93bf5e">onWorldLocationRotationScaleChanged</a> () override</td></tr>
<tr class="separator:a74b459c63b02d3f8fa269ba17d93bf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf53c8e5bcfdc8cbb3d1bc359ff01273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#adf53c8e5bcfdc8cbb3d1bc359ff01273">setShaderCpuWriteResourceBinding</a> (const std::string &amp;sShaderResourceName, size_t iResourceSizeInBytes, const std::function&lt; void *()&gt; &amp;onStartedUpdatingResource, const std::function&lt; void()&gt; &amp;onFinishedUpdatingResource)</td></tr>
<tr class="separator:adf53c8e5bcfdc8cbb3d1bc359ff01273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6098a2228cffcf6caadeaf98546bbda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#ac6098a2228cffcf6caadeaf98546bbda">setShaderTextureResourceBinding</a> (const std::string &amp;sShaderResourceName, const std::string &amp;sPathToTextureResourceRelativeRes)</td></tr>
<tr class="separator:ac6098a2228cffcf6caadeaf98546bbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8fe299045faa38a4ac4fa458753422"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a7a8fe299045faa38a4ac4fa458753422">markShaderCpuWriteResourceToBeCopiedToGpu</a> (const std::string &amp;sShaderResourceName)</td></tr>
<tr class="separator:a7a8fe299045faa38a4ac4fa458753422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classne_1_1SpatialNode"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classne_1_1SpatialNode')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classne_1_1SpatialNode.html">ne::SpatialNode</a></td></tr>
<tr class="memitem:a4ef72e0c9e17fba2aeae88a87c424a84 inherit pro_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a4ef72e0c9e17fba2aeae88a87c424a84">onAfterDeserialized</a> () override</td></tr>
<tr class="separator:a4ef72e0c9e17fba2aeae88a87c424a84 inherit pro_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af79f3d46f46b70636d67b70dab12d2 inherit pro_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a3af79f3d46f46b70636d67b70dab12d2">onSpawning</a> () override</td></tr>
<tr class="separator:a3af79f3d46f46b70636d67b70dab12d2 inherit pro_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae883c06ca2bc4bd917de5486cbbda0d4 inherit pro_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#ae883c06ca2bc4bd917de5486cbbda0d4">onAfterAttachedToNewParent</a> (bool bThisNodeBeingAttached) override</td></tr>
<tr class="separator:ae883c06ca2bc4bd917de5486cbbda0d4 inherit pro_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf62ec87e7faeebafc764a2b71ae92b6 inherit pro_methods_classne_1_1SpatialNode"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#adf62ec87e7faeebafc764a2b71ae92b6">onWorldLocationRotationScaleChanged</a> ()</td></tr>
<tr class="separator:adf62ec87e7faeebafc764a2b71ae92b6 inherit pro_methods_classne_1_1SpatialNode"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classne_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classne_1_1Node')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classne_1_1Node.html">ne::Node</a></td></tr>
<tr class="memitem:a9294c7c58a8b4f85b7674c55751f4b13 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a9294c7c58a8b4f85b7674c55751f4b13">setIsCalledEveryFrame</a> (bool bEnable)</td></tr>
<tr class="separator:a9294c7c58a8b4f85b7674c55751f4b13 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138f69f892f8b80a89262b8a5f7625b8 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a138f69f892f8b80a89262b8a5f7625b8">setTickGroup</a> (TickGroup <a class="el" href="classne_1_1Node.html#aee673da17a5126031bbb957fa2833505">tickGroup</a>)</td></tr>
<tr class="separator:a138f69f892f8b80a89262b8a5f7625b8 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecdaaf48f89ae036a48ecb38d3ac382 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> (bool bEnable)</td></tr>
<tr class="separator:a8ecdaaf48f89ae036a48ecb38d3ac382 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e80560b3b2f02be42285e60195f1b64 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Timer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a0e80560b3b2f02be42285e60195f1b64">createTimer</a> (const std::string &amp;sTimerName)</td></tr>
<tr class="separator:a0e80560b3b2f02be42285e60195f1b64 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2dca870a640ac24053a76b804ce111 inherit pro_methods_classne_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType &gt; </td></tr>
<tr class="memitem:a5f2dca870a640ac24053a76b804ce111 inherit pro_methods_classne_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classne_1_1NodeNotificationBroadcaster.html">NodeNotificationBroadcaster</a>&lt; FunctionType &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5f2dca870a640ac24053a76b804ce111">createNotificationBroadcaster</a> ()</td></tr>
<tr class="separator:a5f2dca870a640ac24053a76b804ce111 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77035ce347e8bf68b564b5358ef4b5cc inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a77035ce347e8bf68b564b5358ef4b5cc">getActionEventBindings</a> ()</td></tr>
<tr class="separator:a77035ce347e8bf68b564b5358ef4b5cc inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062c7be217334d4bce02ce34c32e00cb inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a062c7be217334d4bce02ce34c32e00cb">getAxisEventBindings</a> ()</td></tr>
<tr class="separator:a062c7be217334d4bce02ce34c32e00cb inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893cf9d4987d1b3ece76c0ffa0577e6d inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::recursive_mutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a893cf9d4987d1b3ece76c0ffa0577e6d">getSpawnDespawnMutex</a> ()</td></tr>
<tr class="separator:a893cf9d4987d1b3ece76c0ffa0577e6d inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5e6b60ec1e1fdf9d1b7d6cb8387b74 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5b5e6b60ec1e1fdf9d1b7d6cb8387b74">onMouseMove</a> (double xOffset, double yOffset)</td></tr>
<tr class="separator:a5b5e6b60ec1e1fdf9d1b7d6cb8387b74 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde53f1d8c88385fb8ba338820e77c8e inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#adde53f1d8c88385fb8ba338820e77c8e">onMouseScrollMove</a> (int iOffset)</td></tr>
<tr class="separator:adde53f1d8c88385fb8ba338820e77c8e inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccde9ffedb8ce10cfb4cbdd8b6ea59a inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> (float timeSincePrevFrameInSec)</td></tr>
<tr class="separator:a6ccde9ffedb8ce10cfb4cbdd8b6ea59a inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2310c20abcd99331c4d6b104e1e919 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#abe2310c20abcd99331c4d6b104e1e919">onSpawning</a> ()</td></tr>
<tr class="separator:abe2310c20abcd99331c4d6b104e1e919 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cba5cd17e5e968ed92f162b5a9f08b inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a79cba5cd17e5e968ed92f162b5a9f08b">onChildNodesSpawned</a> ()</td></tr>
<tr class="separator:a79cba5cd17e5e968ed92f162b5a9f08b inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890cf446e639ac9dd1e9e7832cf796ed inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a890cf446e639ac9dd1e9e7832cf796ed">onDespawning</a> ()</td></tr>
<tr class="separator:a890cf446e639ac9dd1e9e7832cf796ed inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e4a732c0e3578d8a5551693b8c02aa inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a53e4a732c0e3578d8a5551693b8c02aa">onBeforeDetachedFromParent</a> (bool bThisNodeBeingDetached)</td></tr>
<tr class="separator:a53e4a732c0e3578d8a5551693b8c02aa inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e67ce1bfe3c1015630301e3c53411f inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab7e67ce1bfe3c1015630301e3c53411f">onAfterAttachedToNewParent</a> (bool bThisNodeBeingAttached)</td></tr>
<tr class="separator:ab7e67ce1bfe3c1015630301e3c53411f inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00002d59e5d0dcda6e53c20b59947150"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a00002d59e5d0dcda6e53c20b59947150">onAfterDeserialized</a> ()</td></tr>
<tr class="separator:a00002d59e5d0dcda6e53c20b59947150"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a995527f60cf6160e427183e604ae9c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a995527f60cf6160e427183e604ae9c89">allocateShaderResources</a> ()</td></tr>
<tr class="separator:a995527f60cf6160e427183e604ae9c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39074f6279baeea3d03794f4480d4c29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a39074f6279baeea3d03794f4480d4c29">allocateGeometryBuffers</a> ()</td></tr>
<tr class="separator:a39074f6279baeea3d03794f4480d4c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd309b596dd9b63483f174af4f64b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a6fd309b596dd9b63483f174af4f64b95">deallocateShaderResources</a> ()</td></tr>
<tr class="separator:a6fd309b596dd9b63483f174af4f64b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee6b4fa44a505403f4255a2a3cdbc99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#abee6b4fa44a505403f4255a2a3cdbc99">deallocateGeometryBuffers</a> ()</td></tr>
<tr class="separator:abee6b4fa44a505403f4255a2a3cdbc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf06c681193ebc25c067b64e05f52871"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#aaf06c681193ebc25c067b64e05f52871">onStartedUpdatingShaderMeshConstants</a> ()</td></tr>
<tr class="separator:aaf06c681193ebc25c067b64e05f52871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ea8756566f5a6b8016e3f919050211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a59ea8756566f5a6b8016e3f919050211">onFinishedUpdatingShaderMeshConstants</a> ()</td></tr>
<tr class="separator:a59ea8756566f5a6b8016e3f919050211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d0fdab3342915497cdc86b00ba30ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a37d0fdab3342915497cdc86b00ba30ba">updateShaderResourcesToUseChangedMaterialPipelines</a> ()</td></tr>
<tr class="separator:a37d0fdab3342915497cdc86b00ba30ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ac0f144af7a1a9786a1be3684fc754"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a90ac0f144af7a1a9786a1be3684fc754">getIndexBufferInfoForMaterialSlot</a> (size_t iMaterialSlot)</td></tr>
<tr class="separator:a90ac0f144af7a1a9786a1be3684fc754"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ad5c28bad20f7a24d30f248602ca9aff0"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classne_1_1Material.html">Material</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#ad5c28bad20f7a24d30f248602ca9aff0">getDefaultMaterial</a> ()</td></tr>
<tr class="separator:ad5c28bad20f7a24d30f248602ca9aff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adc328650dced2f8351ec6f702d7bb44d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1Material.html">Material</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#adc328650dced2f8351ec6f702d7bb44d">vMaterials</a></td></tr>
<tr class="separator:adc328650dced2f8351ec6f702d7bb44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b250fb570ed3679ac1e52c84e6455a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1MeshData.html">MeshData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a3b250fb570ed3679ac1e52c84e6455a3">meshData</a></td></tr>
<tr class="separator:a3b250fb570ed3679ac1e52c84e6455a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07925fe6a2f63fd25e918018a31faeea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structne_1_1AABB.html">AABB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a07925fe6a2f63fd25e918018a31faeea">aabb</a></td></tr>
<tr class="separator:a07925fe6a2f63fd25e918018a31faeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a5728de87baff4232c78322627435a"><td class="memItemLeft" align="right" valign="top">std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#af5a5728de87baff4232c78322627435a">mtxMeshData</a></td></tr>
<tr class="separator:af5a5728de87baff4232c78322627435a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f182285c84099513809acf961169c12"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1MeshNode_1_1GpuResources.html">GpuResources</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a4f182285c84099513809acf961169c12">mtxGpuResources</a></td></tr>
<tr class="separator:a4f182285c84099513809acf961169c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa524ac9c5eda6a9e704e833e804c69e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1MeshNode_1_1MeshShaderConstants.html">MeshShaderConstants</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#afa524ac9c5eda6a9e704e833e804c69e">mtxShaderMeshDataConstants</a></td></tr>
<tr class="separator:afa524ac9c5eda6a9e704e833e804c69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb4105e07d36b244e6cd374f86958b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a3cb4105e07d36b244e6cd374f86958b7">bIsVisible</a> = true</td></tr>
<tr class="separator:a3cb4105e07d36b244e6cd374f86958b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a8c41558c27b79d1cb8cf9861769d2f68"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1MeshNode.html#a8c41558c27b79d1cb8cf9861769d2f68">sMeshShaderConstantBufferName</a> = &quot;meshData&quot;</td></tr>
<tr class="separator:a8c41558c27b79d1cb8cf9861769d2f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa1212b6e372a0f45d2c01f3cd203af77"><td class="memItemLeft" align="right" valign="top"><a id="aa1212b6e372a0f45d2c01f3cd203af77" name="aa1212b6e372a0f45d2c01f3cd203af77"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Material</b></td></tr>
<tr class="separator:aa1212b6e372a0f45d2c01f3cd203af77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classne_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classne_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classne_1_1Node.html">ne::Node</a></td></tr>
<tr class="memitem:a14bad364fb30a60063a147b95ab17acc inherit pub_types_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> { <b>RESET_RELATIVE</b>
, <b>KEEP_RELATIVE</b>
, <b>KEEP_WORLD</b>
 }</td></tr>
<tr class="separator:a14bad364fb30a60063a147b95ab17acc inherit pub_types_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a node that can have 3D geometry to display (mesh).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Used for GPU optimized geometry - geometry that rarely (if ever) changes from the CPU side. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ed41a6566e750963f8cb3f8f5eb1963" name="a6ed41a6566e750963f8cb3f8f5eb1963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed41a6566e750963f8cb3f8f5eb1963">&#9670;&#160;</a></span>MeshNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::MeshNode::MeshNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sNodeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new node with the specified name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sNodeName</td><td>Name of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a39074f6279baeea3d03794f4480d4c29" name="a39074f6279baeea3d03794f4480d4c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39074f6279baeea3d03794f4480d4c29">&#9670;&#160;</a></span>allocateGeometryBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::allocateGeometryBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Allocates geometry resources (see <a class="el" href="classne_1_1MeshNode.html#a4f182285c84099513809acf961169c12">mtxGpuResources</a>). </p>

</div>
</div>
<a id="a995527f60cf6160e427183e604ae9c89" name="a995527f60cf6160e427183e604ae9c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995527f60cf6160e427183e604ae9c89">&#9670;&#160;</a></span>allocateShaderResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::allocateShaderResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Allocates shader resources (see <a class="el" href="classne_1_1MeshNode.html#a4f182285c84099513809acf961169c12">mtxGpuResources</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that <a class="el" href="classne_1_1MeshNode.html#adc328650dced2f8351ec6f702d7bb44d">vMaterials</a> to have initialized PSOs. </dd></dl>

</div>
</div>
<a id="abee6b4fa44a505403f4255a2a3cdbc99" name="abee6b4fa44a505403f4255a2a3cdbc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee6b4fa44a505403f4255a2a3cdbc99">&#9670;&#160;</a></span>deallocateGeometryBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::deallocateGeometryBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deallocates geometry resources (see <a class="el" href="classne_1_1MeshNode.html#a4f182285c84099513809acf961169c12">mtxGpuResources</a>). </p>

</div>
</div>
<a id="a6fd309b596dd9b63483f174af4f64b95" name="a6fd309b596dd9b63483f174af4f64b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd309b596dd9b63483f174af4f64b95">&#9670;&#160;</a></span>deallocateShaderResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::deallocateShaderResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deallocates shader resources (see <a class="el" href="classne_1_1MeshNode.html#a4f182285c84099513809acf961169c12">mtxGpuResources</a>). </p>

</div>
</div>
<a id="a6295e3796e64c6fb4d4552e46cf9f14a" name="a6295e3796e64c6fb4d4552e46cf9f14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6295e3796e64c6fb4d4552e46cf9f14a">&#9670;&#160;</a></span>getAABB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structne_1_1AABB.html">AABB</a> * ne::MeshNode::getAABB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns pointer to axis-aligned bounding box of this mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>Axis-aligned bounding box. </dd></dl>

</div>
</div>
<a id="a8911af4b77829e58ed0d59466d2ba18a" name="a8911af4b77829e58ed0d59466d2ba18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8911af4b77829e58ed0d59466d2ba18a">&#9670;&#160;</a></span>getAvailableMaterialSlotCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::MeshNode::getAvailableMaterialSlotCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the total number of available material slots that the current mesh data (see <a class="el" href="classne_1_1MeshNode.html#a4e9fc27cf88ec1ec90d732b8fe71737c">setMeshData</a>) provides.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of available material slots. </dd></dl>

</div>
</div>
<a id="ad5c28bad20f7a24d30f248602ca9aff0" name="ad5c28bad20f7a24d30f248602ca9aff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c28bad20f7a24d30f248602ca9aff0">&#9670;&#160;</a></span>getDefaultMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classne_1_1Material.html">Material</a> &gt; ne::MeshNode::getDefaultMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns default mesh node material.</p>
<dl class="section return"><dt>Returns</dt><dd>Default material for mesh node. </dd></dl>

</div>
</div>
<a id="a90ac0f144af7a1a9786a1be3684fc754" name="a90ac0f144af7a1a9786a1be3684fc754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ac0f144af7a1a9786a1be3684fc754">&#9670;&#160;</a></span>getIndexBufferInfoForMaterialSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, unsigned int &gt; ne::MeshNode::getIndexBufferInfoForMaterialSlot </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iMaterialSlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns information about an index buffer for the specified material slot.</p>
<dl class="section warning"><dt>Warning</dt><dd>Shows an error and throws an exception if the index buffer at the specified index cannon be found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMaterialSlot</td><td><a class="el" href="classne_1_1Material.html">Material</a> slot that corresponds with an index buffer to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information about an index buffer at the specified material slot. </dd></dl>

</div>
</div>
<a id="a83cb60dfc8713be834295480cbeb4414" name="a83cb60dfc8713be834295480cbeb4414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cb60dfc8713be834295480cbeb4414">&#9670;&#160;</a></span>getMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Material.html">Material</a> * ne::MeshNode::getMaterial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iMaterialSlot</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns material used by this name.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete (free) returned pointer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMaterialSlot</td><td>Slot from which requested material is taken from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if the specified slot does not exist (see <a class="el" href="classne_1_1MeshNode.html#a8911af4b77829e58ed0d59466d2ba18a">getAvailableMaterialSlotCount</a>), otherwise used material. </dd></dl>

</div>
</div>
<a id="a27eb0a143ae98c2419c2e5eef36df9cf" name="a27eb0a143ae98c2419c2e5eef36df9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27eb0a143ae98c2419c2e5eef36df9cf">&#9670;&#160;</a></span>getMeshData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex *, <a class="el" href="classne_1_1MeshData.html">MeshData</a> * &gt; ne::MeshNode::getMeshData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns mesh geometry for read/write operations.</p>
<dl class="section warning"><dt>Warning</dt><dd>Must be used with mutex.</dd>
<dd>
If you're changing mesh data you must call <a class="el" href="classne_1_1MeshNode.html#add9e3c1ba2be62c9f806bb2b7eae78e2">onMeshDataChanged</a> after you finished modifying the mesh data to update internal CPU/GPU resources and see updated geometry on the screen, otherwise this might cause the object to be displayed incorrectly.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note that changing mesh data using <a class="el" href="classne_1_1MeshNode.html#add9e3c1ba2be62c9f806bb2b7eae78e2">onMeshDataChanged</a> will have the same performance as if you used <a class="el" href="classne_1_1MeshNode.html#a4e9fc27cf88ec1ec90d732b8fe71737c">setMeshData</a> because they both do the same work. The main reason why this getter exists is to avoid copying <a class="el" href="classne_1_1MeshData.html">MeshData</a> when somebody wants to read/modify existing mesh data.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Mesh data. </dd></dl>

</div>
</div>
<a id="a3f15c8ce01a9270e58ab56518bfe7098" name="a3f15c8ce01a9270e58ab56518bfe7098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f15c8ce01a9270e58ab56518bfe7098">&#9670;&#160;</a></span>getMeshGpuResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1MeshNode_1_1GpuResources.html">GpuResources</a> &gt; * ne::MeshNode::getMeshGpuResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns GPU resources that this mesh node uses.</p>
<dl class="section return"><dt>Returns</dt><dd>GPU resources. </dd></dl>

</div>
</div>
<a id="ae2c7e2a2dcad5b88a2636e212ca87503" name="ae2c7e2a2dcad5b88a2636e212ca87503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c7e2a2dcad5b88a2636e212ca87503">&#9670;&#160;</a></span>getMeshShaderConstantBufferName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * ne::MeshNode::getMeshShaderConstantBufferName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns name of the constant buffer that stores mesh constants.</p>
<dl class="section return"><dt>Returns</dt><dd>Name of shader resource. </dd></dl>

</div>
</div>
<a id="aaea00de98b55c7e4a6f0ad6abe9db77f" name="aaea00de98b55c7e4a6f0ad6abe9db77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea00de98b55c7e4a6f0ad6abe9db77f">&#9670;&#160;</a></span>getMeshShaderConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1MeshNode_1_1MeshShaderConstants.html">MeshShaderConstants</a> &gt; * ne::MeshNode::getMeshShaderConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns shader constants (copied to GPU).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Changes made this returned object will not be copied to the GPU, this getter only exists read access.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Mesh constants. </dd></dl>

</div>
</div>
<a id="a4ec40629a5cb70acb3aa3172349e6440" name="a4ec40629a5cb70acb3aa3172349e6440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec40629a5cb70acb3aa3172349e6440">&#9670;&#160;</a></span>isVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::MeshNode::isVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tells whether this mesh is currently visible or not.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether the mesh is visible or not. </dd></dl>

</div>
</div>
<a id="a7a8fe299045faa38a4ac4fa458753422" name="a7a8fe299045faa38a4ac4fa458753422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8fe299045faa38a4ac4fa458753422">&#9670;&#160;</a></span>markShaderCpuWriteResourceToBeCopiedToGpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::markShaderCpuWriteResourceToBeCopiedToGpu </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Looks for binding created using <a class="el" href="classne_1_1MeshNode.html#adf53c8e5bcfdc8cbb3d1bc359ff01273">setShaderCpuWriteResourceBinding</a> and notifies the engine that there is new (updated) data for shader CPU write resource to copy to the GPU to be used by shaders.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You don't need to check if the node is spawned or not before calling this function, if the binding does not exist or some other condition is not met this call will be silently ignored without any errors.</dd>
<dd>
Note that the callbacks that you have specified in <a class="el" href="classne_1_1MeshNode.html#adf53c8e5bcfdc8cbb3d1bc359ff01273">setShaderCpuWriteResourceBinding</a> will not be called inside of this function, moreover they are most likely to be called in the next frame(s) (most likely multiple times) when the engine is ready to copy the data to the GPU, so if the resource's data is used by multiple threads in your code, make sure to use mutex or other synchronization primitive in your callbacks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the shader CPU write resource (should be exactly the same as the resource name written in the shader file we are referencing). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a453c3a079be0120c8c9fb7cd3a5a6899" name="a453c3a079be0120c8c9fb7cd3a5a6899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453c3a079be0120c8c9fb7cd3a5a6899">&#9670;&#160;</a></span>onAfterDeserialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::onAfterDeserialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after the object was successfully deserialized. Used to execute post-deserialization logic.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented from <a class="el" href="classne_1_1SpatialNode.html#a4ef72e0c9e17fba2aeae88a87c424a84">ne::SpatialNode</a>.</p>

</div>
</div>
<a id="a53861da301908fac9900bd11073b745f" name="a53861da301908fac9900bd11073b745f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53861da301908fac9900bd11073b745f">&#9670;&#160;</a></span>onDespawning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::onDespawning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called before this node is despawned from the world to execute custom despawn logic.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This node will be marked as despawned after this function is called. </dd>
<dd>
This function is called after all child nodes were despawned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented from <a class="el" href="classne_1_1Node.html#a890cf446e639ac9dd1e9e7832cf796ed">ne::Node</a>.</p>

</div>
</div>
<a id="a59ea8756566f5a6b8016e3f919050211" name="a59ea8756566f5a6b8016e3f919050211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ea8756566f5a6b8016e3f919050211">&#9670;&#160;</a></span>onFinishedUpdatingShaderMeshConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::onFinishedUpdatingShaderMeshConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after finished copying data from <a class="el" href="classne_1_1MeshNode.html#afa524ac9c5eda6a9e704e833e804c69e">mtxShaderMeshDataConstants</a>. </p>

</div>
</div>
<a id="add9e3c1ba2be62c9f806bb2b7eae78e2" name="add9e3c1ba2be62c9f806bb2b7eae78e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9e3c1ba2be62c9f806bb2b7eae78e2">&#9670;&#160;</a></span>onMeshDataChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::onMeshDataChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Must be called after mesh data was modified to (re)create internal CPU/GPU resources. </p>

</div>
</div>
<a id="a7127ccc4f7cc62ab5f74583920ee93ee" name="a7127ccc4f7cc62ab5f74583920ee93ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7127ccc4f7cc62ab5f74583920ee93ee">&#9670;&#160;</a></span>onSpawning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::onSpawning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when this node was not spawned previously and it was either attached to a parent node that is spawned or set as world's root node to execute custom spawn logic.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This node will be marked as spawned before this function is called. </dd>
<dd>
This function is called before any of the child nodes are spawned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented from <a class="el" href="classne_1_1SpatialNode.html#a3af79f3d46f46b70636d67b70dab12d2">ne::SpatialNode</a>.</p>

</div>
</div>
<a id="aaf06c681193ebc25c067b64e05f52871" name="aaf06c681193ebc25c067b64e05f52871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf06c681193ebc25c067b64e05f52871">&#9670;&#160;</a></span>onStartedUpdatingShaderMeshConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * ne::MeshNode::onStartedUpdatingShaderMeshConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called to copy data from <a class="el" href="classne_1_1MeshNode.html#afa524ac9c5eda6a9e704e833e804c69e">mtxShaderMeshDataConstants</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to data in <a class="el" href="classne_1_1MeshNode.html#afa524ac9c5eda6a9e704e833e804c69e">mtxShaderMeshDataConstants</a>. </dd></dl>

</div>
</div>
<a id="a74b459c63b02d3f8fa269ba17d93bf5e" name="a74b459c63b02d3f8fa269ba17d93bf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b459c63b02d3f8fa269ba17d93bf5e">&#9670;&#160;</a></span>onWorldLocationRotationScaleChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::onWorldLocationRotationScaleChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after node's world location/rotation/scale was changed.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented from <a class="el" href="classne_1_1SpatialNode.html#adf62ec87e7faeebafc764a2b71ae92b6">ne::SpatialNode</a>.</p>

</div>
</div>
<a id="aaf28d800c9aaaaa16f20ff190a913667" name="aaf28d800c9aaaaa16f20ff190a913667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf28d800c9aaaaa16f20ff190a913667">&#9670;&#160;</a></span>setIsVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::setIsVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVisible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets whether this mesh is visible or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bVisible</td><td>Whether this mesh is visible or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a600afde2008f201682f59751d175efb7" name="a600afde2008f201682f59751d175efb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600afde2008f201682f59751d175efb7">&#9670;&#160;</a></span>setMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::setMaterial </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classne_1_1Material.html">Material</a> &gt;&#160;</td>
          <td class="paramname"><em>pMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iMaterialSlot</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets material to use.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Replaces old (previously used) material.</dd>
<dd>
Logs an error if the specified material slot does not exist (see <a class="el" href="classne_1_1MeshNode.html#a8911af4b77829e58ed0d59466d2ba18a">getAvailableMaterialSlotCount</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMaterial</td><td><a class="el" href="classne_1_1Material.html">Material</a> to use. </td></tr>
    <tr><td class="paramname">iMaterialSlot</td><td>Index of the material slot to set this new material to. By default all meshes have 1 material at slot 0 and mesh's geometry uses only this slot. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e9fc27cf88ec1ec90d732b8fe71737c" name="a4e9fc27cf88ec1ec90d732b8fe71737c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9fc27cf88ec1ec90d732b8fe71737c">&#9670;&#160;</a></span>setMeshData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::setMeshData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classne_1_1MeshData.html">MeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>meshData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets mesh data (geometry) to use.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The number of available material slots will be changed according to the mesh data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshData</td><td>Mesh geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d4e8cd51eaf440c9a77a715d8543e24" name="a0d4e8cd51eaf440c9a77a715d8543e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4e8cd51eaf440c9a77a715d8543e24">&#9670;&#160;</a></span>setMeshData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::setMeshData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1MeshData.html">MeshData</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>meshData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets mesh data (geometry) to use.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The number of available material slots will be changed according to the mesh data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshData</td><td>Mesh geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf53c8e5bcfdc8cbb3d1bc359ff01273" name="adf53c8e5bcfdc8cbb3d1bc359ff01273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf53c8e5bcfdc8cbb3d1bc359ff01273">&#9670;&#160;</a></span>setShaderCpuWriteResourceBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::setShaderCpuWriteResourceBinding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iResourceSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void *()&gt; &amp;&#160;</td>
          <td class="paramname"><em>onStartedUpdatingResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>onFinishedUpdatingResource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Setups callbacks for a shader resource (buffer or a texture from the shader code) with CPU write access to copy the data from the CPU to the GPU to be used by the shaders.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Call this function in your <a class="el" href="classne_1_1MeshNode.html#a7127ccc4f7cc62ab5f74583920ee93ee">onSpawning</a> function to bind to shader resources, all bindings will be automatically removed in <a class="el" href="classne_1_1MeshNode.html#a53861da301908fac9900bd11073b745f">onDespawning</a>. An error will be shown if this function is called when the node is not spawned.</dd>
<dd>
When the data of a resource that you registered was updated on the CPU side you need to call <a class="el" href="classne_1_1MeshNode.html#a7a8fe299045faa38a4ac4fa458753422">markShaderCpuWriteResourceToBeCopiedToGpu</a> so that the specified update callbacks will be called and the updated data will be copied to the GPU to be used by the shaders. Note that you don't need to call <a class="el" href="classne_1_1MeshNode.html#a7a8fe299045faa38a4ac4fa458753422">markShaderCpuWriteResourceToBeCopiedToGpu</a> for resources you have not registered yourself. Also note that all registered resources are marked as "needs an update" by default so you don't have to call <a class="el" href="classne_1_1MeshNode.html#a7a8fe299045faa38a4ac4fa458753422">markShaderCpuWriteResourceToBeCopiedToGpu</a> right after calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the resource we are referencing (should be exactly the same as the resource name written in the shader file we are referencing). </td></tr>
    <tr><td class="paramname">iResourceSizeInBytes</td><td>Size of the data that this resource will contain. Note that the specified size will most likely be padded (changed) to be a multiple of 256 because of the hardware requirement for shader constant buffers. </td></tr>
    <tr><td class="paramname">onStartedUpdatingResource</td><td>Function that will be called when the engine has started copying data to the GPU. Function returns pointer to new (updated) data of the specified resource that will be copied to the GPU. </td></tr>
    <tr><td class="paramname">onFinishedUpdatingResource</td><td>Function that will be called when the engine has finished copying resource data to the GPU (usually used for unlocking mutexes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6098a2228cffcf6caadeaf98546bbda" name="ac6098a2228cffcf6caadeaf98546bbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6098a2228cffcf6caadeaf98546bbda">&#9670;&#160;</a></span>setShaderTextureResourceBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::setShaderTextureResourceBinding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sPathToTextureResourceRelativeRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Setups a shader resource binding that references a texture from the shader code that is used when this mesh is rendered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Call this function in <a class="el" href="classne_1_1MeshNode.html#a995527f60cf6160e427183e604ae9c89">allocateShaderResources</a> to bind to shader resources, all bindings will be automatically removed in <a class="el" href="classne_1_1MeshNode.html#a6fd309b596dd9b63483f174af4f64b95">deallocateShaderResources</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the resource we are referencing (should be exactly the same as the resource name written in the shader file we are referencing). </td></tr>
    <tr><td class="paramname">sPathToTextureResourceRelativeRes</td><td>Path to the directory with texture resource to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d0fdab3342915497cdc86b00ba30ba" name="a37d0fdab3342915497cdc86b00ba30ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d0fdab3342915497cdc86b00ba30ba">&#9670;&#160;</a></span>updateShaderResourcesToUseChangedMaterialPipelines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::MeshNode::updateShaderResourcesToUseChangedMaterialPipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after <a class="el" href="classne_1_1MeshNode.html#adc328650dced2f8351ec6f702d7bb44d">vMaterials</a> is changed (some slots are added/removed) to notify all shader resources.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the caller is using some mutex to protect this shader resource from being used in the <code>draw</code> function while this function is not finished (i.e. make sure the CPU will not queue a new frame while this function is not finished).</dd>
<dd>
Expects that the node is spawned and all <a class="el" href="classne_1_1MeshNode.html#adc328650dced2f8351ec6f702d7bb44d">vMaterials</a> have pipelines initialized. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a07925fe6a2f63fd25e918018a31faeea" name="a07925fe6a2f63fd25e918018a31faeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07925fe6a2f63fd25e918018a31faeea">&#9670;&#160;</a></span>aabb</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structne_1_1AABB.html">AABB</a> ne::MeshNode::aabb</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Axis-aligned bounding box for <a class="el" href="classne_1_1MeshNode.html#a3b250fb570ed3679ac1e52c84e6455a3">meshData</a>. </p>

</div>
</div>
<a id="a3cb4105e07d36b244e6cd374f86958b7" name="a3cb4105e07d36b244e6cd374f86958b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb4105e07d36b244e6cd374f86958b7">&#9670;&#160;</a></span>bIsVisible</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::MeshNode::bIsVisible = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Whether mesh is visible or not. </p>

</div>
</div>
<a id="a3b250fb570ed3679ac1e52c84e6455a3" name="a3b250fb570ed3679ac1e52c84e6455a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b250fb570ed3679ac1e52c84e6455a3">&#9670;&#160;</a></span>meshData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1MeshData.html">MeshData</a> ne::MeshNode::meshData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Mesh geometry.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use with <a class="el" href="classne_1_1MeshNode.html#af5a5728de87baff4232c78322627435a">mtxMeshData</a>. </dd></dl>

</div>
</div>
<a id="a4f182285c84099513809acf961169c12" name="a4f182285c84099513809acf961169c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f182285c84099513809acf961169c12">&#9670;&#160;</a></span>mtxGpuResources</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1MeshNode_1_1GpuResources.html">GpuResources</a>&gt; ne::MeshNode::mtxGpuResources</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores GPU resources used by this mesh node. <br  />
 </p>

</div>
</div>
<a id="af5a5728de87baff4232c78322627435a" name="af5a5728de87baff4232c78322627435a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a5728de87baff4232c78322627435a">&#9670;&#160;</a></span>mtxMeshData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::recursive_mutex ne::MeshNode::mtxMeshData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Mutex for <a class="el" href="classne_1_1MeshNode.html#a3b250fb570ed3679ac1e52c84e6455a3">meshData</a>. </p>

</div>
</div>
<a id="afa524ac9c5eda6a9e704e833e804c69e" name="afa524ac9c5eda6a9e704e833e804c69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa524ac9c5eda6a9e704e833e804c69e">&#9670;&#160;</a></span>mtxShaderMeshDataConstants</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1MeshNode_1_1MeshShaderConstants.html">MeshShaderConstants</a>&gt; ne::MeshNode::mtxShaderMeshDataConstants</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores data for constant buffer used by shaders. </p>

</div>
</div>
<a id="a8c41558c27b79d1cb8cf9861769d2f68" name="a8c41558c27b79d1cb8cf9861769d2f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c41558c27b79d1cb8cf9861769d2f68">&#9670;&#160;</a></span>sMeshShaderConstantBufferName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto ne::MeshNode::sMeshShaderConstantBufferName = &quot;meshData&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the constant buffer used to store general mesh data in shaders. </p>

</div>
</div>
<a id="adc328650dced2f8351ec6f702d7bb44d" name="adc328650dced2f8351ec6f702d7bb44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc328650dced2f8351ec6f702d7bb44d">&#9670;&#160;</a></span>vMaterials</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="classne_1_1Material.html">Material</a>&gt; &gt; ne::MeshNode::vMaterials</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores materials of the mesh. <a class="el" href="classne_1_1Material.html">Material</a> at index 0 used by index buffer 0, material at index 1 used by index buffer 1 and so on (<a class="el" href="classne_1_1MeshNode.html#a3b250fb570ed3679ac1e52c84e6455a3">meshData</a> defines available slots).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Always contains valid pointers. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/public/game/node/<a class="el" href="MeshNode_8h_source.html">MeshNode.h</a></li>
<li>src/engine_lib/private/game/node/MeshNode.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1MeshNode.html">MeshNode</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
