<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1Node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::Node Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Node_8h_source.html">Node.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::Node:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1Node.png" usemap="#ne::Node_map" alt=""/>
  <map id="ne::Node_map" name="ne::Node_map">
<area href="classne_1_1Serializable.html" alt="ne::Serializable" shape="rect" coords="160,56,310,80"/>
<area href="classne_1_1EnvironmentNode.html" alt="ne::EnvironmentNode" shape="rect" coords="0,168,150,192"/>
<area href="classne_1_1SpatialNode.html" alt="ne::SpatialNode" shape="rect" coords="320,168,470,192"/>
<area href="classne_1_1CameraNode.html" alt="ne::CameraNode" shape="rect" coords="0,224,150,248"/>
<area href="classne_1_1DirectionalLightNode.html" alt="ne::DirectionalLightNode" shape="rect" coords="160,224,310,248"/>
<area href="classne_1_1MeshNode.html" alt="ne::MeshNode" shape="rect" coords="320,224,470,248"/>
<area href="classne_1_1PointLightNode.html" alt="ne::PointLightNode" shape="rect" coords="480,224,630,248"/>
<area href="classne_1_1SpotlightNode.html" alt="ne::SpotlightNode" shape="rect" coords="640,224,790,248"/>
<area href="classne_1_1EditorCameraNode.html" alt="ne::EditorCameraNode" shape="rect" coords="0,280,150,304"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1Node_1_1SerializableObjectInformationWithGcPointer.html">SerializableObjectInformationWithGcPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a14bad364fb30a60063a147b95ab17acc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> { <b>RESET_RELATIVE</b>
, <b>KEEP_RELATIVE</b>
, <b>KEEP_WORLD</b>
 }</td></tr>
<tr class="separator:a14bad364fb30a60063a147b95ab17acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a869b03190702ccef1f85bad536bf1a4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a869b03190702ccef1f85bad536bf1a4b">Node</a> ()</td></tr>
<tr class="separator:a869b03190702ccef1f85bad536bf1a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e8ff8b016048cb83b9bbfbe822a7e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a21e8ff8b016048cb83b9bbfbe822a7e7">Node</a> (const std::string &amp;sName)</td></tr>
<tr class="separator:a21e8ff8b016048cb83b9bbfbe822a7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099cb0edca54481c58a99389d2f983bf"><td class="memItemLeft" align="right" valign="top"><a id="a099cb0edca54481c58a99389d2f983bf" name="a099cb0edca54481c58a99389d2f983bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (const <a class="el" href="classne_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:a099cb0edca54481c58a99389d2f983bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09610eec6599d25609c9c6c383ee49c0"><td class="memItemLeft" align="right" valign="top"><a id="a09610eec6599d25609c9c6c383ee49c0" name="a09610eec6599d25609c9c6c383ee49c0"></a>
<a class="el" href="classne_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:a09610eec6599d25609c9c6c383ee49c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab095a12cd5b7f615b096e7d3db219c1b"><td class="memItemLeft" align="right" valign="top"><a id="ab095a12cd5b7f615b096e7d3db219c1b" name="ab095a12cd5b7f615b096e7d3db219c1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (<a class="el" href="classne_1_1Node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab095a12cd5b7f615b096e7d3db219c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee6453dd5914d7250770af98e59a5eb"><td class="memItemLeft" align="right" valign="top"><a id="a3ee6453dd5914d7250770af98e59a5eb" name="a3ee6453dd5914d7250770af98e59a5eb"></a>
<a class="el" href="classne_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classne_1_1Node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3ee6453dd5914d7250770af98e59a5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79642d37ba8f7a42e6bbb43285f8b0fb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a79642d37ba8f7a42e6bbb43285f8b0fb">~Node</a> () override</td></tr>
<tr class="separator:a79642d37ba8f7a42e6bbb43285f8b0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75cedd320fd643ad154bdceb4b0aad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa75cedd320fd643ad154bdceb4b0aad1">setNodeName</a> (const std::string &amp;sName)</td></tr>
<tr class="separator:aa75cedd320fd643ad154bdceb4b0aad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e2afe27909c7d87d39c048999ab190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa4e2afe27909c7d87d39c048999ab190">detachFromParentAndDespawn</a> ()</td></tr>
<tr class="separator:aa4e2afe27909c7d87d39c048999ab190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a921f5e7fe4deb183e7910be557b1da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a3a921f5e7fe4deb183e7910be557b1da">addChildNode</a> (const sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &amp;pNode, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> locationRule=AttachmentRule::KEEP_WORLD, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> rotationRule=AttachmentRule::KEEP_WORLD, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> scaleRule=AttachmentRule::KEEP_WORLD)</td></tr>
<tr class="separator:a3a921f5e7fe4deb183e7910be557b1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cb324f9de9b495f7bc223356540a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ad8cb324f9de9b495f7bc223356540a44">setSerialize</a> (bool <a class="el" href="classne_1_1Node.html#a7fe9ac405df914997905a4de2045c12b">bSerialize</a>)</td></tr>
<tr class="separator:ad8cb324f9de9b495f7bc223356540a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9b140812be7a938906e36f6e6188b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a40e9b140812be7a938906e36f6e6188b">serializeNodeTree</a> (const std::filesystem::path &amp;pathToFile, bool bEnableBackup)</td></tr>
<tr class="separator:a40e9b140812be7a938906e36f6e6188b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3b419efa656af7bf82b3e85532ceed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aaf3b419efa656af7bf82b3e85532ceed">getNodeName</a> () const</td></tr>
<tr class="separator:aaf3b419efa656af7bf82b3e85532ceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470c2e53992a75304574a6c3c80a87d2"><td class="memItemLeft" align="right" valign="top">sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a470c2e53992a75304574a6c3c80a87d2">getWorldRootNode</a> ()</td></tr>
<tr class="separator:a470c2e53992a75304574a6c3c80a87d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561de14810416e06b506a6c970c296e7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a561de14810416e06b506a6c970c296e7">getParentNode</a> ()</td></tr>
<tr class="separator:a561de14810416e06b506a6c970c296e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874ddce54dfd82fcda801cb799bb1b85"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcVector&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a874ddce54dfd82fcda801cb799bb1b85">getChildNodes</a> ()</td></tr>
<tr class="separator:a874ddce54dfd82fcda801cb799bb1b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4ff3174738477037de125dff1a0707"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; <br />
requires std::derived_from&lt;NodeType, <a class="el" href="classne_1_1Node.html">Node</a>&gt;</td></tr>
<tr class="memitem:acc4ff3174738477037de125dff1a0707"><td class="memTemplItemLeft" align="right" valign="top">sgc::GcPtr&lt; NodeType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#acc4ff3174738477037de125dff1a0707">getParentNodeOfType</a> (const std::string &amp;sParentNodeName=&quot;&quot;)</td></tr>
<tr class="separator:acc4ff3174738477037de125dff1a0707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b03a7b88779e86fd7df6f158892c86b"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; <br />
requires std::derived_from&lt;NodeType, <a class="el" href="classne_1_1Node.html">Node</a>&gt;</td></tr>
<tr class="memitem:a7b03a7b88779e86fd7df6f158892c86b"><td class="memTemplItemLeft" align="right" valign="top">sgc::GcPtr&lt; NodeType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7b03a7b88779e86fd7df6f158892c86b">getChildNodeOfType</a> (const std::string &amp;sChildNodeName=&quot;&quot;)</td></tr>
<tr class="separator:a7b03a7b88779e86fd7df6f158892c86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5711513fe69f2771c6fc6bf84379768"><td class="memItemLeft" align="right" valign="top">TickGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ae5711513fe69f2771c6fc6bf84379768">getTickGroup</a> () const</td></tr>
<tr class="separator:ae5711513fe69f2771c6fc6bf84379768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbae38dafd4765e9026028bd004b31c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5cbae38dafd4765e9026028bd004b31c">getNodeId</a> () const</td></tr>
<tr class="separator:a5cbae38dafd4765e9026028bd004b31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0a06a7b62617e293529f2e0f89cd81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#afe0a06a7b62617e293529f2e0f89cd81">isCalledEveryFrame</a> ()</td></tr>
<tr class="separator:afe0a06a7b62617e293529f2e0f89cd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab524a575030ca4f5a505c800680bcbb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab524a575030ca4f5a505c800680bcbb8">isReceivingInput</a> ()</td></tr>
<tr class="separator:ab524a575030ca4f5a505c800680bcbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452b5f388d94b20c652ae661caca5fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab452b5f388d94b20c652ae661caca5fd">isSpawned</a> ()</td></tr>
<tr class="separator:ab452b5f388d94b20c652ae661caca5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f66ab4ad5300e502fe964e8717f642"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab4f66ab4ad5300e502fe964e8717f642">isParentOf</a> (<a class="el" href="classne_1_1Node.html">Node</a> *pNode)</td></tr>
<tr class="separator:ab4f66ab4ad5300e502fe964e8717f642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d48dcaa587589d0242d523d62bd9d27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7d48dcaa587589d0242d523d62bd9d27">isChildOf</a> (<a class="el" href="classne_1_1Node.html">Node</a> *pNode)</td></tr>
<tr class="separator:a7d48dcaa587589d0242d523d62bd9d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0a97f3a5893d137ef01aa155426706"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aca0a97f3a5893d137ef01aa155426706">isSerialized</a> () const</td></tr>
<tr class="separator:aca0a97f3a5893d137ef01aa155426706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a2b1c9ee24ea69f0b6231eff5a262e348 inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a2b1c9ee24ea69f0b6231eff5a262e348">serialize</a> (std::filesystem::path pathToFile, bool bEnableBackup, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={})</td></tr>
<tr class="separator:a2b1c9ee24ea69f0b6231eff5a262e348 inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a79714019d1b40ce8d063b920bbdcf inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af0a79714019d1b40ce8d063b920bbdcf">serialize</a> (toml::value &amp;tomlData, const std::string &amp;sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:af0a79714019d1b40ce8d063b920bbdcf inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99dd41bee3fdcea40c80bf317cc590d inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#aa99dd41bee3fdcea40c80bf317cc590d">serialize</a> (toml::value &amp;tomlData, <a class="el" href="classne_1_1Serializable.html">Serializable</a> *pOriginalObject, std::string sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:aa99dd41bee3fdcea40c80bf317cc590d inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0404cdf34dc3fb25b7932a87ed9ade38 inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a0404cdf34dc3fb25b7932a87ed9ade38">getPathDeserializedFromRelativeToRes</a> () const</td></tr>
<tr class="separator:a0404cdf34dc3fb25b7932a87ed9ade38 inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a881561ee518c6b936d7b973c89b26b62"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a881561ee518c6b936d7b973c89b26b62">getAliveNodeCount</a> ()</td></tr>
<tr class="separator:a881561ee518c6b936d7b973c89b26b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45ecbcfa73932f521f10154cd65e35"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7b45ecbcfa73932f521f10154cd65e35">deserializeNodeTree</a> (const std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:a7b45ecbcfa73932f521f10154cd65e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeb90fc6bd28ec3b54e9f8f641c3574"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a2aeb90fc6bd28ec3b54e9f8f641c3574">getGameInstance</a> ()</td></tr>
<tr class="separator:a2aeb90fc6bd28ec3b54e9f8f641c3574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a6cd50b9cef87748dede76ba3ef125e43 inherit pub_static_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::pair&lt; std::set&lt; std::string &gt;, toml::value &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a6cd50b9cef87748dede76ba3ef125e43">getIdsFromFile</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a6cd50b9cef87748dede76ba3ef125e43 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f76ea78f80fb43e5e481277a930b364 inherit pub_static_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a1f76ea78f80fb43e5e481277a930b364">serializeMultiple</a> (std::filesystem::path pathToFile, std::vector&lt; <a class="el" href="structne_1_1SerializableObjectInformation.html">SerializableObjectInformation</a> &gt; vObjects, bool bEnableBackup)</td></tr>
<tr class="separator:a1f76ea78f80fb43e5e481277a930b364 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a> (const std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a3162d0dbc003bfcef8c0ae0846b32f77">deserialize</a> (const std::filesystem::path &amp;pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes)</td></tr>
<tr class="separator:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a32a58a89522b5cca64db7b6750a73a19">deserialize</a> (std::filesystem::path pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#afb8e66a57cc108fca4d35ae40de8e22a">deserialize</a> (const std::filesystem::path &amp;pathToFile, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::same_as&lt;SmartPointer, sgc::GcPtr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; std::vector&lt; <a class="el" href="structne_1_1DeserializedObjectInformation.html">DeserializedObjectInformation</a>&lt; SmartPointer &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a5d16d519e3d326cbdc101e78ca1a2478">deserializeMultiple</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af67ef936c5d20e2f861430b48c69c95a">deserialize</a> (const toml::value &amp;tomlData, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, std::string sEntityId=&quot;&quot;, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={})</td></tr>
<tr class="separator:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9294c7c58a8b4f85b7674c55751f4b13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a9294c7c58a8b4f85b7674c55751f4b13">setIsCalledEveryFrame</a> (bool bEnable)</td></tr>
<tr class="separator:a9294c7c58a8b4f85b7674c55751f4b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138f69f892f8b80a89262b8a5f7625b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a138f69f892f8b80a89262b8a5f7625b8">setTickGroup</a> (TickGroup <a class="el" href="classne_1_1Node.html#aee673da17a5126031bbb957fa2833505">tickGroup</a>)</td></tr>
<tr class="separator:a138f69f892f8b80a89262b8a5f7625b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecdaaf48f89ae036a48ecb38d3ac382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> (bool bEnable)</td></tr>
<tr class="separator:a8ecdaaf48f89ae036a48ecb38d3ac382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e80560b3b2f02be42285e60195f1b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Timer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a0e80560b3b2f02be42285e60195f1b64">createTimer</a> (const std::string &amp;sTimerName)</td></tr>
<tr class="separator:a0e80560b3b2f02be42285e60195f1b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2dca870a640ac24053a76b804ce111"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType &gt; </td></tr>
<tr class="memitem:a5f2dca870a640ac24053a76b804ce111"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classne_1_1NodeNotificationBroadcaster.html">NodeNotificationBroadcaster</a>&lt; FunctionType &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5f2dca870a640ac24053a76b804ce111">createNotificationBroadcaster</a> ()</td></tr>
<tr class="separator:a5f2dca870a640ac24053a76b804ce111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77035ce347e8bf68b564b5358ef4b5cc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a77035ce347e8bf68b564b5358ef4b5cc">getActionEventBindings</a> ()</td></tr>
<tr class="separator:a77035ce347e8bf68b564b5358ef4b5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062c7be217334d4bce02ce34c32e00cb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a062c7be217334d4bce02ce34c32e00cb">getAxisEventBindings</a> ()</td></tr>
<tr class="separator:a062c7be217334d4bce02ce34c32e00cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893cf9d4987d1b3ece76c0ffa0577e6d"><td class="memItemLeft" align="right" valign="top">std::recursive_mutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a893cf9d4987d1b3ece76c0ffa0577e6d">getSpawnDespawnMutex</a> ()</td></tr>
<tr class="separator:a893cf9d4987d1b3ece76c0ffa0577e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5e6b60ec1e1fdf9d1b7d6cb8387b74"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5b5e6b60ec1e1fdf9d1b7d6cb8387b74">onMouseMove</a> (double xOffset, double yOffset)</td></tr>
<tr class="separator:a5b5e6b60ec1e1fdf9d1b7d6cb8387b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde53f1d8c88385fb8ba338820e77c8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#adde53f1d8c88385fb8ba338820e77c8e">onMouseScrollMove</a> (int iOffset)</td></tr>
<tr class="separator:adde53f1d8c88385fb8ba338820e77c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccde9ffedb8ce10cfb4cbdd8b6ea59a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> (float timeSincePrevFrameInSec)</td></tr>
<tr class="separator:a6ccde9ffedb8ce10cfb4cbdd8b6ea59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2310c20abcd99331c4d6b104e1e919"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#abe2310c20abcd99331c4d6b104e1e919">onSpawning</a> ()</td></tr>
<tr class="separator:abe2310c20abcd99331c4d6b104e1e919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cba5cd17e5e968ed92f162b5a9f08b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a79cba5cd17e5e968ed92f162b5a9f08b">onChildNodesSpawned</a> ()</td></tr>
<tr class="separator:a79cba5cd17e5e968ed92f162b5a9f08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890cf446e639ac9dd1e9e7832cf796ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a890cf446e639ac9dd1e9e7832cf796ed">onDespawning</a> ()</td></tr>
<tr class="separator:a890cf446e639ac9dd1e9e7832cf796ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e4a732c0e3578d8a5551693b8c02aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a53e4a732c0e3578d8a5551693b8c02aa">onBeforeDetachedFromParent</a> (bool bThisNodeBeingDetached)</td></tr>
<tr class="separator:a53e4a732c0e3578d8a5551693b8c02aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e67ce1bfe3c1015630301e3c53411f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab7e67ce1bfe3c1015630301e3c53411f">onAfterAttachedToNewParent</a> (bool bThisNodeBeingAttached)</td></tr>
<tr class="separator:ab7e67ce1bfe3c1015630301e3c53411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a00002d59e5d0dcda6e53c20b59947150 inherit pro_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a00002d59e5d0dcda6e53c20b59947150">onAfterDeserialized</a> ()</td></tr>
<tr class="separator:a00002d59e5d0dcda6e53c20b59947150 inherit pro_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a64f1ae678b1d2c5a02158346dc8a1219"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a64f1ae678b1d2c5a02158346dc8a1219">enableTimer</a> (<a class="el" href="classne_1_1Timer.html">Timer</a> *pTimer, bool bEnable)</td></tr>
<tr class="separator:a64f1ae678b1d2c5a02158346dc8a1219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3b44b31513e2898d2caf35ea63d4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a1f3b44b31513e2898d2caf35ea63d4e7">onInputActionEvent</a> (unsigned int iActionId, <a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, bool bIsPressedDown)</td></tr>
<tr class="separator:a1f3b44b31513e2898d2caf35ea63d4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48b63d44d51992c3c594b08d3e1c0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa48b63d44d51992c3c594b08d3e1c0a9">onInputAxisEvent</a> (unsigned int iAxisEventId, <a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, float input)</td></tr>
<tr class="separator:aa48b63d44d51992c3c594b08d3e1c0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0cdd65e3886dd5e069a099701f0124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a2d0cdd65e3886dd5e069a099701f0124">spawn</a> ()</td></tr>
<tr class="separator:a2d0cdd65e3886dd5e069a099701f0124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd6ddcf9906c8526b02aa7d1067776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ad9bd6ddcf9906c8526b02aa7d1067776">despawn</a> ()</td></tr>
<tr class="separator:ad9bd6ddcf9906c8526b02aa7d1067776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8472729af29f2e90d0a4ee334953e783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a8472729af29f2e90d0a4ee334953e783">notifyAboutAttachedToNewParent</a> (bool bThisNodeBeingAttached)</td></tr>
<tr class="separator:a8472729af29f2e90d0a4ee334953e783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9854b81a46b4c0063a0447a8a42dac0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a9854b81a46b4c0063a0447a8a42dac0c">notifyAboutDetachingFromParent</a> (bool bThisNodeBeingDetached)</td></tr>
<tr class="separator:a9854b81a46b4c0063a0447a8a42dac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff981780eeb406408afd037bb31f684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1World.html">World</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a1ff981780eeb406408afd037bb31f684">findValidWorld</a> ()</td></tr>
<tr class="separator:a1ff981780eeb406408afd037bb31f684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca87f422b087084a4561e46165022a96"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::vector&lt; <a class="el" href="structne_1_1Node_1_1SerializableObjectInformationWithGcPointer.html">SerializableObjectInformationWithGcPointer</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aca87f422b087084a4561e46165022a96">getInformationForSerialization</a> (size_t &amp;iId, std::optional&lt; size_t &gt; iParentId)</td></tr>
<tr class="separator:aca87f422b087084a4561e46165022a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42518527c8194051ae12f19603f6c32d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a42518527c8194051ae12f19603f6c32d">isTreeDeserializedFromOneFile</a> (const std::string &amp;sPathRelativeToRes)</td></tr>
<tr class="separator:a42518527c8194051ae12f19603f6c32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57649518a54e42668196d18741376397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a57649518a54e42668196d18741376397">lockChildren</a> ()</td></tr>
<tr class="separator:a57649518a54e42668196d18741376397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e575b462b1ef5aff5d2b63e03a1d43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a00e575b462b1ef5aff5d2b63e03a1d43">unlockChildren</a> ()</td></tr>
<tr class="separator:a00e575b462b1ef5aff5d2b63e03a1d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:abf5d0aa8bddaf3927e80dddb787fbe26"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#abf5d0aa8bddaf3927e80dddb787fbe26">sNodeName</a></td></tr>
<tr class="separator:abf5d0aa8bddaf3927e80dddb787fbe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d161e8751a61d6c23cca65bc22847d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcVector&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a39d161e8751a61d6c23cca65bc22847d">mtxChildNodes</a></td></tr>
<tr class="separator:a39d161e8751a61d6c23cca65bc22847d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272a651fe2aa6d290b6d6adbccf31bf3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a272a651fe2aa6d290b6d6adbccf31bf3">mtxParentNode</a></td></tr>
<tr class="separator:a272a651fe2aa6d290b6d6adbccf31bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531525f4d208ca0f45eb5492c3debb54"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a531525f4d208ca0f45eb5492c3debb54">mtxBindedActionEvents</a></td></tr>
<tr class="separator:a531525f4d208ca0f45eb5492c3debb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8913f0acc86e74780a053109f4ccee96"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a8913f0acc86e74780a053109f4ccee96">mtxBindedAxisEvents</a></td></tr>
<tr class="separator:a8913f0acc86e74780a053109f4ccee96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada864abad4d11488fd6652b6f6a6e77f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1Timer.html">Timer</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ada864abad4d11488fd6652b6f6a6e77f">mtxCreatedTimers</a></td></tr>
<tr class="separator:ada864abad4d11488fd6652b6f6a6e77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af274ceec79c97784089f06bd8a95dc34"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1NodeNotificationBroadcasterBase.html">NodeNotificationBroadcasterBase</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#af274ceec79c97784089f06bd8a95dc34">mtxCreatedBroadcasters</a></td></tr>
<tr class="separator:af274ceec79c97784089f06bd8a95dc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104dc3bb8409c8d592fdc320c776d9fc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a104dc3bb8409c8d592fdc320c776d9fc">mtxIsSpawned</a></td></tr>
<tr class="separator:a104dc3bb8409c8d592fdc320c776d9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa406867a33c8b3347df81e329c46b5b8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa406867a33c8b3347df81e329c46b5b8">mtxIsCalledEveryFrame</a></td></tr>
<tr class="separator:aa406867a33c8b3347df81e329c46b5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab250eceeeddc12965d14b29ad0f29ae7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab250eceeeddc12965d14b29ad0f29ae7">mtxIsReceivingInput</a></td></tr>
<tr class="separator:ab250eceeeddc12965d14b29ad0f29ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d87d6149dac42ad71c72959d287dce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1World.html">World</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7d87d6149dac42ad71c72959d287dce1">pWorld</a> = nullptr</td></tr>
<tr class="separator:a7d87d6149dac42ad71c72959d287dce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee673da17a5126031bbb957fa2833505"><td class="memItemLeft" align="right" valign="top">TickGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aee673da17a5126031bbb957fa2833505">tickGroup</a> = TickGroup::FIRST</td></tr>
<tr class="separator:aee673da17a5126031bbb957fa2833505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee3df89d264e4e9514bbf394098fe7e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aaee3df89d264e4e9514bbf394098fe7e">iNodeId</a></td></tr>
<tr class="separator:aaee3df89d264e4e9514bbf394098fe7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe9ac405df914997905a4de2045c12b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7fe9ac405df914997905a4de2045c12b">bSerialize</a> = true</td></tr>
<tr class="separator:a7fe9ac405df914997905a4de2045c12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aaab872e5e0cda5bd3e50b37096d46b3d"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aaab872e5e0cda5bd3e50b37096d46b3d">sParentNodeIdAttributeName</a> = &quot;parent_node_id&quot;</td></tr>
<tr class="separator:aaab872e5e0cda5bd3e50b37096d46b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2acbbe4c033a34bdc9dd4c76edebc32"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa2acbbe4c033a34bdc9dd4c76edebc32">sExternalNodeTreePathAttributeName</a></td></tr>
<tr class="separator:aa2acbbe4c033a34bdc9dd4c76edebc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a140a2a29511147897abbb772733f6c2c"><td class="memItemLeft" align="right" valign="top"><a id="a140a2a29511147897abbb772733f6c2c" name="a140a2a29511147897abbb772733f6c2c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GameManager</b></td></tr>
<tr class="separator:a140a2a29511147897abbb772733f6c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4bcdf992c21ae83363f25df05b1d25"><td class="memItemLeft" align="right" valign="top"><a id="a7b4bcdf992c21ae83363f25df05b1d25" name="a7b4bcdf992c21ae83363f25df05b1d25"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>World</b></td></tr>
<tr class="separator:a7b4bcdf992c21ae83363f25df05b1d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Base class for nodes, allows being spawned in the world, attaching child nodes or being attached to some parent node. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a14bad364fb30a60063a147b95ab17acc" name="a14bad364fb30a60063a147b95ab17acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bad364fb30a60063a147b95ab17acc">&#9670;&#160;</a></span>AttachmentRule</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">ne::Node::AttachmentRule</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Defines how location, rotation or scale of a node being attached as a child node should change after the attachment process (after <code>onAfterAttachedToNewParent</code> was called). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a869b03190702ccef1f85bad536bf1a4b" name="a869b03190702ccef1f85bad536bf1a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869b03190702ccef1f85bad536bf1a4b">&#9670;&#160;</a></span>Node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::Node::Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new node with a default name. </p>

</div>
</div>
<a id="a21e8ff8b016048cb83b9bbfbe822a7e7" name="a21e8ff8b016048cb83b9bbfbe822a7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e8ff8b016048cb83b9bbfbe822a7e7">&#9670;&#160;</a></span>Node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new node with the specified name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sName</td><td>Name of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79642d37ba8f7a42e6bbb43285f8b0fb" name="a79642d37ba8f7a42e6bbb43285f8b0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79642d37ba8f7a42e6bbb43285f8b0fb">&#9670;&#160;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ne::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Logs destruction in debug builds. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a921f5e7fe4deb183e7910be557b1da" name="a3a921f5e7fe4deb183e7910be557b1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a921f5e7fe4deb183e7910be557b1da">&#9670;&#160;</a></span>addChildNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::addChildNode </td>
          <td>(</td>
          <td class="paramtype">const sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a>&#160;</td>
          <td class="paramname"><em>locationRule</em> = <code>AttachmentRule::KEEP_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a>&#160;</td>
          <td class="paramname"><em>rotationRule</em> = <code>AttachmentRule::KEEP_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a>&#160;</td>
          <td class="paramname"><em>scaleRule</em> = <code>AttachmentRule::KEEP_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Attaches a node as a child of this node.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the specified node already has a parent it will change its parent to be a child of this node. This way you can change to which node you are attached.</dd>
<dd>
If the specified node needs to be spawned it will queue a deferred task to be added to the <a class="el" href="classne_1_1World.html">World</a> on next frame so input events and <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> (if enabled) will be called only starting from the next frame.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNode</td><td><a class="el" href="classne_1_1Node.html">Node</a> to attach as a child. If the specified node is a parent of <code>this</code> node the operation will fail and log an error. </td></tr>
    <tr><td class="paramname">locationRule</td><td>Only applied if the child node is a <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a>, otherwise ignored. Defines how child node's location should change after the attachment process (after <code>onAfterAttachedToNewParent</code> was called) </td></tr>
    <tr><td class="paramname">rotationRule</td><td>Only applied if the child node is a <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a>, otherwise ignored. Defines how child node's rotation should change after the attachment process (after <code>onAfterAttachedToNewParent</code> was called) </td></tr>
    <tr><td class="paramname">scaleRule</td><td>Only applied if the child node is a <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a>, otherwise ignored. Defines how child node's scale should change after the attachment process (after <code>onAfterAttachedToNewParent</code> was called) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f2dca870a640ac24053a76b804ce111" name="a5f2dca870a640ac24053a76b804ce111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2dca870a640ac24053a76b804ce111">&#9670;&#160;</a></span>createNotificationBroadcaster()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1NodeNotificationBroadcaster.html">NodeNotificationBroadcaster</a>&lt; FunctionType &gt; * ne::Node::createNotificationBroadcaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new notification broadcaster that only accepts callbacks of the specified type.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="comment">// inside of your Node derived class:</span></div>
<div class="line"><span class="keyword">auto</span> pBroadcaster = createNotificationBroadcaster&lt;void(bool)&gt;();</div>
<div class="line"><span class="comment">// save broadcaster pointer somewhere</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subscribe.</span></div>
<div class="line">pBroadcaster-&gt;subscribe(<a class="code hl_class" href="classne_1_1NodeFunction.html">NodeFunction</a>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">bool</span>)&gt;(<a class="code hl_function" href="classne_1_1Node.html#a5cbae38dafd4765e9026028bd004b31c">getNodeId</a>().value(), [](<span class="keywordtype">bool</span> bParameter){</div>
<div class="line">    <span class="comment">// callback logic ...</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Notify.</span></div>
<div class="line">pBroadcaster-&gt;broadcast(<span class="keyword">true</span>);</div>
<div class="ttc" id="aclassne_1_1NodeFunction_html"><div class="ttname"><a href="classne_1_1NodeFunction.html">ne::NodeFunction</a></div><div class="ttdef"><b>Definition:</b> NodeFunction.hpp:11</div></div>
<div class="ttc" id="aclassne_1_1Node_html_a5cbae38dafd4765e9026028bd004b31c"><div class="ttname"><a href="classne_1_1Node.html#a5cbae38dafd4765e9026028bd004b31c">ne::Node::getNodeId</a></div><div class="ttdeci">std::optional&lt; size_t &gt; getNodeId() const</div><div class="ttdef"><b>Definition:</b> Node.cpp:1003</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Do not free (delete) returned pointer. </dd>
<dd>
Do not use returned pointer outside of this node object as the broadcaster is only guaranteed to live while the node (that created the broadcaster) is living.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note that although you can create broadcasters while the node is despawned or was not spawned yet any attempt to broadcast the notification will be ignored and will do nothing.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A non-owning pointer to the created broadcaster that is guaranteed to be valid while this node object is alive (i.e. even valid when despawned). </dd></dl>

</div>
</div>
<a id="a0e80560b3b2f02be42285e60195f1b64" name="a0e80560b3b2f02be42285e60195f1b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e80560b3b2f02be42285e60195f1b64">&#9670;&#160;</a></span>createTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Timer.html">Timer</a> * ne::Node::createTimer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sTimerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new timer and saves it inside of this node to be used while the node is spawned.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not free (delete) returned pointer. </dd>
<dd>
Do not use returned pointer outside of this node object as the timer is only guaranteed to live while the node (that created the timer) is living.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note that although you can create timers while the node is despawned or was not spawned yet any attempt to start a timer while the node is despawned (or not spawned yet) will result in an error being logged. </dd>
<dd>
This function exists to add some protection code to not shoot yourself in the foot, such as: <a class="el" href="classne_1_1Node.html">Node</a> will automatically stop and disable created timers before <a class="el" href="classne_1_1Node.html#a890cf446e639ac9dd1e9e7832cf796ed">onDespawning</a> is called by using Timer::stop(true) so that you don't have to remember to stop created timers. Moreover, if you are using a callback function for the timer's timeout event it's guaranteed that this callback function will only be called while the node is spawned. </dd>
<dd>
There is no <code>removeTimer</code> function but it may appear in the future (although there's really no point in removing a timer so don't care about it).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTimerName</td><td>Name of this timer (used for logging). Don't add "timer" word to your timer's name as it will be appended in the logs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if something went wrong, otherwise a non-owning pointer to the created timer that is guaranteed to be valid while this node object is alive (i.e. even valid when despawned). </dd></dl>

</div>
</div>
<a id="a7b45ecbcfa73932f521f10154cd65e35" name="a7b45ecbcfa73932f521f10154cd65e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b45ecbcfa73932f521f10154cd65e35">&#9670;&#160;</a></span>deserializeNodeTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Node::deserializeNodeTree </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathToFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deserializes a node and all its child nodes (hierarchy information) from a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to read a node tree from. The ".toml" extension will be added automatically if not specified in the path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise pointer to the root node. </dd></dl>

</div>
</div>
<a id="ad9bd6ddcf9906c8526b02aa7d1067776" name="ad9bd6ddcf9906c8526b02aa7d1067776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bd6ddcf9906c8526b02aa7d1067776">&#9670;&#160;</a></span>despawn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::despawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Calls <a class="el" href="classne_1_1Node.html#a890cf446e639ac9dd1e9e7832cf796ed">onDespawning</a> on this node and all of its child nodes. </p>

</div>
</div>
<a id="aa4e2afe27909c7d87d39c048999ab190" name="aa4e2afe27909c7d87d39c048999ab190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e2afe27909c7d87d39c048999ab190">&#9670;&#160;</a></span>detachFromParentAndDespawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::detachFromParentAndDespawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Detaches this node from the parent and optionally despawns this node and all of its child nodes if the node was spawned.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is usually used to mark node (tree) as "to be destroyed", if you just want to change node's parent consider using <a class="el" href="classne_1_1Node.html#a3a921f5e7fe4deb183e7910be557b1da">addChildNode</a>.</dd>
<dd>
The node and its child nodes are not guaranteed to be deleted after this function is finished. Deletion is handled automatically by <code>gc</code> pointers. </dd></dl>

</div>
</div>
<a id="a64f1ae678b1d2c5a02158346dc8a1219" name="a64f1ae678b1d2c5a02158346dc8a1219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f1ae678b1d2c5a02158346dc8a1219">&#9670;&#160;</a></span>enableTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::enableTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Timer.html">Timer</a> *&#160;</td>
          <td class="paramname"><em>pTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enables the specified timer and sets a callback validator or stops and disables the timer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Does nothing if the timer is already in the requested state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTimer</td><td><a class="el" href="classne_1_1Timer.html">Timer</a> to enable/disable. </td></tr>
    <tr><td class="paramname">bEnable</td><td>New timer state to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if successful, <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a1ff981780eeb406408afd037bb31f684" name="a1ff981780eeb406408afd037bb31f684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff981780eeb406408afd037bb31f684">&#9670;&#160;</a></span>findValidWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1World.html">World</a> * ne::Node::findValidWorld </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Checks if this node has a valid world pointer and if not asks this node's parent and goes up the node hierarchy up to the root node if needed to find valid pointer to world.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1World.html">World</a>. </dd></dl>

</div>
</div>
<a id="a77035ce347e8bf68b564b5358ef4b5cc" name="a77035ce347e8bf68b564b5358ef4b5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77035ce347e8bf68b564b5358ef4b5cc">&#9670;&#160;</a></span>getActionEventBindings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt; * ne::Node::getActionEventBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns map of action events that this node is binded to (must be used with mutex). Binded callbacks will be automatically called when an action event is triggered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Input events will be only triggered if the node is spawned. </dd>
<dd>
Input events will not be called if <a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> was not enabled. </dd>
<dd>
Only events in <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>'s <a class="el" href="classne_1_1InputManager.html">InputManager</a> (<a class="el" href="classne_1_1GameInstance.html#a1914730da5993e3f18f15ce5ee6dbc4e">GameInstance::getInputManager</a>) will be considered to trigger events in the node.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> iForwardActionId = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pActionEvents = <a class="code hl_function" href="classne_1_1Node.html#a77035ce347e8bf68b564b5358ef4b5cc">getActionEventBindings</a>();</div>
<div class="line"> </div>
<div class="line">std::scoped_lock guard(pActionEvents-&gt;first);</div>
<div class="line">pActionEvents-&gt;second[iForwardActionId] = [&amp;](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">bool</span> bIsPressedDown) {</div>
<div class="line">    moveForward(modifiers, bIsPressedDown);</div>
<div class="line">};</div>
<div class="ttc" id="aclassne_1_1KeyboardModifiers_html"><div class="ttname"><a href="classne_1_1KeyboardModifiers.html">ne::KeyboardModifiers</a></div><div class="ttdef"><b>Definition:</b> KeyboardKey.hpp:10</div></div>
<div class="ttc" id="aclassne_1_1Node_html_a77035ce347e8bf68b564b5358ef4b5cc"><div class="ttname"><a href="classne_1_1Node.html#a77035ce347e8bf68b564b5358ef4b5cc">ne::Node::getActionEventBindings</a></div><div class="ttdeci">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(KeyboardModifiers, bool)&gt; &gt; &gt; * getActionEventBindings()</div><div class="ttdef"><b>Definition:</b> Node.cpp:910</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Binded action events. </dd></dl>

</div>
</div>
<a id="a881561ee518c6b936d7b973c89b26b62" name="a881561ee518c6b936d7b973c89b26b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881561ee518c6b936d7b973c89b26b62">&#9670;&#160;</a></span>getAliveNodeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::Node::getAliveNodeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the total amount of currently alive (allocated) nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of alive nodes right now. </dd></dl>

</div>
</div>
<a id="a062c7be217334d4bce02ce34c32e00cb" name="a062c7be217334d4bce02ce34c32e00cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062c7be217334d4bce02ce34c32e00cb">&#9670;&#160;</a></span>getAxisEventBindings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt; * ne::Node::getAxisEventBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns map of axis events that this node is binded to (must be used with mutex). Binded callbacks will be automatically called when an axis event is triggered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Input events will be only triggered if the node is spawned. </dd>
<dd>
Input events will not be called if <a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> was not enabled. </dd>
<dd>
Only events in <a class="el" href="classne_1_1GameInstance.html">GameInstance</a>'s <a class="el" href="classne_1_1InputManager.html">InputManager</a> (<a class="el" href="classne_1_1GameInstance.html#a1914730da5993e3f18f15ce5ee6dbc4e">GameInstance::getInputManager</a>) will be considered to trigger events in the node.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> iForwardAxisEventId = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pAxisEvents = <a class="code hl_function" href="classne_1_1Node.html#a062c7be217334d4bce02ce34c32e00cb">getAxisEventBindings</a>();</div>
<div class="line"> </div>
<div class="line">std::scoped_lock guard(pAxisEvents-&gt;first);</div>
<div class="line">pAxisEvents-&gt;second[iForwardAxisEventId] = [&amp;](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">float</span> input) {</div>
<div class="line">    moveForward(modifiers, input);</div>
<div class="line">};</div>
<div class="ttc" id="aclassne_1_1Node_html_a062c7be217334d4bce02ce34c32e00cb"><div class="ttname"><a href="classne_1_1Node.html#a062c7be217334d4bce02ce34c32e00cb">ne::Node::getAxisEventBindings</a></div><div class="ttdeci">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(KeyboardModifiers, float)&gt; &gt; &gt; * getAxisEventBindings()</div><div class="ttdef"><b>Definition:</b> Node.cpp:917</div></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Input parameter is a value in range [-1.0f; 1.0f] that describes input.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Binded action events. </dd></dl>

</div>
</div>
<a id="a7b03a7b88779e86fd7df6f158892c86b" name="a7b03a7b88779e86fd7df6f158892c86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b03a7b88779e86fd7df6f158892c86b">&#9670;&#160;</a></span>getChildNodeOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType &gt; <br />
requires std::derived_from&lt;NodeType, <a class="el" href="classne_1_1Node.html">Node</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">sgc::GcPtr&lt; NodeType &gt; ne::Node::getChildNodeOfType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sChildNodeName</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Goes down the child node chain to find a first node that matches the specified node type and optionally node name.</p>
<p >Template parameter NodeType specifies node type to look for. Note that this means that we will use dynamic_cast to determine whether the node matches the specified type or not. So if you are looking for a node with the type <code><a class="el" href="classne_1_1Node.html">Node</a></code> this means that every node will match the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sChildNodeName</td><td>If not empty, nodes that match the specified node type will also be checked to see if their name exactly matches the specified name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if not found, otherwise a valid pointer to the node. </dd></dl>

</div>
</div>
<a id="a874ddce54dfd82fcda801cb799bb1b85" name="a874ddce54dfd82fcda801cb799bb1b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874ddce54dfd82fcda801cb799bb1b85">&#9670;&#160;</a></span>getChildNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, sgc::GcVector&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; &gt; * ne::Node::getChildNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns pointer to child nodes array.</p>
<dl class="section warning"><dt>Warning</dt><dd>Must be used with mutex.</dd>
<dd>
Avoid saving returned raw pointer as it points to the node's field and does not guarantee that the node will always live while you hold this pointer. Returning raw pointer in order to avoid creating GC pointers (if you for example only want to iterate over child nodes there's no point in returning GC vector), but you can always save returned GC vector or GC pointers to child nodes if you need.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Array of child nodes. </dd></dl>

</div>
</div>
<a id="a2aeb90fc6bd28ec3b54e9f8f641c3574" name="a2aeb90fc6bd28ec3b54e9f8f641c3574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeb90fc6bd28ec3b54e9f8f641c3574">&#9670;&#160;</a></span>getGameInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1GameInstance.html">GameInstance</a> * ne::Node::getGameInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns last created game instance.</p>
<dl class="section return"><dt>Returns</dt><dd>Game instance. </dd></dl>

</div>
</div>
<a id="aca87f422b087084a4561e46165022a96" name="aca87f422b087084a4561e46165022a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca87f422b087084a4561e46165022a96">&#9670;&#160;</a></span>getInformationForSerialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::vector&lt; <a class="el" href="structne_1_1Node_1_1SerializableObjectInformationWithGcPointer.html">Node::SerializableObjectInformationWithGcPointer</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Node::getInformationForSerialization </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>iId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>iParentId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Collects and returns information for serialization for self and all child nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iId</td><td>ID for serialization to use (will be incremented). </td></tr>
    <tr><td class="paramname">iParentId</td><td>Parent's serialization ID (if this node has a parent and it will also be serialized).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise an array of collected information that can be serialized. </dd></dl>

</div>
</div>
<a id="a5cbae38dafd4765e9026028bd004b31c" name="a5cbae38dafd4765e9026028bd004b31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbae38dafd4765e9026028bd004b31c">&#9670;&#160;</a></span>getNodeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; size_t &gt; ne::Node::getNodeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a unique ID of the node.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Each spawn gives the node a new ID.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Empty if this node was never spawned, otherwise unique ID of this node. </dd></dl>

</div>
</div>
<a id="aaf3b419efa656af7bf82b3e85532ceed" name="aaf3b419efa656af7bf82b3e85532ceed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3b419efa656af7bf82b3e85532ceed">&#9670;&#160;</a></span>getNodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Node::getNodeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's name.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Node.html">Node</a> name. </dd></dl>

</div>
</div>
<a id="a561de14810416e06b506a6c970c296e7" name="a561de14810416e06b506a6c970c296e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561de14810416e06b506a6c970c296e7">&#9670;&#160;</a></span>getParentNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; * ne::Node::getParentNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns parent node if this node.</p>
<dl class="section warning"><dt>Warning</dt><dd>Must be used with mutex.</dd>
<dd>
Avoid saving returned raw pointer as it points to the node's field and does not guarantee that the node will always live while you hold this pointer. Returning raw pointer in order to avoid creating GC pointers (if you for example only want to check the parent node there's no point in returning a gc pointer), but you can always save returned GC pointer to node's parent if you need.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> as a gc pointer (second value in the pair) if this node has no parent (could only happen when the node is not spawned), otherwise valid gc pointer. </dd></dl>

</div>
</div>
<a id="acc4ff3174738477037de125dff1a0707" name="acc4ff3174738477037de125dff1a0707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4ff3174738477037de125dff1a0707">&#9670;&#160;</a></span>getParentNodeOfType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType &gt; <br />
requires std::derived_from&lt;NodeType, <a class="el" href="classne_1_1Node.html">Node</a>&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">sgc::GcPtr&lt; NodeType &gt; ne::Node::getParentNodeOfType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sParentNodeName</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Goes up the parent node chain (up to the world's root node if needed) to find a first node that matches the specified node type and optionally node name.</p>
<p >Template parameter NodeType specifies node type to look for. Note that this means that we will use dynamic_cast to determine whether the node matches the specified type or not. So if you are looking for a node with the type <code><a class="el" href="classne_1_1Node.html">Node</a></code> this means that every node will match the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sParentNodeName</td><td>If not empty, nodes that match the specified node type will also be checked to see if their name exactly matches the specified name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if not found, otherwise a valid pointer to the node. </dd></dl>

</div>
</div>
<a id="a893cf9d4987d1b3ece76c0ffa0577e6d" name="a893cf9d4987d1b3ece76c0ffa0577e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893cf9d4987d1b3ece76c0ffa0577e6d">&#9670;&#160;</a></span>getSpawnDespawnMutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::recursive_mutex * ne::Node::getSpawnDespawnMutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns mutex that is generally used to protect/prevent spawning/despawning.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Do not delete (free) returned pointer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Mutex. </dd></dl>

</div>
</div>
<a id="ae5711513fe69f2771c6fc6bf84379768" name="ae5711513fe69f2771c6fc6bf84379768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5711513fe69f2771c6fc6bf84379768">&#9670;&#160;</a></span>getTickGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TickGroup ne::Node::getTickGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the tick group this node resides in.</p>
<dl class="section return"><dt>Returns</dt><dd>Tick group the node is using. </dd></dl>

</div>
</div>
<a id="a470c2e53992a75304574a6c3c80a87d2" name="a470c2e53992a75304574a6c3c80a87d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470c2e53992a75304574a6c3c80a87d2">&#9670;&#160;</a></span>getWorldRootNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; ne::Node::getWorldRootNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns world's root node.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if this node is not spawned or was despawned or world is being destroyed (always check returned pointer before doing something), otherwise valid pointer. </dd></dl>

</div>
</div>
<a id="afe0a06a7b62617e293529f2e0f89cd81" name="afe0a06a7b62617e293529f2e0f89cd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0a06a7b62617e293529f2e0f89cd81">&#9670;&#160;</a></span>isCalledEveryFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::isCalledEveryFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns whether the <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> should be called each frame or not.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether the <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> should be called each frame or not. </dd></dl>

</div>
</div>
<a id="a7d48dcaa587589d0242d523d62bd9d27" name="a7d48dcaa587589d0242d523d62bd9d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d48dcaa587589d0242d523d62bd9d27">&#9670;&#160;</a></span>isChildOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::isChildOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the specified node is a parent of this node (somewhere in the parent hierarchy, not only as a direct parent node).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNode</td><td><a class="el" href="classne_1_1Node.html">Node</a> to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified node was found as a parent of this node, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab4f66ab4ad5300e502fe964e8717f642" name="ab4f66ab4ad5300e502fe964e8717f642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f66ab4ad5300e502fe964e8717f642">&#9670;&#160;</a></span>isParentOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::isParentOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the specified node is a child of this node (somewhere in the child hierarchy, not only as a direct child node).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNode</td><td><a class="el" href="classne_1_1Node.html">Node</a> to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the specified node was found as a child of this node, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab524a575030ca4f5a505c800680bcbb8" name="ab524a575030ca4f5a505c800680bcbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab524a575030ca4f5a505c800680bcbb8">&#9670;&#160;</a></span>isReceivingInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::isReceivingInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns whether this node receives input or not.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether this node receives input or not. </dd></dl>

</div>
</div>
<a id="aca0a97f3a5893d137ef01aa155426706" name="aca0a97f3a5893d137ef01aa155426706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0a97f3a5893d137ef01aa155426706">&#9670;&#160;</a></span>isSerialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::isSerialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tells whether or not this node (and node's child nodes) will be serialized as part of a node tree.</p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if this node and its child nodes will be ignored when being serialized as part of a node tree, <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab452b5f388d94b20c652ae661caca5fd" name="ab452b5f388d94b20c652ae661caca5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab452b5f388d94b20c652ae661caca5fd">&#9670;&#160;</a></span>isSpawned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::isSpawned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns whether this node is spawned in the world or not.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether this node is spawned in the world or not. </dd></dl>

</div>
</div>
<a id="a42518527c8194051ae12f19603f6c32d" name="a42518527c8194051ae12f19603f6c32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42518527c8194051ae12f19603f6c32d">&#9670;&#160;</a></span>isTreeDeserializedFromOneFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::isTreeDeserializedFromOneFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sPathRelativeToRes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Checks if this node and all child nodes were deserialized from the same file (i.e. checks if this node tree is located in one file).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sPathRelativeToRes</td><td>Path relative to the <code>res</code> directory to the file to check, example: <code>game/test.toml</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if this node or some child node(s) were deserialized from other file or if some nodes we not deserialized previously, otherwise <code>true</code>. </dd></dl>

</div>
</div>
<a id="a57649518a54e42668196d18741376397" name="a57649518a54e42668196d18741376397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57649518a54e42668196d18741376397">&#9670;&#160;</a></span>lockChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::lockChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Locks <a class="el" href="classne_1_1Node.html#a39d161e8751a61d6c23cca65bc22847d">mtxChildNodes</a> mutex for self and recursively for all children.</p>
<p >After a node with children was locked this makes the whole node tree to be frozen (hierarchy can't be changed).</p>
<p >Use <a class="el" href="classne_1_1Node.html#a00e575b462b1ef5aff5d2b63e03a1d43">unlockChildren</a> for unlocking the tree. </p>

</div>
</div>
<a id="a8472729af29f2e90d0a4ee334953e783" name="a8472729af29f2e90d0a4ee334953e783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8472729af29f2e90d0a4ee334953e783">&#9670;&#160;</a></span>notifyAboutAttachedToNewParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::notifyAboutAttachedToNewParent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bThisNodeBeingAttached</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Calls <a class="el" href="classne_1_1Node.html#ab7e67ce1bfe3c1015630301e3c53411f">onAfterAttachedToNewParent</a> on this node and all of its child nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bThisNodeBeingAttached</td><td><code>true</code> if this node was attached to a parent, <code>false</code> if some node in the parent hierarchy was attached to a parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9854b81a46b4c0063a0447a8a42dac0c" name="a9854b81a46b4c0063a0447a8a42dac0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9854b81a46b4c0063a0447a8a42dac0c">&#9670;&#160;</a></span>notifyAboutDetachingFromParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::notifyAboutDetachingFromParent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bThisNodeBeingDetached</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Calls <a class="el" href="classne_1_1Node.html#a53e4a732c0e3578d8a5551693b8c02aa">onBeforeDetachedFromParent</a> on this node and all of its child nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bThisNodeBeingDetached</td><td><code>true</code> if this node is being detached from its parent, <code>false</code> if some node in the parent hierarchy is being detached from its parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7e67ce1bfe3c1015630301e3c53411f" name="ab7e67ce1bfe3c1015630301e3c53411f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e67ce1bfe3c1015630301e3c53411f">&#9670;&#160;</a></span>onAfterAttachedToNewParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Node::onAfterAttachedToNewParent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bThisNodeBeingAttached</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after this node or one of the node's parents (in the parent hierarchy) was attached to a new parent node.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function will also be called on all child nodes after this function is finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bThisNodeBeingAttached</td><td><code>true</code> if this node was attached to a parent, <code>false</code> if some node in the parent hierarchy was attached to a parent. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classne_1_1EditorCameraNode.html#a08e4e5ace5a7e1f0c9267a3482f7f4ca">ne::EditorCameraNode</a>, and <a class="el" href="classne_1_1SpatialNode.html#ae883c06ca2bc4bd917de5486cbbda0d4">ne::SpatialNode</a>.</p>

</div>
</div>
<a id="a53e4a732c0e3578d8a5551693b8c02aa" name="a53e4a732c0e3578d8a5551693b8c02aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e4a732c0e3578d8a5551693b8c02aa">&#9670;&#160;</a></span>onBeforeDetachedFromParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Node::onBeforeDetachedFromParent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bThisNodeBeingDetached</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called before this node or one of the node's parents (in the parent hierarchy) is about to be detached from the current parent node.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If this node is being detached from its parent <a class="el" href="classne_1_1Node.html#a561de14810416e06b506a6c970c296e7">getParentNode</a> will return <code>nullptr</code> after this function is finished.</dd>
<dd>
This function will also be called on all child nodes after this function is finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bThisNodeBeingDetached</td><td><code>true</code> if this node is being detached from its parent, <code>false</code> if some node in the parent hierarchy is being detached from its parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ccde9ffedb8ce10cfb4cbdd8b6ea59a" name="a6ccde9ffedb8ce10cfb4cbdd8b6ea59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">&#9670;&#160;</a></span>onBeforeNewFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Node::onBeforeNewFrame </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timeSincePrevFrameInSec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called before a new frame is rendered.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is disabled by default, use <a class="el" href="classne_1_1Node.html#a9294c7c58a8b4f85b7674c55751f4b13">setIsCalledEveryFrame</a> to enable it. </dd>
<dd>
This function will only be called while this node is spawned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic (if there is any).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeSincePrevFrameInSec</td><td>Also known as deltatime - time in seconds that has passed since the last frame was rendered. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classne_1_1EditorCameraNode.html#a32c682de69a47481aa8429f56a58f07c">ne::EditorCameraNode</a>.</p>

</div>
</div>
<a id="a79cba5cd17e5e968ed92f162b5a9f08b" name="a79cba5cd17e5e968ed92f162b5a9f08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cba5cd17e5e968ed92f162b5a9f08b">&#9670;&#160;</a></span>onChildNodesSpawned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Node::onChildNodesSpawned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after <a class="el" href="classne_1_1Node.html#abe2310c20abcd99331c4d6b104e1e919">onSpawning</a> when this node and all of node's child nodes (at the moment of spawning) were spawned.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Generally you might want to prefer to use <a class="el" href="classne_1_1Node.html#abe2310c20abcd99331c4d6b104e1e919">onSpawning</a>, this function is mostly used to do some logic related to child nodes after all child nodes were spawned (for example if you have a camera child node you can make it active in this function).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

</div>
</div>
<a id="a890cf446e639ac9dd1e9e7832cf796ed" name="a890cf446e639ac9dd1e9e7832cf796ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890cf446e639ac9dd1e9e7832cf796ed">&#9670;&#160;</a></span>onDespawning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Node::onDespawning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called before this node is despawned from the world to execute custom despawn logic.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This node will be marked as despawned after this function is called. </dd>
<dd>
This function is called after all child nodes were despawned.</dd>
<dd>
<a class="el" href="classne_1_1Node.html#a893cf9d4987d1b3ece76c0ffa0577e6d">getSpawnDespawnMutex</a> is locked while this function is called.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented in <a class="el" href="classne_1_1CameraNode.html#a163b51874818ad22d1e4bcc83774a78f">ne::CameraNode</a>, <a class="el" href="classne_1_1EnvironmentNode.html#adbe7bebff6387c0bdca1b8b18af811db">ne::EnvironmentNode</a>, <a class="el" href="classne_1_1DirectionalLightNode.html#a8ecbc829b192d1caf811746b58b8a475">ne::DirectionalLightNode</a>, <a class="el" href="classne_1_1PointLightNode.html#a3a3653f472765d4594939d8c3796aa73">ne::PointLightNode</a>, <a class="el" href="classne_1_1SpotlightNode.html#a8f09cc94a4a701d7f9771e0cddddeebe">ne::SpotlightNode</a>, and <a class="el" href="classne_1_1MeshNode.html#a53861da301908fac9900bd11073b745f">ne::MeshNode</a>.</p>

</div>
</div>
<a id="a1f3b44b31513e2898d2caf35ea63d4e7" name="a1f3b44b31513e2898d2caf35ea63d4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3b44b31513e2898d2caf35ea63d4e7">&#9670;&#160;</a></span>onInputActionEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::onInputActionEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iActionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsPressedDown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when a window that owns this game instance receives user input and the input key exists as an action event in the <a class="el" href="classne_1_1InputManager.html">InputManager</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function will not be called if <a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> was not enabled. </dd>
<dd>
This function will only be called while this node is spawned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iActionId</td><td>Unique ID of the input action event (from input manager). </td></tr>
    <tr><td class="paramname">modifiers</td><td>Keyboard modifier keys. </td></tr>
    <tr><td class="paramname">bIsPressedDown</td><td>Whether the key down event occurred or key up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa48b63d44d51992c3c594b08d3e1c0a9" name="aa48b63d44d51992c3c594b08d3e1c0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48b63d44d51992c3c594b08d3e1c0a9">&#9670;&#160;</a></span>onInputAxisEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::onInputAxisEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iAxisEventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>&#160;</td>
          <td class="paramname"><em>modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when a window that owns this game instance receives user input and the input key exists as an axis event in the <a class="el" href="classne_1_1InputManager.html">InputManager</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function will not be called if <a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> was not enabled. </dd>
<dd>
This function will only be called while this node is spawned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iAxisEventId</td><td>Unique ID of the input axis event (from input manager). </td></tr>
    <tr><td class="paramname">modifiers</td><td>Keyboard modifier keys. </td></tr>
    <tr><td class="paramname">input</td><td>A value in range [-1.0f; 1.0f] that describes input. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b5e6b60ec1e1fdf9d1b7d6cb8387b74" name="a5b5e6b60ec1e1fdf9d1b7d6cb8387b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5e6b60ec1e1fdf9d1b7d6cb8387b74">&#9670;&#160;</a></span>onMouseMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Node::onMouseMove </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the window received mouse movement.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function will not be called if <a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> was not enabled. </dd>
<dd>
This function will only be called while this node is spawned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xOffset</td><td>Mouse X movement delta in pixels (plus if moved to the right, minus if moved to the left). </td></tr>
    <tr><td class="paramname">yOffset</td><td>Mouse Y movement delta in pixels (plus if moved up, minus if moved down). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classne_1_1EditorCameraNode.html#acdb9469dbdb548e0e91712f1d93454ec">ne::EditorCameraNode</a>.</p>

</div>
</div>
<a id="adde53f1d8c88385fb8ba338820e77c8e" name="adde53f1d8c88385fb8ba338820e77c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde53f1d8c88385fb8ba338820e77c8e">&#9670;&#160;</a></span>onMouseScrollMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Node::onMouseScrollMove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iOffset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the window receives mouse scroll movement.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function will not be called if <a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> was not enabled. </dd>
<dd>
This function will only be called while this node is spawned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iOffset</td><td>Movement offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe2310c20abcd99331c4d6b104e1e919" name="abe2310c20abcd99331c4d6b104e1e919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2310c20abcd99331c4d6b104e1e919">&#9670;&#160;</a></span>onSpawning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Node::onSpawning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when this node was not spawned previously and it was either attached to a parent node that is spawned or set as world's root node to execute custom spawn logic.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This node will be marked as spawned before this function is called.</dd>
<dd>
<a class="el" href="classne_1_1Node.html#a893cf9d4987d1b3ece76c0ffa0577e6d">getSpawnDespawnMutex</a> is locked while this function is called.</dd>
<dd>
This function is called before any of the child nodes are spawned. If you need to do some logic after child nodes are spawned use <a class="el" href="classne_1_1Node.html#a79cba5cd17e5e968ed92f162b5a9f08b">onChildNodesSpawned</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented in <a class="el" href="classne_1_1EnvironmentNode.html#a095bb987abc897af274a2e9627fadfac">ne::EnvironmentNode</a>, <a class="el" href="classne_1_1DirectionalLightNode.html#a87cfb909061175db5c5ec9a0fc9ef899">ne::DirectionalLightNode</a>, <a class="el" href="classne_1_1PointLightNode.html#afd427bdca3170f84fe6d924e9ba9cde4">ne::PointLightNode</a>, <a class="el" href="classne_1_1SpotlightNode.html#ab2281ef335d11edcd87971e8ed3d92c1">ne::SpotlightNode</a>, <a class="el" href="classne_1_1MeshNode.html#a7127ccc4f7cc62ab5f74583920ee93ee">ne::MeshNode</a>, and <a class="el" href="classne_1_1SpatialNode.html#a3af79f3d46f46b70636d67b70dab12d2">ne::SpatialNode</a>.</p>

</div>
</div>
<a id="a40e9b140812be7a938906e36f6e6188b" name="a40e9b140812be7a938906e36f6e6188b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e9b140812be7a938906e36f6e6188b">&#9670;&#160;</a></span>serializeNodeTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Node::serializeNodeTree </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathToFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableBackup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Serializes the node and all child nodes (hierarchy information will also be saved) into a file. <a class="el" href="classne_1_1Node.html">Node</a> tree can later be deserialized using <a class="el" href="classne_1_1Node.html#a7b45ecbcfa73932f521f10154cd65e35">deserializeNodeTree</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to write the node tree to. The ".toml" extension will be added automatically if not specified in the path. If the specified file already exists it will be overwritten. </td></tr>
    <tr><td class="paramname">bEnableBackup</td><td>If 'true' will also use a backup (copy) file. <a class="el" href="classne_1_1Node.html#a7b45ecbcfa73932f521f10154cd65e35">deserializeNodeTree</a> can use backup file if the original file does not exist. Generally you want to use a backup file if you are saving important information, such as player progress, other cases such as player game settings and etc. usually do not need a backup but you can use it if you want.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Custom attributes, like in <a class="el" href="classne_1_1Serializable.html#a2b1c9ee24ea69f0b6231eff5a262e348">Serializable::serialize</a>, are not available here because they are used internally to store hierarchy and other information.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, for example when found an unsupported for serialization reflected field. </dd></dl>

</div>
</div>
<a id="a9294c7c58a8b4f85b7674c55751f4b13" name="a9294c7c58a8b4f85b7674c55751f4b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9294c7c58a8b4f85b7674c55751f4b13">&#9670;&#160;</a></span>setIsCalledEveryFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::setIsCalledEveryFrame </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Determines if the <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> should be called each frame or not (disabled by default).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Safe to call any time (while spawned/despawned).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td><code>true</code> to enable <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a>, <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ecdaaf48f89ae036a48ecb38d3ac382" name="a8ecdaaf48f89ae036a48ecb38d3ac382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecdaaf48f89ae036a48ecb38d3ac382">&#9670;&#160;</a></span>setIsReceivingInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::setIsReceivingInput </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Determines if the input related functions, such as <a class="el" href="classne_1_1Node.html#a5b5e6b60ec1e1fdf9d1b7d6cb8387b74">onMouseMove</a>, <a class="el" href="classne_1_1Node.html#adde53f1d8c88385fb8ba338820e77c8e">onMouseScrollMove</a>, <a class="el" href="classne_1_1Node.html#a1f3b44b31513e2898d2caf35ea63d4e7">onInputActionEvent</a> and <a class="el" href="classne_1_1Node.html#aa48b63d44d51992c3c594b08d3e1c0a9">onInputAxisEvent</a> will be called or not.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Typically you should call this function in your node's constructor to determine if this node should receive input or not. </dd>
<dd>
Nodes do not receive input by default. </dd>
<dd>
Safe to call any time (while spawned/despawned).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>Whether the input function should be enabled or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa75cedd320fd643ad154bdceb4b0aad1" name="aa75cedd320fd643ad154bdceb4b0aad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75cedd320fd643ad154bdceb4b0aad1">&#9670;&#160;</a></span>setNodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::setNodeName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets node's name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sName</td><td>New name of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8cb324f9de9b495f7bc223356540a44" name="ad8cb324f9de9b495f7bc223356540a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cb324f9de9b495f7bc223356540a44">&#9670;&#160;</a></span>setSerialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::setSerialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSerialize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets if this node (and node's child nodes) should be serialized as part of a node tree or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bSerialize</td><td><code>true</code> to serialize, <code>false</code> ignore when serializing as part of a node tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a138f69f892f8b80a89262b8a5f7625b8" name="a138f69f892f8b80a89262b8a5f7625b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138f69f892f8b80a89262b8a5f7625b8">&#9670;&#160;</a></span>setTickGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::setTickGroup </td>
          <td>(</td>
          <td class="paramtype">TickGroup&#160;</td>
          <td class="paramname"><em>tickGroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the tick group in which the node will reside.</p>
<p >Tick groups determine the order in which the <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> functions will be called on nodes. Each frame, <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> will be called first on the nodes that use the first tick group, then on the nodes that use the second group and etc. This allows defining a special order in which <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> functions will be called on nodes, thus if you want some nodes to execute their <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> function only after some other nodes do so, you can define this with tick groups.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Tick group is ignored if <a class="el" href="classne_1_1Node.html#a9294c7c58a8b4f85b7674c55751f4b13">setIsCalledEveryFrame</a> was not enabled. </dd>
<dd>
Typically you should call this function in your node's constructor to determine in which tick group the node will reside. </dd>
<dd>
Nodes use the first tick group by default.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling this function while the node is spawned will cause an error to be shown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tickGroup</td><td>Tick group the node will reside in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d0cdd65e3886dd5e069a099701f0124" name="a2d0cdd65e3886dd5e069a099701f0124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0cdd65e3886dd5e069a099701f0124">&#9670;&#160;</a></span>spawn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::spawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Calls <a class="el" href="classne_1_1Node.html#abe2310c20abcd99331c4d6b104e1e919">onSpawning</a> on this node and all of its child nodes. </p>

</div>
</div>
<a id="a00e575b462b1ef5aff5d2b63e03a1d43" name="a00e575b462b1ef5aff5d2b63e03a1d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e575b462b1ef5aff5d2b63e03a1d43">&#9670;&#160;</a></span>unlockChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::Node::unlockChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Unlocks <a class="el" href="classne_1_1Node.html#a39d161e8751a61d6c23cca65bc22847d">mtxChildNodes</a> mutex for self and recursively for all children.</p>
<p >After a node with children was unlocked this makes the whole node tree to be unfrozen (hierarchy can be changed as usual). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7fe9ac405df914997905a4de2045c12b" name="a7fe9ac405df914997905a4de2045c12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe9ac405df914997905a4de2045c12b">&#9670;&#160;</a></span>bSerialize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::Node::bSerialize = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Defines whether or not this node (and node's child nodes) should be serialized as part of a node tree. </p>

</div>
</div>
<a id="aaee3df89d264e4e9514bbf394098fe7e" name="aaee3df89d264e4e9514bbf394098fe7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee3df89d264e4e9514bbf394098fe7e">&#9670;&#160;</a></span>iNodeId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;size_t&gt; ne::Node::iNodeId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Unique ID of the spawned node (initialized after the node is spawned). </p>

</div>
</div>
<a id="a531525f4d208ca0f45eb5492c3debb54" name="a531525f4d208ca0f45eb5492c3debb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531525f4d208ca0f45eb5492c3debb54">&#9670;&#160;</a></span>mtxBindedActionEvents</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, std::unordered_map&lt;unsigned int, std::function&lt;void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt; ne::Node::mtxBindedActionEvents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Map of action events that this node is binded to. Must be used with mutex. </p>

</div>
</div>
<a id="a8913f0acc86e74780a053109f4ccee96" name="a8913f0acc86e74780a053109f4ccee96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8913f0acc86e74780a053109f4ccee96">&#9670;&#160;</a></span>mtxBindedAxisEvents</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, std::unordered_map&lt;unsigned int, std::function&lt;void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt; ne::Node::mtxBindedAxisEvents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Map of axis events that this node is binded to. Must be used with mutex. </p>

</div>
</div>
<a id="a39d161e8751a61d6c23cca65bc22847d" name="a39d161e8751a61d6c23cca65bc22847d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d161e8751a61d6c23cca65bc22847d">&#9670;&#160;</a></span>mtxChildNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, sgc::GcVector&lt;sgc::GcPtr&lt;<a class="el" href="classne_1_1Node.html">Node</a>&gt; &gt; &gt; ne::Node::mtxChildNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attached child nodes. Should be used under the mutex when changing children. </p>

</div>
</div>
<a id="af274ceec79c97784089f06bd8a95dc34" name="af274ceec79c97784089f06bd8a95dc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af274ceec79c97784089f06bd8a95dc34">&#9670;&#160;</a></span>mtxCreatedBroadcasters</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, std::vector&lt;std::unique_ptr&lt;<a class="el" href="classne_1_1NodeNotificationBroadcasterBase.html">NodeNotificationBroadcasterBase</a>&gt; &gt; &gt; ne::Node::mtxCreatedBroadcasters</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Notification broadcasters created using <a class="el" href="classne_1_1Node.html#a5f2dca870a640ac24053a76b804ce111">createNotificationBroadcaster</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Don't remove/erase broadcasters from this array because it's allowed to use broadcasters while the node is despawned. Additionally, all users hold raw pointers to broadcasters so they will hit deleted memory in the case of deletion. </dd></dl>

</div>
</div>
<a id="ada864abad4d11488fd6652b6f6a6e77f" name="ada864abad4d11488fd6652b6f6a6e77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada864abad4d11488fd6652b6f6a6e77f">&#9670;&#160;</a></span>mtxCreatedTimers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, std::vector&lt;std::unique_ptr&lt;<a class="el" href="classne_1_1Timer.html">Timer</a>&gt; &gt; &gt; ne::Node::mtxCreatedTimers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Timers creates using <a class="el" href="classne_1_1Node.html#a0e80560b3b2f02be42285e60195f1b64">createTimer</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Don't remove/erase timers from this array because in <a class="el" href="classne_1_1Node.html#ad9bd6ddcf9906c8526b02aa7d1067776">despawn</a> we might submit a deferred task (while stopping the timer) and will use the timer to check its state in deferred task so we need to make sure that stopped timer will not be deleted while the node exists. Additionally, all users hold raw pointers to timers so they will hit deleted memory in the case of deletion. </dd></dl>

</div>
</div>
<a id="aa406867a33c8b3347df81e329c46b5b8" name="aa406867a33c8b3347df81e329c46b5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa406867a33c8b3347df81e329c46b5b8">&#9670;&#160;</a></span>mtxIsCalledEveryFrame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, bool&gt; ne::Node::mtxIsCalledEveryFrame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Determines if the <a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> should be called each frame or not. </p>

</div>
</div>
<a id="ab250eceeeddc12965d14b29ad0f29ae7" name="ab250eceeeddc12965d14b29ad0f29ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab250eceeeddc12965d14b29ad0f29ae7">&#9670;&#160;</a></span>mtxIsReceivingInput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, bool&gt; ne::Node::mtxIsReceivingInput</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Determines if the input related functions, such as <a class="el" href="classne_1_1Node.html#a5b5e6b60ec1e1fdf9d1b7d6cb8387b74">onMouseMove</a>, <a class="el" href="classne_1_1Node.html#adde53f1d8c88385fb8ba338820e77c8e">onMouseScrollMove</a>, <a class="el" href="classne_1_1Node.html#a1f3b44b31513e2898d2caf35ea63d4e7">onInputActionEvent</a> and <a class="el" href="classne_1_1Node.html#aa48b63d44d51992c3c594b08d3e1c0a9">onInputAxisEvent</a> will be called or not. </p>

</div>
</div>
<a id="a104dc3bb8409c8d592fdc320c776d9fc" name="a104dc3bb8409c8d592fdc320c776d9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104dc3bb8409c8d592fdc320c776d9fc">&#9670;&#160;</a></span>mtxIsSpawned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, bool&gt; ne::Node::mtxIsSpawned</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Whether this node is spawned in the world or not. </p>

</div>
</div>
<a id="a272a651fe2aa6d290b6d6adbccf31bf3" name="a272a651fe2aa6d290b6d6adbccf31bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272a651fe2aa6d290b6d6adbccf31bf3">&#9670;&#160;</a></span>mtxParentNode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, sgc::GcPtr&lt;<a class="el" href="classne_1_1Node.html">Node</a>&gt; &gt; ne::Node::mtxParentNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attached parent node. </p>

</div>
</div>
<a id="a7d87d6149dac42ad71c72959d287dce1" name="a7d87d6149dac42ad71c72959d287dce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d87d6149dac42ad71c72959d287dce1">&#9670;&#160;</a></span>pWorld</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1World.html">World</a>* ne::Node::pWorld = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Do not delete this pointer. <a class="el" href="classne_1_1World.html">World</a> object that owns this node.</p>
<dl class="section warning"><dt>Warning</dt><dd>Will be initialized after the node is spawned and reset when despawned. </dd></dl>

</div>
</div>
<a id="aa2acbbe4c033a34bdc9dd4c76edebc32" name="aa2acbbe4c033a34bdc9dd4c76edebc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2acbbe4c033a34bdc9dd4c76edebc32">&#9670;&#160;</a></span>sExternalNodeTreePathAttributeName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto ne::Node::sExternalNodeTreePathAttributeName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            <span class="stringliteral">&quot;external_node_tree_path_relative_to_res&quot;</span></div>
</div><!-- fragment --><p >Name of the attribute we use to store a path to an external node tree. </p>

</div>
</div>
<a id="abf5d0aa8bddaf3927e80dddb787fbe26" name="abf5d0aa8bddaf3927e80dddb787fbe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5d0aa8bddaf3927e80dddb787fbe26">&#9670;&#160;</a></span>sNodeName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::Node::sNodeName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classne_1_1Node.html">Node</a>'s name. </p>

</div>
</div>
<a id="aaab872e5e0cda5bd3e50b37096d46b3d" name="aaab872e5e0cda5bd3e50b37096d46b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab872e5e0cda5bd3e50b37096d46b3d">&#9670;&#160;</a></span>sParentNodeIdAttributeName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto ne::Node::sParentNodeIdAttributeName = &quot;parent_node_id&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the attribute we use to serialize information about parent node. </p>

</div>
</div>
<a id="aee673da17a5126031bbb957fa2833505" name="aee673da17a5126031bbb957fa2833505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee673da17a5126031bbb957fa2833505">&#9670;&#160;</a></span>tickGroup</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TickGroup ne::Node::tickGroup = TickGroup::FIRST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tick group used by this node. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/public/game/node/<a class="el" href="Node_8h_source.html">Node.h</a></li>
<li>src/engine_lib/private/game/node/Node.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1Node.html">Node</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
