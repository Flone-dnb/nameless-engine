<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::PipelineManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1PipelineManager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1PipelineManager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::PipelineManager Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="PipelineManager_8h_source.html">PipelineManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html">ComputePipelines</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a977740ed73ba168c3b95c7b9e828c9a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#a977740ed73ba168c3b95c7b9e828c9a0">PipelineManager</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *<a class="el" href="classne_1_1PipelineManager.html#aa47dd48258976cdb05b313c9c52033cd">pRenderer</a>)</td></tr>
<tr class="separator:a977740ed73ba168c3b95c7b9e828c9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3041bd4f89a01584c07810d97c5cb9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#abc3041bd4f89a01584c07810d97c5cb9">~PipelineManager</a> ()</td></tr>
<tr class="separator:abc3041bd4f89a01584c07810d97c5cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aab5988f1e3548050d676c998636124"><td class="memItemLeft" align="right" valign="top"><a id="a6aab5988f1e3548050d676c998636124" name="a6aab5988f1e3548050d676c998636124"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PipelineManager</b> (const <a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> &amp;)=delete</td></tr>
<tr class="separator:a6aab5988f1e3548050d676c998636124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a54e67a9595d80055d45df4f7ebeb4"><td class="memItemLeft" align="right" valign="top"><a id="a75a54e67a9595d80055d45df4f7ebeb4" name="a75a54e67a9595d80055d45df4f7ebeb4"></a>
<a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> &amp;)=delete</td></tr>
<tr class="separator:a75a54e67a9595d80055d45df4f7ebeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19fcac5d073e236595bbaba0ef05289"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#ab19fcac5d073e236595bbaba0ef05289">bindBuffersToAllVulkanPipelinesIfUsed</a> (const std::array&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, <a class="el" href="classne_1_1FrameResourceManager.html#a90b23924d591a9a2fc33241c25d7892c">FrameResourceManager::getFrameResourceCount</a>()&gt; &amp;vResources, const std::string &amp;sShaderResourceName, VkDescriptorType descriptorType)</td></tr>
<tr class="separator:ab19fcac5d073e236595bbaba0ef05289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f3fae6d2b1ad8dd957061c4b902093"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#a51f3fae6d2b1ad8dd957061c4b902093">bindImageToAllVulkanPipelinesIfUsed</a> (<a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *pImageResourceToBind, const std::string &amp;sShaderResourceName, VkDescriptorType descriptorType, VkImageLayout imageLayout, VkSampler pSampler)</td></tr>
<tr class="separator:a51f3fae6d2b1ad8dd957061c4b902093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a610ed8365e4d63d30bfaed639190d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#ae3a610ed8365e4d63d30bfaed639190d">recreateGraphicsPipelinesResources</a> ()</td></tr>
<tr class="separator:ae3a610ed8365e4d63d30bfaed639190d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec99295c715da94f3969044a54b0b63"><td class="memItemLeft" align="right" valign="top">std::variant&lt; <a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#a9ec99295c715da94f3969044a54b0b63">getGraphicsPipelineForMaterial</a> (std::unique_ptr&lt; <a class="el" href="classne_1_1PipelineConfiguration.html">PipelineConfiguration</a> &gt; pPipelineConfiguration, <a class="el" href="classne_1_1Material.html">Material</a> *pMaterial)</td></tr>
<tr class="separator:a9ec99295c715da94f3969044a54b0b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2b14224c8e71e0f15daf965f54b398"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex *, <a class="el" href="structne_1_1QueuedForExecutionComputeShaders.html">QueuedForExecutionComputeShaders</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#aff2b14224c8e71e0f15daf965f54b398">getComputeShadersForGraphicsQueueExecution</a> ()</td></tr>
<tr class="separator:aff2b14224c8e71e0f15daf965f54b398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad700c995b0d52d2386731fe2a25277f6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1GraphicsPipelineRegistry.html">GraphicsPipelineRegistry</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#ad700c995b0d52d2386731fe2a25277f6">getGraphicsPipelines</a> ()</td></tr>
<tr class="separator:ad700c995b0d52d2386731fe2a25277f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6df8937369f1b14c0277f4645cf847"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#a9c6df8937369f1b14c0277f4645cf847">getCurrentGraphicsPipelineCount</a> ()</td></tr>
<tr class="separator:a9c6df8937369f1b14c0277f4645cf847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43fd33ba41cc0103d9decb11c5bb64d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#ae43fd33ba41cc0103d9decb11c5bb64d">getCurrentComputePipelineCount</a> ()</td></tr>
<tr class="separator:ae43fd33ba41cc0103d9decb11c5bb64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291716865f8990d91d417292c7b253be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#a291716865f8990d91d417292c7b253be">getRenderer</a> () const</td></tr>
<tr class="separator:a291716865f8990d91d417292c7b253be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab5a5dd302834a0098188defe1051edb6"><td class="memItemLeft" align="right" valign="top">std::variant&lt; <a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#ab5a5dd302834a0098188defe1051edb6">createGraphicsPipelineForMaterial</a> (std::unordered_map&lt; std::string, <a class="el" href="structne_1_1ShaderPipelines.html">ShaderPipelines</a> &gt; &amp;pipelines, const std::string &amp;sShaderNames, const std::set&lt; ShaderMacro &gt; &amp;macrosToUse, std::unique_ptr&lt; <a class="el" href="classne_1_1PipelineConfiguration.html">PipelineConfiguration</a> &gt; pPipelineConfiguration, <a class="el" href="classne_1_1Material.html">Material</a> *pMaterial)</td></tr>
<tr class="separator:ab5a5dd302834a0098188defe1051edb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b8c5604d6e9f1c44ec925bdee27400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#a07b8c5604d6e9f1c44ec925bdee27400">onPipelineNoLongerUsedByMaterial</a> (const std::string &amp;sPipelineIdentifier)</td></tr>
<tr class="separator:a07b8c5604d6e9f1c44ec925bdee27400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cd88db58b6607098cddc41bf855501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#a02cd88db58b6607098cddc41bf855501">onPipelineNoLongerUsedByComputeShaderInterface</a> (const std::string &amp;sComputeShaderName, <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *pComputeShaderInterface)</td></tr>
<tr class="separator:a02cd88db58b6607098cddc41bf855501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535e2ce924545544f65fff07d192c7e"><td class="memItemLeft" align="right" valign="top">std::variant&lt; <a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#ab535e2ce924545544f65fff07d192c7e">findOrCreatePipeline</a> (std::unordered_map&lt; std::string, <a class="el" href="structne_1_1ShaderPipelines.html">ShaderPipelines</a> &gt; &amp;pipelines, const std::string &amp;sKeyToLookFor, const std::set&lt; ShaderMacro &gt; &amp;macrosToLookFor, std::unique_ptr&lt; <a class="el" href="classne_1_1PipelineConfiguration.html">PipelineConfiguration</a> &gt; pPipelineConfiguration, <a class="el" href="classne_1_1Material.html">Material</a> *pMaterial)</td></tr>
<tr class="separator:ab535e2ce924545544f65fff07d192c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aeace69b8742a79b77faa24ac51841d46"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1GraphicsPipelineRegistry.html">GraphicsPipelineRegistry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#aeace69b8742a79b77faa24ac51841d46">mtxGraphicsPipelines</a></td></tr>
<tr class="separator:aeace69b8742a79b77faa24ac51841d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52a60668dd2d8ab801c45c0a16c70a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html">ComputePipelines</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#aa52a60668dd2d8ab801c45c0a16c70a4">computePipelines</a></td></tr>
<tr class="separator:aa52a60668dd2d8ab801c45c0a16c70a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47dd48258976cdb05b313c9c52033cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1PipelineManager.html#aa47dd48258976cdb05b313c9c52033cd">pRenderer</a> = nullptr</td></tr>
<tr class="separator:aa47dd48258976cdb05b313c9c52033cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af9f0f1adbd5baee7830839447205af8d"><td class="memItemLeft" align="right" valign="top"><a id="af9f0f1adbd5baee7830839447205af8d" name="af9f0f1adbd5baee7830839447205af8d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Pipeline</b></td></tr>
<tr class="separator:af9f0f1adbd5baee7830839447205af8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7461d815336b6905c15b155181451bba"><td class="memItemLeft" align="right" valign="top"><a id="a7461d815336b6905c15b155181451bba" name="a7461d815336b6905c15b155181451bba"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DelayedPipelineResourcesCreation</b></td></tr>
<tr class="separator:a7461d815336b6905c15b155181451bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791f2f97163f91abded57933d515f47e"><td class="memItemLeft" align="right" valign="top"><a id="a791f2f97163f91abded57933d515f47e" name="a791f2f97163f91abded57933d515f47e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeShaderInterface</b></td></tr>
<tr class="separator:a791f2f97163f91abded57933d515f47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Base class for managing render specific pipelines. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a977740ed73ba168c3b95c7b9e828c9a0" name="a977740ed73ba168c3b95c7b9e828c9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977740ed73ba168c3b95c7b9e828c9a0">&#9670;&#160;</a></span>PipelineManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::PipelineManager::PipelineManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new pipeline manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td><a class="el" href="classne_1_1Renderer.html">Renderer</a> that owns this pipeline manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc3041bd4f89a01584c07810d97c5cb9" name="abc3041bd4f89a01584c07810d97c5cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3041bd4f89a01584c07810d97c5cb9">&#9670;&#160;</a></span>~PipelineManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ne::PipelineManager::~PipelineManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Checks that there are no existing pipelines left. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab19fcac5d073e236595bbaba0ef05289" name="ab19fcac5d073e236595bbaba0ef05289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19fcac5d073e236595bbaba0ef05289">&#9670;&#160;</a></span>bindBuffersToAllVulkanPipelinesIfUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::bindBuffersToAllVulkanPipelinesIfUsed </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *, <a class="el" href="classne_1_1FrameResourceManager.html#a90b23924d591a9a2fc33241c25d7892c">FrameResourceManager::getFrameResourceCount</a>()&gt; &amp;&#160;</td>
          <td class="paramname"><em>vResources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorType&#160;</td>
          <td class="paramname"><em>descriptorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Binds the specified GPU resources (buffers, not images) to all Vulkan pipelines that use the specified shader resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vResources</td><td>Resources to bind. </td></tr>
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the shader resource (name from shader code) to bind to. </td></tr>
    <tr><td class="paramname">descriptorType</td><td>Type of the descriptor to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a51f3fae6d2b1ad8dd957061c4b902093" name="a51f3fae6d2b1ad8dd957061c4b902093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f3fae6d2b1ad8dd957061c4b902093">&#9670;&#160;</a></span>bindImageToAllVulkanPipelinesIfUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::bindImageToAllVulkanPipelinesIfUsed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *&#160;</td>
          <td class="paramname"><em>pImageResourceToBind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorType&#160;</td>
          <td class="paramname"><em>descriptorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>imageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSampler&#160;</td>
          <td class="paramname"><em>pSampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Binds the specified GPU image (not buffer) to all Vulkan pipelines that use the specified shader resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImageResourceToBind</td><td>Image to bind. </td></tr>
    <tr><td class="paramname">sShaderResourceName</td><td>Name of the shader resource (name from shader code) to bind to. </td></tr>
    <tr><td class="paramname">descriptorType</td><td>Type of the descriptor to bind. </td></tr>
    <tr><td class="paramname">imageLayout</td><td>Layout of the image. </td></tr>
    <tr><td class="paramname">pSampler</td><td>Sampler to use for the image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="ab5a5dd302834a0098188defe1051edb6" name="ab5a5dd302834a0098188defe1051edb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a5dd302834a0098188defe1051edb6">&#9670;&#160;</a></span>createGraphicsPipelineForMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; <a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::createGraphicsPipelineForMaterial </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; std::string, <a class="el" href="structne_1_1ShaderPipelines.html">ShaderPipelines</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; ShaderMacro &gt; &amp;&#160;</td>
          <td class="paramname"><em>macrosToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classne_1_1PipelineConfiguration.html">PipelineConfiguration</a> &gt;&#160;</td>
          <td class="paramname"><em>pPipelineConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Material.html">Material</a> *&#160;</td>
          <td class="paramname"><em>pMaterial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assigns vertex and pixel shaders to create a render specific graphics pipeline (for usual rendering).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelines</td><td>Pipelines of specific type to look in. </td></tr>
    <tr><td class="paramname">sShaderNames</td><td><a class="el" href="classne_1_1Shader.html">Shader</a> or shaders (map key value) for target pipeline. </td></tr>
    <tr><td class="paramname">macrosToUse</td><td>Macros that are set (can be only vertex or combined). </td></tr>
    <tr><td class="paramname">pPipelineConfiguration</td><td>Settings that determine pipeline usage and usage details. </td></tr>
    <tr><td class="paramname">pMaterial</td><td><a class="el" href="classne_1_1Material.html">Material</a> that requests the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if one or both were not found in <a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a> or if failed to generate pipeline, otherwise created pipeline. </dd></dl>

</div>
</div>
<a id="ab535e2ce924545544f65fff07d192c7e" name="ab535e2ce924545544f65fff07d192c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab535e2ce924545544f65fff07d192c7e">&#9670;&#160;</a></span>findOrCreatePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; <a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::findOrCreatePipeline </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; std::string, <a class="el" href="structne_1_1ShaderPipelines.html">ShaderPipelines</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sKeyToLookFor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; ShaderMacro &gt; &amp;&#160;</td>
          <td class="paramname"><em>macrosToLookFor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classne_1_1PipelineConfiguration.html">PipelineConfiguration</a> &gt;&#160;</td>
          <td class="paramname"><em>pPipelineConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Material.html">Material</a> *&#160;</td>
          <td class="paramname"><em>pMaterial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Looks for a pipeline and returns it if found, otherwise creates and return it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelines</td><td>Pipelines of specific type to look in. </td></tr>
    <tr><td class="paramname">sKeyToLookFor</td><td><a class="el" href="classne_1_1Shader.html">Shader</a> or shaders (map key value) for target pipeline. </td></tr>
    <tr><td class="paramname">macrosToLookFor</td><td>Macros that are set (can be only vertex or combined). </td></tr>
    <tr><td class="paramname">pPipelineConfiguration</td><td>Settings that determine pipeline usage and usage details. </td></tr>
    <tr><td class="paramname">pMaterial</td><td><a class="el" href="classne_1_1Material.html">Material</a> that requests the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise valid pipeline pointer. </dd></dl>

</div>
</div>
<a id="aff2b14224c8e71e0f15daf965f54b398" name="aff2b14224c8e71e0f15daf965f54b398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2b14224c8e71e0f15daf965f54b398">&#9670;&#160;</a></span>getComputeShadersForGraphicsQueueExecution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex *, <a class="el" href="structne_1_1QueuedForExecutionComputeShaders.html">QueuedForExecutionComputeShaders</a> * &gt; ne::PipelineManager::getComputeShadersForGraphicsQueueExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns all compute shaders and their pipelines to be executed on the graphics queue.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete (free) returned pointers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Shaders and pipelines. </dd></dl>

</div>
</div>
<a id="ae43fd33ba41cc0103d9decb11c5bb64d" name="ae43fd33ba41cc0103d9decb11c5bb64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43fd33ba41cc0103d9decb11c5bb64d">&#9670;&#160;</a></span>getCurrentComputePipelineCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::PipelineManager::getCurrentComputePipelineCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the total number of currently existing compute pipelines.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of currently existing compute pipelines. </dd></dl>

</div>
</div>
<a id="a9c6df8937369f1b14c0277f4645cf847" name="a9c6df8937369f1b14c0277f4645cf847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6df8937369f1b14c0277f4645cf847">&#9670;&#160;</a></span>getCurrentGraphicsPipelineCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::PipelineManager::getCurrentGraphicsPipelineCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the total number of currently existing graphics pipelines.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of currently existing graphics pipelines. </dd></dl>

</div>
</div>
<a id="a9ec99295c715da94f3969044a54b0b63" name="a9ec99295c715da94f3969044a54b0b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec99295c715da94f3969044a54b0b63">&#9670;&#160;</a></span>getGraphicsPipelineForMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; <a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::getGraphicsPipelineForMaterial </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classne_1_1PipelineConfiguration.html">PipelineConfiguration</a> &gt;&#160;</td>
          <td class="paramname"><em>pPipelineConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Material.html">Material</a> *&#160;</td>
          <td class="paramname"><em>pMaterial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Look for already created pipeline that uses the specified shaders and settings and returns it, otherwise creates a new pipeline.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If creating a new pipeline, loads the specified shaders from disk into the memory, they will be released from the memory once the pipeline object is destroyed (not the shared pointer) and no other object is using them.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPipelineConfiguration</td><td>Settings that determine pipeline usage and usage details. </td></tr>
    <tr><td class="paramname">pMaterial</td><td><a class="el" href="classne_1_1Material.html">Material</a> that requests the pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if one or both shaders were not found in <a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a> or if failed to generate pipeline, otherwise created pipeline. </dd></dl>

</div>
</div>
<a id="ad700c995b0d52d2386731fe2a25277f6" name="ad700c995b0d52d2386731fe2a25277f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad700c995b0d52d2386731fe2a25277f6">&#9670;&#160;</a></span>getGraphicsPipelines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1GraphicsPipelineRegistry.html">GraphicsPipelineRegistry</a> &gt; * ne::PipelineManager::getGraphicsPipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns all vertex/pixel shaders and their graphics pipelines.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete (free) returned pointers.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>While the mutex is locked no pipeline will re-create its internal resources.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Shaders and pipelines. </dd></dl>

</div>
</div>
<a id="a291716865f8990d91d417292c7b253be" name="a291716865f8990d91d417292c7b253be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291716865f8990d91d417292c7b253be">&#9670;&#160;</a></span>getRenderer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Renderer.html">Renderer</a> * ne::PipelineManager::getRenderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns renderer that owns this pipeline manager.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Renderer.html">Renderer</a>. </dd></dl>

</div>
</div>
<a id="a02cd88db58b6607098cddc41bf855501" name="a02cd88db58b6607098cddc41bf855501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cd88db58b6607098cddc41bf855501">&#9670;&#160;</a></span>onPipelineNoLongerUsedByComputeShaderInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::PipelineManager::onPipelineNoLongerUsedByComputeShaderInterface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sComputeShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *&#160;</td>
          <td class="paramname"><em>pComputeShaderInterface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from a pipeline when a compute shader interface is no longer using a pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sComputeShaderName</td><td>Name of the compute shader that the pipeline uses. </td></tr>
    <tr><td class="paramname">pComputeShaderInterface</td><td>Compute shader interface that stopped using the pipeline. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07b8c5604d6e9f1c44ec925bdee27400" name="a07b8c5604d6e9f1c44ec925bdee27400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b8c5604d6e9f1c44ec925bdee27400">&#9670;&#160;</a></span>onPipelineNoLongerUsedByMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::PipelineManager::onPipelineNoLongerUsedByMaterial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sPipelineIdentifier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called from a pipeline when a material is no longer using a pipeline (for ex. because changing shaders).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sPipelineIdentifier</td><td><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3a610ed8365e4d63d30bfaed639190d" name="ae3a610ed8365e4d63d30bfaed639190d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a610ed8365e4d63d30bfaed639190d">&#9670;&#160;</a></span>recreateGraphicsPipelinesResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::recreateGraphicsPipelinesResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Releases all internal resources from all graphics graphics pipelines and then recreates them to reference new resources/parameters from the renderer.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that the GPU is not processing any frames and the rendering is paused (new frames are not submitted) while this function is being called.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used when all graphics pipelines reference old render resources/parameters to reference the new (changed) render resources/parameters. The typical workflow goes like this: pause the rendering, change renderer's resource/parameter that all graphics pipelines reference (like render target type (MSAA or not) or MSAA sample count), then call this function (all graphics pipelines will now query up-to-date rendering resources/parameters) and then you can continue rendering.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa52a60668dd2d8ab801c45c0a16c70a4" name="aa52a60668dd2d8ab801c45c0a16c70a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52a60668dd2d8ab801c45c0a16c70a4">&#9670;&#160;</a></span>computePipelines</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html">ComputePipelines</a> ne::PipelineManager::computePipelines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores all compute pipelines. </p>

</div>
</div>
<a id="aeace69b8742a79b77faa24ac51841d46" name="aeace69b8742a79b77faa24ac51841d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeace69b8742a79b77faa24ac51841d46">&#9670;&#160;</a></span>mtxGraphicsPipelines</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1GraphicsPipelineRegistry.html">GraphicsPipelineRegistry</a>&gt; ne::PipelineManager::mtxGraphicsPipelines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Groups all graphics pipelines. </p>

</div>
</div>
<a id="aa47dd48258976cdb05b313c9c52033cd" name="aa47dd48258976cdb05b313c9c52033cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47dd48258976cdb05b313c9c52033cd">&#9670;&#160;</a></span>pRenderer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Renderer.html">Renderer</a>* const ne::PipelineManager::pRenderer = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Do not delete (free) this pointer. <a class="el" href="classne_1_1Renderer.html">Renderer</a> that owns this pipeline manager. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/private/render/general/pipeline/<a class="el" href="PipelineManager_8h_source.html">PipelineManager.h</a></li>
<li>src/engine_lib/private/render/general/pipeline/PipelineManager.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
