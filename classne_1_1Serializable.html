<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::Serializable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1Serializable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1Serializable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::Serializable Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Serializable_8h_source.html">Serializable.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::Serializable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1Serializable.png" usemap="#ne::Serializable_map" alt=""/>
  <map id="ne::Serializable_map" name="ne::Serializable_map">
<area href="classne_1_1Material.html" alt="ne::Material" shape="rect" coords="0,112,150,136"/>
<area href="classne_1_1MeshData.html" alt="ne::MeshData" shape="rect" coords="160,112,310,136"/>
<area href="classne_1_1Node.html" alt="ne::Node" shape="rect" coords="320,112,470,136"/>
<area href="classne_1_1RenderSettings.html" alt="ne::RenderSettings" shape="rect" coords="480,112,630,136"/>
<area href="classne_1_1EnvironmentNode.html" alt="ne::EnvironmentNode" shape="rect" coords="240,168,390,192"/>
<area href="classne_1_1SpatialNode.html" alt="ne::SpatialNode" shape="rect" coords="400,168,550,192"/>
<area href="classne_1_1CameraNode.html" alt="ne::CameraNode" shape="rect" coords="80,224,230,248"/>
<area href="classne_1_1DirectionalLightNode.html" alt="ne::DirectionalLightNode" shape="rect" coords="240,224,390,248"/>
<area href="classne_1_1MeshNode.html" alt="ne::MeshNode" shape="rect" coords="400,224,550,248"/>
<area href="classne_1_1PointLightNode.html" alt="ne::PointLightNode" shape="rect" coords="560,224,710,248"/>
<area href="classne_1_1SpotlightNode.html" alt="ne::SpotlightNode" shape="rect" coords="720,224,870,248"/>
<area href="classne_1_1EditorCameraNode.html" alt="ne::EditorCameraNode" shape="rect" coords="80,280,230,304"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2b1c9ee24ea69f0b6231eff5a262e348"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a2b1c9ee24ea69f0b6231eff5a262e348">serialize</a> (std::filesystem::path pathToFile, bool bEnableBackup, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={})</td></tr>
<tr class="separator:a2b1c9ee24ea69f0b6231eff5a262e348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a79714019d1b40ce8d063b920bbdcf"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af0a79714019d1b40ce8d063b920bbdcf">serialize</a> (toml::value &amp;tomlData, const std::string &amp;sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:af0a79714019d1b40ce8d063b920bbdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99dd41bee3fdcea40c80bf317cc590d"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#aa99dd41bee3fdcea40c80bf317cc590d">serialize</a> (toml::value &amp;tomlData, <a class="el" href="classne_1_1Serializable.html">Serializable</a> *pOriginalObject, std::string sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:aa99dd41bee3fdcea40c80bf317cc590d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0404cdf34dc3fb25b7932a87ed9ade38"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a0404cdf34dc3fb25b7932a87ed9ade38">getPathDeserializedFromRelativeToRes</a> () const</td></tr>
<tr class="separator:a0404cdf34dc3fb25b7932a87ed9ade38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6cd50b9cef87748dede76ba3ef125e43"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::pair&lt; std::set&lt; std::string &gt;, toml::value &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a6cd50b9cef87748dede76ba3ef125e43">getIdsFromFile</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a6cd50b9cef87748dede76ba3ef125e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f76ea78f80fb43e5e481277a930b364"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a1f76ea78f80fb43e5e481277a930b364">serializeMultiple</a> (std::filesystem::path pathToFile, std::vector&lt; <a class="el" href="structne_1_1SerializableObjectInformation.html">SerializableObjectInformation</a> &gt; vObjects, bool bEnableBackup)</td></tr>
<tr class="separator:a1f76ea78f80fb43e5e481277a930b364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a> (const std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:a464dd6597a8eb7793dfde75c36a44a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a3162d0dbc003bfcef8c0ae0846b32f77">deserialize</a> (const std::filesystem::path &amp;pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes)</td></tr>
<tr class="separator:a3162d0dbc003bfcef8c0ae0846b32f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a32a58a89522b5cca64db7b6750a73a19">deserialize</a> (std::filesystem::path pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:a32a58a89522b5cca64db7b6750a73a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#afb8e66a57cc108fca4d35ae40de8e22a">deserialize</a> (const std::filesystem::path &amp;pathToFile, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:afb8e66a57cc108fca4d35ae40de8e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::same_as&lt;SmartPointer, sgc::GcPtr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; std::vector&lt; <a class="el" href="structne_1_1DeserializedObjectInformation.html">DeserializedObjectInformation</a>&lt; SmartPointer &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a5d16d519e3d326cbdc101e78ca1a2478">deserializeMultiple</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a5d16d519e3d326cbdc101e78ca1a2478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af67ef936c5d20e2f861430b48c69c95a">deserialize</a> (const toml::value &amp;tomlData, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, std::string sEntityId=&quot;&quot;, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={})</td></tr>
<tr class="separator:af67ef936c5d20e2f861430b48c69c95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a00002d59e5d0dcda6e53c20b59947150"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a00002d59e5d0dcda6e53c20b59947150">onAfterDeserialized</a> ()</td></tr>
<tr class="separator:a00002d59e5d0dcda6e53c20b59947150"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aab36f16bc593429b096f1112ad5cd52d"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#aab36f16bc593429b096f1112ad5cd52d">resolvePathToToml</a> (std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:aab36f16bc593429b096f1112ad5cd52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae524a157024d00ae1ab1ee6a3a44b01a"><td class="memItemLeft" align="right" valign="top">static const rfk::Class *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#ae524a157024d00ae1ab1ee6a3a44b01a">getClassForGuid</a> (const std::string &amp;sGuid)</td></tr>
<tr class="separator:ae524a157024d00ae1ab1ee6a3a44b01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9ca7767a0cac5a0612ff2243e15fd0"><td class="memItemLeft" align="right" valign="top">static const rfk::Struct *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a8c9ca7767a0cac5a0612ff2243e15fd0">getClassForGuid</a> (const rfk::Struct *pArchetypeToAnalyze, const std::string &amp;sGuid)</td></tr>
<tr class="separator:a8c9ca7767a0cac5a0612ff2243e15fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf799d17a8e7649d66c956fee4bb921b"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:adf799d17a8e7649d66c956fee4bb921b"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#adf799d17a8e7649d66c956fee4bb921b">deserializeFromSection</a> (const toml::value &amp;tomlData, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, const std::string &amp;sSectionName, const std::string &amp;sTypeGuid, const std::string &amp;sEntityId, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile)</td></tr>
<tr class="separator:adf799d17a8e7649d66c956fee4bb921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa26ef7fb597d68900cf353dfd6f63120"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#aa26ef7fb597d68900cf353dfd6f63120">pathDeserializedFromRelativeToRes</a></td></tr>
<tr class="separator:aa26ef7fb597d68900cf353dfd6f63120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a23b63a86bea9420f2d053c90c234c232"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a23b63a86bea9420f2d053c90c234c232">sSubEntityFieldNameKey</a> = &quot;.field_name&quot;</td></tr>
<tr class="separator:a23b63a86bea9420f2d053c90c234c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab488404eca6e23051944f1618e9fbbcb"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#ab488404eca6e23051944f1618e9fbbcb">sPathRelativeToResKey</a> = &quot;.path_relative_to_res&quot;</td></tr>
<tr class="separator:ab488404eca6e23051944f1618e9fbbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909285db66b8dad8e83bfad4dcafa59c"><td class="memItemLeft" align="right" valign="top">static const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a909285db66b8dad8e83bfad4dcafa59c">sNothingToSerializeKey</a> = &quot;.none&quot;</td></tr>
<tr class="separator:a909285db66b8dad8e83bfad4dcafa59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6d9e5fd4a908f96fa6bea88924ec42"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a8e6d9e5fd4a908f96fa6bea88924ec42">sCustomAttributePrefix</a> = &quot;..&quot;</td></tr>
<tr class="separator:a8e6d9e5fd4a908f96fa6bea88924ec42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a46bcb3022e066c28e3f167f4eace22bc"><td class="memItemLeft" align="right" valign="top"><a id="a46bcb3022e066c28e3f167f4eace22bc" name="a46bcb3022e066c28e3f167f4eace22bc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SerializableObjectFieldSerializer</b></td></tr>
<tr class="separator:a46bcb3022e066c28e3f167f4eace22bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Adds support for serialization/deserialization for your reflected type.</p>
<p >Inherit your class/struct from this class to add functions which will serialize the type and reflected fields (even inherited) that are marked with special properties. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a464dd6597a8eb7793dfde75c36a44a24" name="a464dd6597a8eb7793dfde75c36a44a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464dd6597a8eb7793dfde75c36a44a24">&#9670;&#160;</a></span>deserialize() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SmartPointer , typename InnerType &gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::deserialize </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathToFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deserializes an object and all reflected fields (including inherited) from a file. Specify the type of an object (that is located in the file) as the T template parameter, which can be entity's actual type or entity's parent (up to <a class="el" href="classne_1_1Serializable.html">Serializable</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>You can use either <code>sgc::GcPtr</code> or <code>std::unique_ptr</code> as a smart pointer for deserialized object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to read reflected data from. The ".toml" extension will be added automatically if not specified in the path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise a pointer to deserialized object. </dd></dl>

</div>
</div>
<a id="afb8e66a57cc108fca4d35ae40de8e22a" name="afb8e66a57cc108fca4d35ae40de8e22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8e66a57cc108fca4d35ae40de8e22a">&#9670;&#160;</a></span>deserialize() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SmartPointer , typename InnerType &gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::deserialize </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathToFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sEntityId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deserializes an object and all reflected fields (including inherited) from a file. Specify the type of an object (that is located in the file) as the T template parameter, which can be entity's actual type or entity's parent (up to <a class="el" href="classne_1_1Serializable.html">Serializable</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is an overloaded function, see a more detailed documentation for the other overload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to read reflected data from. The ".toml" extension will be added automatically if not specified in the path. </td></tr>
    <tr><td class="paramname">sEntityId</td><td>Unique ID of this object. When serializing multiple objects into one toml value provide different IDs for each object so they could be differentiated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise a pointer to deserialized object. </dd></dl>

</div>
</div>
<a id="a3162d0dbc003bfcef8c0ae0846b32f77" name="a3162d0dbc003bfcef8c0ae0846b32f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3162d0dbc003bfcef8c0ae0846b32f77">&#9670;&#160;</a></span>deserialize() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SmartPointer , typename InnerType &gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::deserialize </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathToFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>customAttributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deserializes an object and all reflected fields (including inherited) from a file. Specify the type of an object (that is located in the file) as the T template parameter, which can be entity's actual type or entity's parent (up to <a class="el" href="classne_1_1Serializable.html">Serializable</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is an overloaded function, see a more detailed documentation for the other overload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to read reflected data from. The ".toml" extension will be added automatically if not specified in the path. </td></tr>
    <tr><td class="paramname">customAttributes</td><td>Pairs of values that were associated with this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise a pointer to deserialized object. </dd></dl>

</div>
</div>
<a id="af67ef936c5d20e2f861430b48c69c95a" name="af67ef936c5d20e2f861430b48c69c95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67ef936c5d20e2f861430b48c69c95a">&#9670;&#160;</a></span>deserialize() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SmartPointer , typename InnerType &gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::deserialize </td>
          <td>(</td>
          <td class="paramtype">const toml::value &amp;&#160;</td>
          <td class="paramname"><em>tomlData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>customAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sEntityId</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::filesystem::path &gt; &amp;&#160;</td>
          <td class="paramname"><em>optionalPathToFile</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deserializes an object and all reflected fields (including inherited) from a toml value. Specify the type of an object (that is located in the file) as the T template parameter, which can be entity's actual type or entity's parent (up to <a class="el" href="classne_1_1Serializable.html">Serializable</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is an overloaded function, see a more detailed documentation for the other overload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tomlData</td><td>Toml value to retrieve an object from. </td></tr>
    <tr><td class="paramname">customAttributes</td><td>Pairs of values that were associated with this object. </td></tr>
    <tr><td class="paramname">sEntityId</td><td>Unique ID of this object. When serializing multiple objects into one toml value provide different IDs for each object so they could be differentiated. </td></tr>
    <tr><td class="paramname">optionalPathToFile</td><td>Optional. Path to the file that this TOML data is deserialized from. Used for fields marked as <code>Serialize(AsExternal)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Don't use dots in the entity ID, dots are used in recursion when this function is called from this function to process reflected field (sub entity).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise a pointer to deserialized object. </dd></dl>

</div>
</div>
<a id="a32a58a89522b5cca64db7b6750a73a19" name="a32a58a89522b5cca64db7b6750a73a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a58a89522b5cca64db7b6750a73a19">&#9670;&#160;</a></span>deserialize() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SmartPointer , typename InnerType &gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::filesystem::path&#160;</td>
          <td class="paramname"><em>pathToFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>customAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sEntityId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deserializes an object and all reflected fields (including inherited) from a file. Specify the type of an object (that is located in the file) as the T template parameter, which can be entity's actual type or entity's parent (up to <a class="el" href="classne_1_1Serializable.html">Serializable</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is an overloaded function, see a more detailed documentation for the other overload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to read reflected data from. The ".toml" extension will be added automatically if not specified in the path. </td></tr>
    <tr><td class="paramname">customAttributes</td><td>Pairs of values that were associated with this object. </td></tr>
    <tr><td class="paramname">sEntityId</td><td>Unique ID of this object. When serializing multiple objects into one toml value provide different IDs for each object so they could be differentiated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise a pointer to deserialized object. </dd></dl>

</div>
</div>
<a id="adf799d17a8e7649d66c956fee4bb921b" name="adf799d17a8e7649d66c956fee4bb921b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf799d17a8e7649d66c956fee4bb921b">&#9670;&#160;</a></span>deserializeFromSection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SmartPointer , typename InnerType &gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::deserializeFromSection </td>
          <td>(</td>
          <td class="paramtype">const toml::value &amp;&#160;</td>
          <td class="paramname"><em>tomlData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>customAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sSectionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sTypeGuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sEntityId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::filesystem::path &gt; &amp;&#160;</td>
          <td class="paramname"><em>optionalPathToFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deserializes an object and all reflected fields (including inherited) from a file. Specify the type of an object (that is located in the file) as the T template parameter, which can be entity's actual type or entity's parent (up to <a class="el" href="classne_1_1Serializable.html">Serializable</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is an overloaded function, see a more detailed documentation for the other overload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tomlData</td><td>Toml value to retrieve an object from. </td></tr>
    <tr><td class="paramname">customAttributes</td><td>Pairs of values that were associated with this object. </td></tr>
    <tr><td class="paramname">sSectionName</td><td>Name of the TOML section to deserialize. </td></tr>
    <tr><td class="paramname">sTypeGuid</td><td>GUID of the type to deserialize (taken from section name). </td></tr>
    <tr><td class="paramname">sEntityId</td><td>Entity ID chain string. </td></tr>
    <tr><td class="paramname">optionalPathToFile</td><td>Optional. Path to the file that this TOML data is deserialized from. Used for fields marked as <code>Serialize(AsExternal)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise a pointer to deserialized object. </dd></dl>

</div>
</div>
<a id="a5d16d519e3d326cbdc101e78ca1a2478" name="a5d16d519e3d326cbdc101e78ca1a2478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d16d519e3d326cbdc101e78ca1a2478">&#9670;&#160;</a></span>deserializeMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SmartPointer , typename InnerType &gt; <br />
requires std::same_as&lt;SmartPointer, sgc::GcPtr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::vector&lt; <a class="el" href="structne_1_1DeserializedObjectInformation.html">DeserializedObjectInformation</a>&lt; SmartPointer &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::deserializeMultiple </td>
          <td>(</td>
          <td class="paramtype">std::filesystem::path&#160;</td>
          <td class="paramname"><em>pathToFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Deserializes multiple objects and their reflected fields (including inherited) from a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to read reflected data from. The ".toml" extension will be added automatically if not specified in the path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise an array of pointers to deserialized objects. </dd></dl>

</div>
</div>
<a id="a8c9ca7767a0cac5a0612ff2243e15fd0" name="a8c9ca7767a0cac5a0612ff2243e15fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9ca7767a0cac5a0612ff2243e15fd0">&#9670;&#160;</a></span>getClassForGuid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const rfk::Struct * ne::Serializable::getClassForGuid </td>
          <td>(</td>
          <td class="paramtype">const rfk::Struct *&#160;</td>
          <td class="paramname"><em>pArchetypeToAnalyze</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sGuid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Looks for all children of the specified archetype to find a type that has the specified GUID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pArchetypeToAnalyze</td><td>Type which children to analyze. </td></tr>
    <tr><td class="paramname">sGuid</td><td>GUID to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if not found, otherwise valid pointer. </dd></dl>

</div>
</div>
<a id="ae524a157024d00ae1ab1ee6a3a44b01a" name="ae524a157024d00ae1ab1ee6a3a44b01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae524a157024d00ae1ab1ee6a3a44b01a">&#9670;&#160;</a></span>getClassForGuid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const rfk::Class * ne::Serializable::getClassForGuid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sGuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns archetype for the specified GUID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sGuid</td><td>GUID to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if not found, otherwise valid pointer. </dd></dl>

</div>
</div>
<a id="a6cd50b9cef87748dede76ba3ef125e43" name="a6cd50b9cef87748dede76ba3ef125e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd50b9cef87748dede76ba3ef125e43">&#9670;&#160;</a></span>getIdsFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::pair&lt; std::set&lt; std::string &gt;, toml::value &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::getIdsFromFile </td>
          <td>(</td>
          <td class="paramtype">std::filesystem::path&#160;</td>
          <td class="paramname"><em>pathToFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Analyzes the file for serialized objects, gathers and returns unique IDs of those objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to read serialized data from. The ".toml" extension will be added automatically if not specified in the path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise array of unique IDs of objects that exist in the specified file and parsed TOML data that you can reuse. </dd></dl>

</div>
</div>
<a id="a0404cdf34dc3fb25b7932a87ed9ade38" name="a0404cdf34dc3fb25b7932a87ed9ade38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0404cdf34dc3fb25b7932a87ed9ade38">&#9670;&#160;</a></span>getPathDeserializedFromRelativeToRes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::pair&lt; std::string, std::string &gt; &gt; ne::Serializable::getPathDeserializedFromRelativeToRes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If this object was deserialized from a file that is located in the <code>res</code> directory of this project, returns a pair of values:</p><ul>
<li>path to this file relative to the <code>res</code> directory,</li>
<li>unique ID of this object in this file.</li>
</ul>
<p >This path will never point to a backup file and will always point to the original file (even if the backup file was used in deserialization).</p>
<p >Example: say this object is deserialized from the file located at <code>.../res/game/test.toml</code>, this value will be equal to the following pair: {<code>game/test.toml</code>, <code>some.id</code>}.</p>
<dl class="section return"><dt>Returns</dt><dd>Empty if this object was not deserialized previously, otherwise path to the file that was used in deserialization relative to the <code>res</code> directory. </dd></dl>

</div>
</div>
<a id="a00002d59e5d0dcda6e53c20b59947150" name="a00002d59e5d0dcda6e53c20b59947150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00002d59e5d0dcda6e53c20b59947150">&#9670;&#160;</a></span>onAfterDeserialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::Serializable::onAfterDeserialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after the object was successfully deserialized. Used to execute post-deserialization logic.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented in <a class="el" href="classne_1_1DirectionalLightNode.html#a5371921a835741ed94bc0c823e8f5424">ne::DirectionalLightNode</a>, <a class="el" href="classne_1_1PointLightNode.html#ae2b46df4a1cf71aafb64a05a2b03a98c">ne::PointLightNode</a>, <a class="el" href="classne_1_1SpotlightNode.html#aa34d6c205b21d9b7beeaa2769c0ecb96">ne::SpotlightNode</a>, <a class="el" href="classne_1_1MeshNode.html#a453c3a079be0120c8c9fb7cd3a5a6899">ne::MeshNode</a>, <a class="el" href="classne_1_1SpatialNode.html#a4ef72e0c9e17fba2aeae88a87c424a84">ne::SpatialNode</a>, <a class="el" href="classne_1_1Material.html#a7946faee0b5231b38196c9cc8c2dffd4">ne::Material</a>, and <a class="el" href="classne_1_1RenderSettings.html#a9107963ba60801c525dcfecdc3d0d293">ne::RenderSettings</a>.</p>

</div>
</div>
<a id="aab36f16bc593429b096f1112ad5cd52d" name="aab36f16bc593429b096f1112ad5cd52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab36f16bc593429b096f1112ad5cd52d">&#9670;&#160;</a></span>resolvePathToToml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::resolvePathToToml </td>
          <td>(</td>
          <td class="paramtype">std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>pathToFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds ".toml" extension to the path (if needed) and copies a backup file to the specified path if the specified path does not exist but there is a backup file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>Path to toml file (may point to non-existing path or don't have ".toml" extension).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a2b1c9ee24ea69f0b6231eff5a262e348" name="a2b1c9ee24ea69f0b6231eff5a262e348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1c9ee24ea69f0b6231eff5a262e348">&#9670;&#160;</a></span>serialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::serialize </td>
          <td>(</td>
          <td class="paramtype">std::filesystem::path&#160;</td>
          <td class="paramname"><em>pathToFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableBackup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>customAttributes</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Serializes the object and all reflected fields (including inherited) that are marked with <code><a class="el" href="classne_1_1Serialize.html">ne::Serialize</a></code> property into a file. Serialized object can later be deserialized using <a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to write reflected data to. The ".toml" extension will be added automatically if not specified in the path. If the specified file already exists it will be overwritten. If the directories of the specified file do not exist they will be recursively created. </td></tr>
    <tr><td class="paramname">bEnableBackup</td><td>If 'true' will also use a backup (copy) file. <a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a> can use backup file if the original file does not exist. Generally you want to use a backup file if you are saving important information, such as player progress, other cases such as player game settings and etc. usually do not need a backup but you can use it if you want. </td></tr>
    <tr><td class="paramname">customAttributes</td><td>Optional. Custom pairs of values that will be saved as this object's additional information and could be later retrieved in <a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If file's parent directories do no exist they will be created.</dd>
<dd>
In order for a field to be serialized with the object, you need to mark it with <code><a class="el" href="classne_1_1Serialize.html">ne::Serialize</a></code> property like so: <div class="fragment"><div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line">RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line"><span class="keywordtype">int</span> iMyValue = 0;</div>
<div class="ttc" id="aclassne_1_1Serialize_html"><div class="ttname"><a href="classne_1_1Serialize.html">ne::Serialize</a></div><div class="ttdef"><b>Definition:</b> SerializeProperty.h:42</div></div>
</div><!-- fragment --> Note that not all reflected fields can be serialized, only specific types can be serialized. Const fields, pointer fields, lvalue references, rvalue references and C-arrays will always be ignored and will not be serialized (no error returned). Supported for serialization types are:<ul>
<li><code>bool</code></li>
<li><code>int</code></li>
<li><code>unsigned int</code></li>
<li><code>long long</code></li>
<li><code>unsigned long long</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>std::string</code></li>
<li><code>T</code> (where <code>T</code> is any type that derives from <a class="el" href="classne_1_1Serializable.html">Serializable</a>)</li>
<li>and more, see <code>io/serializers</code> directory for available field serializers (you don't need to use them directly, they will be automatically picked inside of this function).</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, for example when found an unsupported for serialization reflected field. </dd></dl>

</div>
</div>
<a id="af0a79714019d1b40ce8d063b920bbdcf" name="af0a79714019d1b40ce8d063b920bbdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a79714019d1b40ce8d063b920bbdcf">&#9670;&#160;</a></span>serialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::serialize </td>
          <td>(</td>
          <td class="paramtype">toml::value &amp;&#160;</td>
          <td class="paramname"><em>tomlData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sEntityId</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>customAttributes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::filesystem::path &gt; &amp;&#160;</td>
          <td class="paramname"><em>optionalPathToFile</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableBackup</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Serializes the object and all reflected fields (including inherited) into a toml value.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is an overloaded function. See full documentation for other overload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tomlData</td><td>Toml value to append this object to. </td></tr>
    <tr><td class="paramname">sEntityId</td><td>Unique ID of this object. When serializing multiple objects into one toml value provide different IDs for each object so they could be differentiated. Don't use dots in the entity ID, dots are used in recursion when this function is called from this function to process reflected field (sub entity). </td></tr>
    <tr><td class="paramname">customAttributes</td><td>Optional. Custom pairs of values that will be saved as this object's additional information and could be later retrieved in <a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a>. </td></tr>
    <tr><td class="paramname">optionalPathToFile</td><td>Optional. Path to the file that this TOML data will be serialized. Used for fields marked as <code>Serialize(AsExternal)</code>. </td></tr>
    <tr><td class="paramname">bEnableBackup</td><td>Optional. If this TOML data will be serialized to file whether the backup file is needed or not. Used for fields marked as <code>Serialize(AsExternal)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, for example when found an unsupported for serialization reflected field, otherwise name of the section that was used to store this entity. </dd></dl>

</div>
</div>
<a id="aa99dd41bee3fdcea40c80bf317cc590d" name="aa99dd41bee3fdcea40c80bf317cc590d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99dd41bee3fdcea40c80bf317cc590d">&#9670;&#160;</a></span>serialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::serialize </td>
          <td>(</td>
          <td class="paramtype">toml::value &amp;&#160;</td>
          <td class="paramname"><em>tomlData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Serializable.html">Serializable</a> *&#160;</td>
          <td class="paramname"><em>pOriginalObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sEntityId</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>customAttributes</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::filesystem::path &gt; &amp;&#160;</td>
          <td class="paramname"><em>optionalPathToFile</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableBackup</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Serializes the object and all reflected fields (including inherited) into a toml value.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is an overloaded function that takes an original object to serialize only changed values. See full documentation for other overload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tomlData</td><td>Toml value to append this object to. </td></tr>
    <tr><td class="paramname">pOriginalObject</td><td>Optional. Original object of the same type as the object being serialized, this object is a deserialized version of the object being serialized, used to compare serializable fields' values and only serialize changed values. </td></tr>
    <tr><td class="paramname">sEntityId</td><td>Unique ID of this object. When serializing multiple objects into one toml value provide different IDs for each object so they could be differentiated. Don't use dots in the entity ID, dots are used in recursion when this function is called from this function to process reflected field (sub entity). </td></tr>
    <tr><td class="paramname">customAttributes</td><td>Optional. Custom pairs of values that will be saved as this object's additional information and could be later retrieved in <a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a>. </td></tr>
    <tr><td class="paramname">optionalPathToFile</td><td>Optional. Path to the file that this TOML data will be serialized. Used for fields marked as <code>Serialize(AsExternal)</code>. </td></tr>
    <tr><td class="paramname">bEnableBackup</td><td>Optional. If this TOML data will be serialized to file whether the backup file is needed or not. Used for fields marked as <code>Serialize(AsExternal)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, for example when found an unsupported for serialization reflected field, otherwise name of the section that was used to store this entity. </dd></dl>

</div>
</div>
<a id="a1f76ea78f80fb43e5e481277a930b364" name="a1f76ea78f80fb43e5e481277a930b364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f76ea78f80fb43e5e481277a930b364">&#9670;&#160;</a></span>serializeMultiple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::Serializable::serializeMultiple </td>
          <td>(</td>
          <td class="paramtype">std::filesystem::path&#160;</td>
          <td class="paramname"><em>pathToFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structne_1_1SerializableObjectInformation.html">SerializableObjectInformation</a> &gt;&#160;</td>
          <td class="paramname"><em>vObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableBackup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Serializes multiple objects, their reflected fields (including inherited) and provided custom attributes (if any) into a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathToFile</td><td>File to write reflected data to. The ".toml" extension will be added automatically if not specified in the path. If the specified file already exists it will be overwritten. </td></tr>
    <tr><td class="paramname">vObjects</td><td>Array of objects to serialize, their unique IDs (so they could be differentiated in the file) and custom attributes (if any). Don't use dots in the entity IDs, dots are used internally. </td></tr>
    <tr><td class="paramname">bEnableBackup</td><td>If 'true' will also use a backup (copy) file. <a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a> can use backup file if the original file does not exist. Generally you want to use a backup file if you are saving important information, such as player progress, other cases such as player game settings and etc. usually do not need a backup but you can use it if you want.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, for example when found an unsupported for serialization reflected field. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa26ef7fb597d68900cf353dfd6f63120" name="aa26ef7fb597d68900cf353dfd6f63120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26ef7fb597d68900cf353dfd6f63120">&#9670;&#160;</a></span>pathDeserializedFromRelativeToRes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::pair&lt;std::string, std::string&gt; &gt; ne::Serializable::pathDeserializedFromRelativeToRes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If this object was deserialized from a file that is located in the <code>res</code> directory of this project, this field will contain a pair of values:</p><ul>
<li>path to this file relative to the <code>res</code> directory,</li>
<li>unique ID of this object in this file.</li>
</ul>
<p >This path will never point to a backup file and will always point to the original file (even if the backup file was used in deserialization).</p>
<p >Example: say this object is deserialized from the file located at <code>.../res/game/test.toml</code>, this value will be equal to <code>game/test.toml</code>. </p>

</div>
</div>
<a id="a8e6d9e5fd4a908f96fa6bea88924ec42" name="a8e6d9e5fd4a908f96fa6bea88924ec42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6d9e5fd4a908f96fa6bea88924ec42">&#9670;&#160;</a></span>sCustomAttributePrefix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view ne::Serializable::sCustomAttributePrefix = &quot;..&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Text that we add to custom (user-specified) attributes in TOML files. </p>

</div>
</div>
<a id="a909285db66b8dad8e83bfad4dcafa59c" name="a909285db66b8dad8e83bfad4dcafa59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909285db66b8dad8e83bfad4dcafa59c">&#9670;&#160;</a></span>sNothingToSerializeKey</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto ne::Serializable::sNothingToSerializeKey = &quot;.none&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the key which we use when there is nothing to serialize. </p>

</div>
</div>
<a id="ab488404eca6e23051944f1618e9fbbcb" name="ab488404eca6e23051944f1618e9fbbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab488404eca6e23051944f1618e9fbbcb">&#9670;&#160;</a></span>sPathRelativeToResKey</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto ne::Serializable::sPathRelativeToResKey = &quot;.path_relative_to_res&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the key which we use when we serialize an object that was previously deserialized from the <code>res</code> directory. </p>

</div>
</div>
<a id="a23b63a86bea9420f2d053c90c234c232" name="a23b63a86bea9420f2d053c90c234c232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b63a86bea9420f2d053c90c234c232">&#9670;&#160;</a></span>sSubEntityFieldNameKey</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto ne::Serializable::sSubEntityFieldNameKey = &quot;.field_name&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the key in which to store name of the field a section represents. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/public/io/<a class="el" href="Serializable_8h_source.html">Serializable.h</a></li>
<li>src/engine_lib/private/io/Serializable.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1Serializable.html">Serializable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
