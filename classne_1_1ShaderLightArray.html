<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::ShaderLightArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1ShaderLightArray.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1ShaderLightArray-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::ShaderLightArray Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ShaderLightArray_8h_source.html">ShaderLightArray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1ShaderLightArray_1_1Resources.html">Resources</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab31abec30f8efd631644f951a9943e1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#ab31abec30f8efd631644f951a9943e1e">~ShaderLightArray</a> ()</td></tr>
<tr class="separator:ab31abec30f8efd631644f951a9943e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae70b6d70f55db9c6a6c7e6a4e79813c"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderLightArraySlot.html">ShaderLightArraySlot</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#aae70b6d70f55db9c6a6c7e6a4e79813c">reserveNewSlot</a> (<a class="el" href="classne_1_1Node.html">Node</a> *pSpawnedOwnerLightNode, size_t iDataSizeInBytes, const std::function&lt; void *()&gt; &amp;startUpdateCallback, const std::function&lt; void()&gt; &amp;finishUpdateCallback)</td></tr>
<tr class="separator:aae70b6d70f55db9c6a6c7e6a4e79813c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebc69a64306d5c8018702d33c56f67a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1ShaderLightArray_1_1Resources.html">Resources</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a1ebc69a64306d5c8018702d33c56f67a">getInternalResources</a> ()</td></tr>
<tr class="separator:a1ebc69a64306d5c8018702d33c56f67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba83acfc58436dcb6c7bb1d0e9dcc41"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a1ba83acfc58436dcb6c7bb1d0e9dcc41">getShaderResourceName</a> () const</td></tr>
<tr class="separator:a1ba83acfc58436dcb6c7bb1d0e9dcc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abf03e290231b8ccbf397735d8b5da41d"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderLightArray.html">ShaderLightArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#abf03e290231b8ccbf397735d8b5da41d">create</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *<a class="el" href="classne_1_1ShaderLightArray.html#aa20bb571bf72d18efd48b3c7cc5d540f">pRenderer</a>, const std::string &amp;<a class="el" href="classne_1_1ShaderLightArray.html#ae2f84853d5b089acaa0c88910c6bb470">sShaderLightResourceName</a>, const std::function&lt; void(size_t)&gt; &amp;<a class="el" href="classne_1_1ShaderLightArray.html#acb1cd03348735f995151cca2af72dc35">onSizeChanged</a>, const std::optional&lt; std::pair&lt; std::function&lt; void(size_t)&gt;, std::string &gt; &gt; &amp;optionalOnLightsInCameraFrustumCulled)</td></tr>
<tr class="separator:abf03e290231b8ccbf397735d8b5da41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a82364a0934412cb48f7ac3f8d2a71696"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a82364a0934412cb48f7ac3f8d2a71696">ShaderLightArray</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *<a class="el" href="classne_1_1ShaderLightArray.html#aa20bb571bf72d18efd48b3c7cc5d540f">pRenderer</a>, const std::string &amp;<a class="el" href="classne_1_1ShaderLightArray.html#ae2f84853d5b089acaa0c88910c6bb470">sShaderLightResourceName</a>, const std::function&lt; void(size_t)&gt; &amp;<a class="el" href="classne_1_1ShaderLightArray.html#acb1cd03348735f995151cca2af72dc35">onSizeChanged</a>, const std::optional&lt; std::function&lt; void(size_t)&gt; &gt; &amp;<a class="el" href="classne_1_1ShaderLightArray.html#a61485718d7dc7043ba990c7eec6beed1">optionalCallbackOnLightsInCameraFrustumCulled</a>, const std::string &amp;sIndicesLightsInFrustumShaderResourceName=&quot;&quot;)</td></tr>
<tr class="separator:a82364a0934412cb48f7ac3f8d2a71696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d9f5f3d4916adb095077b84dccad0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a47d9f5f3d4916adb095077b84dccad0a">onLightsInCameraFrustumCulled</a> (size_t iCurrentFrameResourceIndex)</td></tr>
<tr class="separator:a47d9f5f3d4916adb095077b84dccad0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545c6de44ae5674b637ddc849599c8ba"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a545c6de44ae5674b637ddc849599c8ba">recreateArray</a> (bool bIsInitialization=false)</td></tr>
<tr class="separator:a545c6de44ae5674b637ddc849599c8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff63eebae0040b8a82ced015c22662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a57ff63eebae0040b8a82ced015c22662">updateSlotsMarkedAsNeedsUpdate</a> (size_t iCurrentFrameResourceIndex)</td></tr>
<tr class="separator:a57ff63eebae0040b8a82ced015c22662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab06a0a73281fe8a8c3a55f3dac39fe"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a0ab06a0a73281fe8a8c3a55f3dac39fe">updateBindingsInAllPipelines</a> ()</td></tr>
<tr class="separator:a0ab06a0a73281fe8a8c3a55f3dac39fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c45a8a69b61832fb3563a00baa685c9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a9c45a8a69b61832fb3563a00baa685c9">updatePipelineBinding</a> (<a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *pPipeline)</td></tr>
<tr class="separator:a9c45a8a69b61832fb3563a00baa685c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3328662ff475820aae6c436b08ef8bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a3328662ff475820aae6c436b08ef8bc7">freeSlot</a> (<a class="el" href="classne_1_1ShaderLightArraySlot.html">ShaderLightArraySlot</a> *pSlot)</td></tr>
<tr class="separator:a3328662ff475820aae6c436b08ef8bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1ca46441de4fdd45cb53339968fecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a3a1ca46441de4fdd45cb53339968fecb">markSlotAsNeedsUpdate</a> (<a class="el" href="classne_1_1ShaderLightArraySlot.html">ShaderLightArraySlot</a> *pSlot)</td></tr>
<tr class="separator:a3a1ca46441de4fdd45cb53339968fecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a15f7189a54f5809dcc61dbd61eb8bb39"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1ShaderLightArray_1_1Resources.html">Resources</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a15f7189a54f5809dcc61dbd61eb8bb39">mtxResources</a></td></tr>
<tr class="separator:a15f7189a54f5809dcc61dbd61eb8bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20bb571bf72d18efd48b3c7cc5d540f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#aa20bb571bf72d18efd48b3c7cc5d540f">pRenderer</a> = nullptr</td></tr>
<tr class="separator:aa20bb571bf72d18efd48b3c7cc5d540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4c669a2419d42c01c780d5c7ce9484"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#acc4c669a2419d42c01c780d5c7ce9484">iElementSizeInBytes</a> = 0</td></tr>
<tr class="separator:acc4c669a2419d42c01c780d5c7ce9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61485718d7dc7043ba990c7eec6beed1"><td class="memItemLeft" align="right" valign="top">const std::optional&lt; std::function&lt; void(size_t)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#a61485718d7dc7043ba990c7eec6beed1">optionalCallbackOnLightsInCameraFrustumCulled</a></td></tr>
<tr class="separator:a61485718d7dc7043ba990c7eec6beed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1cd03348735f995151cca2af72dc35"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void(size_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#acb1cd03348735f995151cca2af72dc35">onSizeChanged</a></td></tr>
<tr class="separator:acb1cd03348735f995151cca2af72dc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f84853d5b089acaa0c88910c6bb470"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderLightArray.html#ae2f84853d5b089acaa0c88910c6bb470">sShaderLightResourceName</a></td></tr>
<tr class="separator:ae2f84853d5b089acaa0c88910c6bb470"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5d52e88ab5b9a7c74b31dad2be54fdd7"><td class="memItemLeft" align="right" valign="top"><a id="a5d52e88ab5b9a7c74b31dad2be54fdd7" name="a5d52e88ab5b9a7c74b31dad2be54fdd7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderLightArraySlot</b></td></tr>
<tr class="separator:a5d52e88ab5b9a7c74b31dad2be54fdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ec01be613e89fa402929420493f4da"><td class="memItemLeft" align="right" valign="top"><a id="a89ec01be613e89fa402929420493f4da" name="a89ec01be613e89fa402929420493f4da"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>LightingShaderResourceManager</b></td></tr>
<tr class="separator:a89ec01be613e89fa402929420493f4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70538530bc36e033e360880ef311df61"><td class="memItemLeft" align="right" valign="top"><a id="a70538530bc36e033e360880ef311df61" name="a70538530bc36e033e360880ef311df61"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Renderer</b></td></tr>
<tr class="separator:a70538530bc36e033e360880ef311df61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Manages arrays (defined in shaders) related to lighting and allows modifying the array data from the CPU side. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab31abec30f8efd631644f951a9943e1e" name="ab31abec30f8efd631644f951a9943e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31abec30f8efd631644f951a9943e1e">&#9670;&#160;</a></span>~ShaderLightArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::ShaderLightArray::~ShaderLightArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Makes sure there are no active slots. </p>

</div>
</div>
<a id="a82364a0934412cb48f7ac3f8d2a71696" name="a82364a0934412cb48f7ac3f8d2a71696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82364a0934412cb48f7ac3f8d2a71696">&#9670;&#160;</a></span>ShaderLightArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ne::ShaderLightArray::ShaderLightArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderLightResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>onSizeChanged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::function&lt; void(size_t)&gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>optionalCallbackOnLightsInCameraFrustumCulled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sIndicesLightsInFrustumShaderResourceName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new array.</p>
<dl class="section warning"><dt>Warning</dt><dd>Only used internally, prefer to use <a class="el" href="classne_1_1ShaderLightArray.html#abf03e290231b8ccbf397735d8b5da41d">create</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td>Used renderer. </td></tr>
    <tr><td class="paramname">sShaderLightResourceName</td><td>Name of the resource (specified in shader code) that this array should bind to. </td></tr>
    <tr><td class="paramname">onSizeChanged</td><td>Callback that will be called after array's size changed with the current array size passed as the only argument. </td></tr>
    <tr><td class="paramname">optionalCallbackOnLightsInCameraFrustumCulled</td><td>If specified will be called after array of indices to lights in camera frustum changed (indices changed) with the current frame resource index as the only argument, otherwise (if empty) GPU resources for such array will not be created and this callback will never be called. </td></tr>
    <tr><td class="paramname">sIndicesLightsInFrustumShaderResourceName</td><td>If callback for culled lights in camera frustum is specified stores name of the shader resource used for the array of indices of non-culled lights. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf03e290231b8ccbf397735d8b5da41d" name="abf03e290231b8ccbf397735d8b5da41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf03e290231b8ccbf397735d8b5da41d">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderLightArray.html">ShaderLightArray</a> &gt; ne::ShaderLightArray::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderLightResourceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>onSizeChanged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::pair&lt; std::function&lt; void(size_t)&gt;, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>optionalOnLightsInCameraFrustumCulled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td>Used renderer. </td></tr>
    <tr><td class="paramname">sShaderLightResourceName</td><td>Name of the resource (specified in shader code) that this array should bind to. </td></tr>
    <tr><td class="paramname">onSizeChanged</td><td>Callback that will be called after array's size changed with the current array size passed as the only argument. </td></tr>
    <tr><td class="paramname">optionalOnLightsInCameraFrustumCulled</td><td>A pair of callback and shader resource name that are used for array that stores indices of light sources in camera's frustum. If specified the callback will be called after array of indices to lights in camera frustum changed (indices changed) with the current frame resource index as the only argument, otherwise (if empty) GPU resources for such array will not be created and this callback will never be called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created array. </dd></dl>

</div>
</div>
<a id="a3328662ff475820aae6c436b08ef8bc7" name="a3328662ff475820aae6c436b08ef8bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3328662ff475820aae6c436b08ef8bc7">&#9670;&#160;</a></span>freeSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ShaderLightArray::freeSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1ShaderLightArraySlot.html">ShaderLightArraySlot</a> *&#160;</td>
          <td class="paramname"><em>pSlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called by slot-objects to notify the array that a slot is no longer used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSlot</td><td>Slot that is being destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ebc69a64306d5c8018702d33c56f67a" name="a1ebc69a64306d5c8018702d33c56f67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebc69a64306d5c8018702d33c56f67a">&#9670;&#160;</a></span>getInternalResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1ShaderLightArray_1_1Resources.html">ShaderLightArray::Resources</a> &gt; * ne::ShaderLightArray::getInternalResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns internal resources of this array.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Generally used for tests (read-only), you should not modify them.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Internal resources. </dd></dl>

</div>
</div>
<a id="a1ba83acfc58436dcb6c7bb1d0e9dcc41" name="a1ba83acfc58436dcb6c7bb1d0e9dcc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba83acfc58436dcb6c7bb1d0e9dcc41">&#9670;&#160;</a></span>getShaderResourceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::ShaderLightArray::getShaderResourceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns name of the resource (specified in shader code) that this array is binded to.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Shader.html">Shader</a> resource name. </dd></dl>

</div>
</div>
<a id="a3a1ca46441de4fdd45cb53339968fecb" name="a3a1ca46441de4fdd45cb53339968fecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1ca46441de4fdd45cb53339968fecb">&#9670;&#160;</a></span>markSlotAsNeedsUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ShaderLightArray::markSlotAsNeedsUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1ShaderLightArraySlot.html">ShaderLightArraySlot</a> *&#160;</td>
          <td class="paramname"><em>pSlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Queues the specified slot's data to be updated later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSlot</td><td>Slot to update later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d9f5f3d4916adb095077b84dccad0a" name="a47d9f5f3d4916adb095077b84dccad0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d9f5f3d4916adb095077b84dccad0a">&#9670;&#160;</a></span>onLightsInCameraFrustumCulled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ShaderLightArray::onLightsInCameraFrustumCulled </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after the renderer culls lights (so that indices of lights sources in camera's frustum change) to copy the new (modified) data to the GPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the frame resource that will be used to submit the next frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a545c6de44ae5674b637ddc849599c8ba" name="a545c6de44ae5674b637ddc849599c8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545c6de44ae5674b637ddc849599c8ba">&#9670;&#160;</a></span>recreateArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ShaderLightArray::recreateArray </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsInitialization</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >(Re)creates GPU resources to hold the current number of active slots and updates all previously existing slots.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIsInitialization</td><td><code>true</code> if we are creating resources for the first time and there are no active slots at the moment but since we need valid (non <code>nullptr</code> resources) we will create resources that will hold 1 slot, <code>false</code> otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="aae70b6d70f55db9c6a6c7e6a4e79813c" name="aae70b6d70f55db9c6a6c7e6a4e79813c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae70b6d70f55db9c6a6c7e6a4e79813c">&#9670;&#160;</a></span>reserveNewSlot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderLightArraySlot.html">ShaderLightArraySlot</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ShaderLightArray::reserveNewSlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>pSpawnedOwnerLightNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iDataSizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void *()&gt; &amp;&#160;</td>
          <td class="paramname"><em>startUpdateCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>finishUpdateCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reserves a new slot in the array to store some data.</p>
<dl class="section remark"><dt>Remarks</dt><dd>While you hold the returned slot-object (and while it's not destroyed), it can call update callbacks at any time.</dd>
<dd>
Update callbacks will be called inside of this function to copy the initial data.</dd>
<dd>
If you mark your slot as "needs update" callbacks may be called multiple times (this is perfectly fine, just don't rely on your callbacks being called only once).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpawnedOwnerLightNode</td><td>Spawned light node that requests the slot. Used for light culling. </td></tr>
    <tr><td class="paramname">iDataSizeInBytes</td><td>Size of the data that you want to store in the slot in bytes. </td></tr>
    <tr><td class="paramname">startUpdateCallback</td><td>Callback that will be called after you mark your slot as "needs
update" when the engine is ready to copy the data to the GPU. You must return a pointer which data will be copied. </td></tr>
    <tr><td class="paramname">finishUpdateCallback</td><td>Callback that will be called after the copying of your new data is finished.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise reserved slot. </dd></dl>

</div>
</div>
<a id="a0ab06a0a73281fe8a8c3a55f3dac39fe" name="a0ab06a0a73281fe8a8c3a55f3dac39fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab06a0a73281fe8a8c3a55f3dac39fe">&#9670;&#160;</a></span>updateBindingsInAllPipelines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ShaderLightArray::updateBindingsInAllPipelines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Binds the underlying GPU resource to descriptors of pipelines that use this array in shaders.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Does nothing if DirectX renderer is used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a9c45a8a69b61832fb3563a00baa685c9" name="a9c45a8a69b61832fb3563a00baa685c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c45a8a69b61832fb3563a00baa685c9">&#9670;&#160;</a></span>updatePipelineBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ShaderLightArray::updatePipelineBinding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *&#160;</td>
          <td class="paramname"><em>pPipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Binds the underlying GPU resource to the specified pipeline's descriptor (if this pipeline's shaders use this array, otherwise return empty).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Does nothing if DirectX renderer is used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPipeline</td><td><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> to bind to / rebind to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a57ff63eebae0040b8a82ced015c22662" name="a57ff63eebae0040b8a82ced015c22662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ff63eebae0040b8a82ced015c22662">&#9670;&#160;</a></span>updateSlotsMarkedAsNeedsUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ShaderLightArray::updateSlotsMarkedAsNeedsUpdate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Goes through all slots that are marked as "needs update" and copies their new data to the GPU resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the frame resource that will be used to submit the next frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acc4c669a2419d42c01c780d5c7ce9484" name="acc4c669a2419d42c01c780d5c7ce9484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4c669a2419d42c01c780d5c7ce9484">&#9670;&#160;</a></span>iElementSizeInBytes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::ShaderLightArray::iElementSizeInBytes = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Size of one array element in bytes. </p>

</div>
</div>
<a id="a15f7189a54f5809dcc61dbd61eb8bb39" name="a15f7189a54f5809dcc61dbd61eb8bb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f7189a54f5809dcc61dbd61eb8bb39">&#9670;&#160;</a></span>mtxResources</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1ShaderLightArray_1_1Resources.html">Resources</a>&gt; ne::ShaderLightArray::mtxResources</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Internal data. </p>

</div>
</div>
<a id="acb1cd03348735f995151cca2af72dc35" name="acb1cd03348735f995151cca2af72dc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1cd03348735f995151cca2af72dc35">&#9670;&#160;</a></span>onSizeChanged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void(size_t)&gt; ne::ShaderLightArray::onSizeChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Callback that will be called after array's size changed with the current array size passed as the only argument. </p>

</div>
</div>
<a id="a61485718d7dc7043ba990c7eec6beed1" name="a61485718d7dc7043ba990c7eec6beed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61485718d7dc7043ba990c7eec6beed1">&#9670;&#160;</a></span>optionalCallbackOnLightsInCameraFrustumCulled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::optional&lt;std::function&lt;void(size_t)&gt; &gt; ne::ShaderLightArray::optionalCallbackOnLightsInCameraFrustumCulled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If specified will be called after array of indices to lights in camera frustum changed (indices changed) with the current frame resource index as the only argument, otherwise (if empty) GPU resources for such array will not be created and this callback will never be called. </p>

</div>
</div>
<a id="aa20bb571bf72d18efd48b3c7cc5d540f" name="aa20bb571bf72d18efd48b3c7cc5d540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20bb571bf72d18efd48b3c7cc5d540f">&#9670;&#160;</a></span>pRenderer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Renderer.html">Renderer</a>* ne::ShaderLightArray::pRenderer = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Used renderer. </p>

</div>
</div>
<a id="ae2f84853d5b089acaa0c88910c6bb470" name="ae2f84853d5b089acaa0c88910c6bb470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f84853d5b089acaa0c88910c6bb470">&#9670;&#160;</a></span>sShaderLightResourceName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string ne::ShaderLightArray::sShaderLightResourceName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the resource (specified in shader code) that this array should bind to. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/private/shader/general/resource/<a class="el" href="ShaderLightArray_8h_source.html">ShaderLightArray.h</a></li>
<li>src/engine_lib/private/shader/general/resource/ShaderLightArray.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1ShaderLightArray.html">ShaderLightArray</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
