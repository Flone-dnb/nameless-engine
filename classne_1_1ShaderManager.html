<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::ShaderManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1ShaderManager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1ShaderManager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::ShaderManager Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ShaderManager_8h_source.html">ShaderManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1ShaderManager_1_1ShaderData.html">ShaderData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b7db57803fdfd091373e3efc2a23808"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a7b7db57803fdfd091373e3efc2a23808">ShaderManager</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *<a class="el" href="classne_1_1ShaderManager.html#a7cd027c36ca5f4e81f04ee3c66adedde">pRenderer</a>)</td></tr>
<tr class="separator:a7b7db57803fdfd091373e3efc2a23808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39848297e61b1ac36195fcc1dae94c1a"><td class="memItemLeft" align="right" valign="top"><a id="a39848297e61b1ac36195fcc1dae94c1a" name="a39848297e61b1ac36195fcc1dae94c1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderManager</b> (const <a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a> &amp;)=delete</td></tr>
<tr class="separator:a39848297e61b1ac36195fcc1dae94c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11f64e732ded046495bc443dd24bc25"><td class="memItemLeft" align="right" valign="top"><a id="ad11f64e732ded046495bc443dd24bc25" name="ad11f64e732ded046495bc443dd24bc25"></a>
<a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a> &amp;)=delete</td></tr>
<tr class="separator:ad11f64e732ded046495bc443dd24bc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2166c0698051cb43ba0b44dd1e6536"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">compileShaders</a> (std::vector&lt; <a class="el" href="structne_1_1ShaderDescription.html">ShaderDescription</a> &gt; vShadersToCompile, const std::function&lt; void(size_t iCompiledShaderCount, size_t iTotalShadersToCompile)&gt; &amp;onProgress, const std::function&lt; void(<a class="el" href="structne_1_1ShaderDescription.html">ShaderDescription</a> shaderDescription, std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; error)&gt; &amp;onError, const std::function&lt; void()&gt; &amp;onCompleted)</td></tr>
<tr class="separator:a8d2166c0698051cb43ba0b44dd1e6536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87aa310492aa04059696943383403f7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a87aa310492aa04059696943383403f7f">isShaderNameCanBeUsed</a> (const std::string &amp;sShaderName)</td></tr>
<tr class="separator:a87aa310492aa04059696943383403f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005b1de2299a6257502f772992ab52b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a005b1de2299a6257502f772992ab52b5">markShaderToBeRemoved</a> (const std::string &amp;sShaderName)</td></tr>
<tr class="separator:a005b1de2299a6257502f772992ab52b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09beef22fcf157936533b5b7a8e62ac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a09beef22fcf157936533b5b7a8e62ac6">performSelfValidation</a> ()</td></tr>
<tr class="separator:a09beef22fcf157936533b5b7a8e62ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a435cd6d65d44e573a745f15f3172102a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a435cd6d65d44e573a745f15f3172102a">compileShaderTask</a> (size_t iQueryId, const std::shared_ptr&lt; std::atomic&lt; size_t &gt; &gt; &amp;pCompiledShaderCount, size_t iTotalShaderCount, <a class="el" href="structne_1_1ShaderDescription.html">ShaderDescription</a> shaderDescription, const std::function&lt; void(size_t iCompiledShaderCount, size_t iTotalShadersToCompile)&gt; &amp;onProgress, const std::function&lt; void(<a class="el" href="structne_1_1ShaderDescription.html">ShaderDescription</a> shaderDescription, std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; error)&gt; &amp;onError, const std::function&lt; void()&gt; &amp;onCompleted)</td></tr>
<tr class="separator:a435cd6d65d44e573a745f15f3172102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e06a6661d97629ce2b0bfed110e6ea"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classne_1_1ShaderPack.html">ShaderPack</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a65e06a6661d97629ce2b0bfed110e6ea">findShader</a> (const std::string &amp;sShaderName)</td></tr>
<tr class="separator:a65e06a6661d97629ce2b0bfed110e6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac605a789b555ca9fa5a267e258ec4143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#ac605a789b555ca9fa5a267e258ec4143">releaseShaderBytecodeIfNotUsed</a> (const std::string &amp;sShaderName)</td></tr>
<tr class="separator:ac605a789b555ca9fa5a267e258ec4143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac23eeac24f3692764f9bb9592441c50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#aac23eeac24f3692764f9bb9592441c50">removeShaderIfMarkedToBeRemoved</a> (const std::string &amp;sShaderName)</td></tr>
<tr class="separator:aac23eeac24f3692764f9bb9592441c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a1e41b8eccc56ef48163f4d5bbd09c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#ae5a1e41b8eccc56ef48163f4d5bbd09c">refreshShaderCache</a> ()</td></tr>
<tr class="separator:ae5a1e41b8eccc56ef48163f4d5bbd09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1df76e59cacdb2d3f2e3c480ad78a7f4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classne_1_1ShaderCacheManager.html">ShaderCacheManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a1df76e59cacdb2d3f2e3c480ad78a7f4">pShaderCacheManager</a></td></tr>
<tr class="separator:a1df76e59cacdb2d3f2e3c480ad78a7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab348a57a97036ac786b40b061cc6e307"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1ShaderManager_1_1ShaderData.html">ShaderData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#ab348a57a97036ac786b40b061cc6e307">mtxShaderData</a></td></tr>
<tr class="separator:ab348a57a97036ac786b40b061cc6e307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7f0bf39c48d5471354b19b0327289a"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a5d7f0bf39c48d5471354b19b0327289a">iTotalCompileShadersQueries</a> = 0</td></tr>
<tr class="separator:a5d7f0bf39c48d5471354b19b0327289a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd027c36ca5f4e81f04ee3c66adedde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a7cd027c36ca5f4e81f04ee3c66adedde">pRenderer</a> = nullptr</td></tr>
<tr class="separator:a7cd027c36ca5f4e81f04ee3c66adedde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a539c5b65b2158cab00f5161e9c3b9663"><td class="memItemLeft" align="right" valign="top">static const std::array&lt; char, 65 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a539c5b65b2158cab00f5161e9c3b9663">vValidCharactersForShaderName</a></td></tr>
<tr class="separator:a539c5b65b2158cab00f5161e9c3b9663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b2d9ff0bf54dd02457e394a373e583"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1ShaderManager.html#a43b2d9ff0bf54dd02457e394a373e583">iMaximumShaderNameLength</a> = 40</td></tr>
<tr class="separator:a43b2d9ff0bf54dd02457e394a373e583"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac77335d32da336628fddabe06a069197"><td class="memItemLeft" align="right" valign="top"><a id="ac77335d32da336628fddabe06a069197" name="ac77335d32da336628fddabe06a069197"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ShaderUser</b></td></tr>
<tr class="separator:ac77335d32da336628fddabe06a069197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70538530bc36e033e360880ef311df61"><td class="memItemLeft" align="right" valign="top"><a id="a70538530bc36e033e360880ef311df61" name="a70538530bc36e033e360880ef311df61"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Renderer</b></td></tr>
<tr class="separator:a70538530bc36e033e360880ef311df61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Handles shader compilation and controls shader registry. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7b7db57803fdfd091373e3efc2a23808" name="a7b7db57803fdfd091373e3efc2a23808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7db57803fdfd091373e3efc2a23808">&#9670;&#160;</a></span>ShaderManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::ShaderManager::ShaderManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td>Parent renderer that uses this shader manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d2166c0698051cb43ba0b44dd1e6536" name="a8d2166c0698051cb43ba0b44dd1e6536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2166c0698051cb43ba0b44dd1e6536">&#9670;&#160;</a></span>compileShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ShaderManager::compileShaders </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structne_1_1ShaderDescription.html">ShaderDescription</a> &gt;&#160;</td>
          <td class="paramname"><em>vShadersToCompile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t iCompiledShaderCount, size_t iTotalShadersToCompile)&gt; &amp;&#160;</td>
          <td class="paramname"><em>onProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="structne_1_1ShaderDescription.html">ShaderDescription</a> shaderDescription, std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; error)&gt; &amp;&#160;</td>
          <td class="paramname"><em>onError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>onCompleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add shaders to be asynchronously compiled.</p>
<p >Compiled shaders are stored on disk, when a shader is needed it will be automatically loaded from disk into memory and when no longer being used it will be released from memory (stored on disk again).</p>
<dl class="section remark"><dt>Remarks</dt><dd>If a shader was already compiled previously compilation results will be stored in the shader cache on the disk and if the cache is currently valid (for ex. shader source file has not changed, included shader source files also not changed, defined shader macros not changed, build configuration not changed and etc.), shader compilation will be skipped and instead the shader will be loaded from the cache (which is faster than compiling the shader).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vShadersToCompile</td><td>Array of shaders to compile. Use <a class="el" href="classne_1_1ShaderManager.html#a87aa310492aa04059696943383403f7f">isShaderNameCanBeUsed</a> to check if a shader name is free (unique). </td></tr>
    <tr><td class="paramname">onProgress</td><td>Callback function that will be called when each shader is compiled. This will also be called when all shaders are compiled (together with 'onCompleted'). The first argument is number of compiled shaders and the second one is total number of shaders to compile. </td></tr>
    <tr><td class="paramname">onError</td><td>Callback function that will be called if an error occurred. This might be one of the two things: shader compilation error/warning (shader contains error) or internal error (engine failed to compile shader). If there was a shader compilation error/warning, this shader will be marked as processed and onProgress will be called (but this shader will not be added to shader manager and will not be available, you will need to fix the error and add this shader again). </td></tr>
    <tr><td class="paramname">onCompleted</td><td>Callback function that will be called once all shaders are compiled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note that all callback functions will be queued to be executed on the main thread and will be called later from the main thread before next frame is rendered. Because callbacks are called from the main thread it's safe to call functions that are marked as "should only be called from the main thread" from the callback functions. If you are using member functions as callbacks you need to make sure that the owner object of these member functions will not be deleted until onCompleted is called.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An error if something went wrong. </dd></dl>

</div>
</div>
<a id="a435cd6d65d44e573a745f15f3172102a" name="a435cd6d65d44e573a745f15f3172102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435cd6d65d44e573a745f15f3172102a">&#9670;&#160;</a></span>compileShaderTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ShaderManager::compileShaderTask </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iQueryId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; std::atomic&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pCompiledShaderCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iTotalShaderCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structne_1_1ShaderDescription.html">ShaderDescription</a>&#160;</td>
          <td class="paramname"><em>shaderDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t iCompiledShaderCount, size_t iTotalShadersToCompile)&gt; &amp;&#160;</td>
          <td class="paramname"><em>onProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="structne_1_1ShaderDescription.html">ShaderDescription</a> shaderDescription, std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; error)&gt; &amp;&#160;</td>
          <td class="paramname"><em>onError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>onCompleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compiles each shader. Executed as a thread pooled task to do this work asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iQueryId</td><td>Unique number used to differentiate different calls <a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">compileShaders</a>. </td></tr>
    <tr><td class="paramname">pCompiledShaderCount</td><td>Current total number of shaders compiled (in query). </td></tr>
    <tr><td class="paramname">iTotalShaderCount</td><td>Total number of shaders to compile in this query (might be bigger than the size of the vShadersToCompile argument because the query is divided in smaller tasks). </td></tr>
    <tr><td class="paramname">shaderDescription</td><td><a class="el" href="classne_1_1Shader.html">Shader</a> to compile. </td></tr>
    <tr><td class="paramname">onProgress</td><td>Callback function that will be called when each shader is compiled. This will also be called when all shaders are compiled (together with 'onCompleted'). The first argument is number of compiled shaders and the second one is total number of shaders to compile. </td></tr>
    <tr><td class="paramname">onError</td><td>Callback function that will be called if an error occurred. This might be one of the two things: shader compilation error/warning (shader contains error) or internal error (engine failed somewhere). If there was a shader compilation error/warning, this shader will be marked as processed and onProgress will be called (but this shader will not be added to shader manager and will not be available, use will need to fix the error and add this shader again). </td></tr>
    <tr><td class="paramname">onCompleted</td><td>Callback function that will be called once all shaders are compiled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65e06a6661d97629ce2b0bfed110e6ea" name="a65e06a6661d97629ce2b0bfed110e6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e06a6661d97629ce2b0bfed110e6ea">&#9670;&#160;</a></span>findShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classne_1_1ShaderPack.html">ShaderPack</a> &gt; ne::ShaderManager::findShader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Should only be called by <a class="el" href="classne_1_1ShaderUser.html">ShaderUser</a> class.</dd></dl>
<p>Returns compiled shader (compiled using <a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">compileShaders</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderName</td><td>Name of this shader.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if the shader with the specified name was not found, valid pointer otherwise. </dd></dl>

</div>
</div>
<a id="a87aa310492aa04059696943383403f7f" name="a87aa310492aa04059696943383403f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87aa310492aa04059696943383403f7f">&#9670;&#160;</a></span>isShaderNameCanBeUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::ShaderManager::isShaderNameCanBeUsed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the shader name is free (no shader with this name found) to be used in <a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">compileShaders</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderName</td><td>Name to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if can be used (no shader with this name found), <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a005b1de2299a6257502f772992ab52b5" name="a005b1de2299a6257502f772992ab52b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005b1de2299a6257502f772992ab52b5">&#9670;&#160;</a></span>markShaderToBeRemoved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::ShaderManager::markShaderToBeRemoved </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the shader if nobody is referencing it, otherwise marks shader to be removed later.</p>
<p >Typically you would not use this function as we expect you to make one call to <a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">compileShaders</a> in the beginning of the game to compile ALL of your shaders (for all levels) and never remove them as compiled shaders are not stored in memory, they are stored on disk and when actually needed/used loaded from disk to memory. If some shader was used but no longer needed it will be released from memory until someone will need it again.</p>
<p >If somebody is still referencing this shader, the shader will be added to "to remove" array and will be removed later when nobody is referencing this shader (specifically when only one std::shared_ptr&lt;Shader&gt; instance pointing to this shader will exist (it will exist in <a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a> as <a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a> stores pointer to each shader)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderName</td><td><a class="el" href="classne_1_1Shader.html">Shader</a> name to be marked for removal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'true' if someone is still referencing this shader and it cannot be removed right now, thus shader's name still cannot be used in <a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">compileShaders</a>. Returns 'false' if nobody was referencing this shader and it was removed, thus shader's name can now be used in <a class="el" href="classne_1_1ShaderManager.html#a8d2166c0698051cb43ba0b44dd1e6536">compileShaders</a>. </dd></dl>

</div>
</div>
<a id="a09beef22fcf157936533b5b7a8e62ac6" name="a09beef22fcf157936533b5b7a8e62ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09beef22fcf157936533b5b7a8e62ac6">&#9670;&#160;</a></span>performSelfValidation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ShaderManager::performSelfValidation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Analyzes the current state to see if any shader-related errors have place (like unused shaders in memory or etc.). Fixes errors and reports them in log. </p>

</div>
</div>
<a id="ae5a1e41b8eccc56ef48163f4d5bbd09c" name="ae5a1e41b8eccc56ef48163f4d5bbd09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a1e41b8eccc56ef48163f4d5bbd09c">&#9670;&#160;</a></span>refreshShaderCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::ShaderManager::refreshShaderCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Looks if any of the global shader cache parameters changed (such as build mode, shader model, etc.), clears shader cache directory and creates a fresh new shader cache directory with up to date info.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If no global shader cache metadata file existed it will create it.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An error if something went wrong. </dd></dl>

</div>
</div>
<a id="ac605a789b555ca9fa5a267e258ec4143" name="ac605a789b555ca9fa5a267e258ec4143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac605a789b555ca9fa5a267e258ec4143">&#9670;&#160;</a></span>releaseShaderBytecodeIfNotUsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ShaderManager::releaseShaderBytecodeIfNotUsed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Looks if the specified shader is not used by anyone and releases shader bytecode from memory if it was previously loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderName</td><td>Name of the shader to release bytecode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac23eeac24f3692764f9bb9592441c50" name="aac23eeac24f3692764f9bb9592441c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac23eeac24f3692764f9bb9592441c50">&#9670;&#160;</a></span>removeShaderIfMarkedToBeRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::ShaderManager::removeShaderIfMarkedToBeRemoved </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sShaderName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Looks if this shader was marked "to be removed" and that it's not being used by anyone else, if this is correct removes the shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sShaderName</td><td>Name of the shader to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a43b2d9ff0bf54dd02457e394a373e583" name="a43b2d9ff0bf54dd02457e394a373e583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b2d9ff0bf54dd02457e394a373e583">&#9670;&#160;</a></span>iMaximumShaderNameLength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ne::ShaderManager::iMaximumShaderNameLength = 40</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Maximum length of a shader name. </p>

</div>
</div>
<a id="a5d7f0bf39c48d5471354b19b0327289a" name="a5d7f0bf39c48d5471354b19b0327289a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7f0bf39c48d5471354b19b0327289a">&#9670;&#160;</a></span>iTotalCompileShadersQueries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;size_t&gt; ne::ShaderManager::iTotalCompileShadersQueries = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Total number of "compile shaders" queries. Used to differentiate calls to <a class="el" href="classne_1_1ShaderManager.html#a435cd6d65d44e573a745f15f3172102a">compileShaderTask</a>. </p>

</div>
</div>
<a id="ab348a57a97036ac786b40b061cc6e307" name="ab348a57a97036ac786b40b061cc6e307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab348a57a97036ac786b40b061cc6e307">&#9670;&#160;</a></span>mtxShaderData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1ShaderManager_1_1ShaderData.html">ShaderData</a>&gt; ne::ShaderManager::mtxShaderData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Internal shader data guarded by mutex. </p>

</div>
</div>
<a id="a7cd027c36ca5f4e81f04ee3c66adedde" name="a7cd027c36ca5f4e81f04ee3c66adedde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd027c36ca5f4e81f04ee3c66adedde">&#9670;&#160;</a></span>pRenderer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1Renderer.html">Renderer</a>* const ne::ShaderManager::pRenderer = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Do not delete. Parent renderer that uses this shader manager. </p>

</div>
</div>
<a id="a1df76e59cacdb2d3f2e3c480ad78a7f4" name="a1df76e59cacdb2d3f2e3c480ad78a7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df76e59cacdb2d3f2e3c480ad78a7f4">&#9670;&#160;</a></span>pShaderCacheManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classne_1_1ShaderCacheManager.html">ShaderCacheManager</a>&gt; ne::ShaderManager::pShaderCacheManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Handles everything related to shader cache. </p>

</div>
</div>
<a id="a539c5b65b2158cab00f5161e9c3b9663" name="a539c5b65b2158cab00f5161e9c3b9663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539c5b65b2158cab00f5161e9c3b9663">&#9670;&#160;</a></span>vValidCharactersForShaderName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;char, 65&gt; ne::ShaderManager::vValidCharactersForShaderName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">            <span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;B&#39;</span>, <span class="charliteral">&#39;C&#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39;E&#39;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="charliteral">&#39;G&#39;</span>, <span class="charliteral">&#39;H&#39;</span>, <span class="charliteral">&#39;I&#39;</span>, <span class="charliteral">&#39;J&#39;</span>, <span class="charliteral">&#39;K&#39;</span>, <span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;O&#39;</span>, <span class="charliteral">&#39;P&#39;</span>, <span class="charliteral">&#39;Q&#39;</span>,</div>
<div class="line">            <span class="charliteral">&#39;R&#39;</span>, <span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;T&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, <span class="charliteral">&#39;V&#39;</span>, <span class="charliteral">&#39;W&#39;</span>, <span class="charliteral">&#39;X&#39;</span>, <span class="charliteral">&#39;Y&#39;</span>, <span class="charliteral">&#39;Z&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;f&#39;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;h&#39;</span>,</div>
<div class="line">            <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;j&#39;</span>, <span class="charliteral">&#39;k&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="charliteral">&#39;q&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;w&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>,</div>
<div class="line">            <span class="charliteral">&#39;z&#39;</span>, <span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;4&#39;</span>, <span class="charliteral">&#39;5&#39;</span>, <span class="charliteral">&#39;6&#39;</span>, <span class="charliteral">&#39;7&#39;</span>, <span class="charliteral">&#39;8&#39;</span>, <span class="charliteral">&#39;9&#39;</span>, <span class="charliteral">&#39;.&#39;</span>, <span class="charliteral">&#39;_&#39;</span>, <span class="charliteral">&#39;-&#39;</span>}</div>
</div><!-- fragment --><p >Array of characters that can be used for shader name. We limit amount of valid characters because we store compiled shaders on disk and different filesystems have different limitations for file names. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/public/shader/<a class="el" href="ShaderManager_8h_source.html">ShaderManager.h</a></li>
<li>src/engine_lib/private/shader/general/ShaderManager.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
