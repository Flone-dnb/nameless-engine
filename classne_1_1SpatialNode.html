<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::SpatialNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1SpatialNode.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classne_1_1SpatialNode-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::SpatialNode Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="SpatialNode_8h_source.html">SpatialNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::SpatialNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1SpatialNode.png" usemap="#ne::SpatialNode_map" alt=""/>
  <map id="ne::SpatialNode_map" name="ne::SpatialNode_map">
<area href="classne_1_1Node.html" alt="ne::Node" shape="rect" coords="320,112,470,136"/>
<area href="classne_1_1Serializable.html" alt="ne::Serializable" shape="rect" coords="320,56,470,80"/>
<area href="classne_1_1CameraNode.html" alt="ne::CameraNode" shape="rect" coords="0,224,150,248"/>
<area href="classne_1_1DirectionalLightNode.html" alt="ne::DirectionalLightNode" shape="rect" coords="160,224,310,248"/>
<area href="classne_1_1MeshNode.html" alt="ne::MeshNode" shape="rect" coords="320,224,470,248"/>
<area href="classne_1_1PointLightNode.html" alt="ne::PointLightNode" shape="rect" coords="480,224,630,248"/>
<area href="classne_1_1SpotlightNode.html" alt="ne::SpotlightNode" shape="rect" coords="640,224,790,248"/>
<area href="classne_1_1EditorCameraNode.html" alt="ne::EditorCameraNode" shape="rect" coords="0,280,150,304"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1SpatialNode_1_1LocalSpaceInformation.html">LocalSpaceInformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1SpatialNode_1_1WorldMatrixInformation.html">WorldMatrixInformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac02b39a7177a89acf9613d4b1bb9f203"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#ac02b39a7177a89acf9613d4b1bb9f203">SpatialNode</a> (const std::string &amp;<a class="el" href="classne_1_1Node.html#abf5d0aa8bddaf3927e80dddb787fbe26">sNodeName</a>)</td></tr>
<tr class="separator:ac02b39a7177a89acf9613d4b1bb9f203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d5413bbb88c9b259e8e9e48a271ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a15d5413bbb88c9b259e8e9e48a271ab6">setRelativeLocation</a> (const glm::vec3 &amp;location)</td></tr>
<tr class="separator:a15d5413bbb88c9b259e8e9e48a271ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32914b6236f0d2675736be0f1ea1cac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a32914b6236f0d2675736be0f1ea1cac2">setRelativeRotation</a> (const glm::vec3 &amp;rotation)</td></tr>
<tr class="separator:a32914b6236f0d2675736be0f1ea1cac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf859b09995cfac54203d12d5527627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aecf859b09995cfac54203d12d5527627">setRelativeScale</a> (const glm::vec3 &amp;scale)</td></tr>
<tr class="separator:aecf859b09995cfac54203d12d5527627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5505c98b284aaf4037e8bf2e31305f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a5505c98b284aaf4037e8bf2e31305f2b">setWorldLocation</a> (const glm::vec3 &amp;location)</td></tr>
<tr class="separator:a5505c98b284aaf4037e8bf2e31305f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2f513f7406d324c9927af5fec07c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#afb2f513f7406d324c9927af5fec07c26">setWorldRotation</a> (const glm::vec3 &amp;rotation)</td></tr>
<tr class="separator:afb2f513f7406d324c9927af5fec07c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c51087d2b8e3bd43ca218de57a7cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a95c51087d2b8e3bd43ca218de57a7cca">setWorldScale</a> (const glm::vec3 &amp;scale)</td></tr>
<tr class="separator:a95c51087d2b8e3bd43ca218de57a7cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb558a9f20e9501a3d8a4b0f4a769f2c"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aeb558a9f20e9501a3d8a4b0f4a769f2c">getRelativeLocation</a> () const</td></tr>
<tr class="separator:aeb558a9f20e9501a3d8a4b0f4a769f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ebb64994069549f09f5148d890fb9"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a277ebb64994069549f09f5148d890fb9">getRelativeRotation</a> () const</td></tr>
<tr class="separator:a277ebb64994069549f09f5148d890fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b030ce699a74fd273d64affd7c34963"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a2b030ce699a74fd273d64affd7c34963">getRelativeScale</a> () const</td></tr>
<tr class="separator:a2b030ce699a74fd273d64affd7c34963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e2381f0d40f43e050cfa9ac2c2d9fa"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a50e2381f0d40f43e050cfa9ac2c2d9fa">getRelativeRotationMatrix</a> ()</td></tr>
<tr class="separator:a50e2381f0d40f43e050cfa9ac2c2d9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd42888d6bb7d5ff7e82bd61ed8f8c2"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#acbd42888d6bb7d5ff7e82bd61ed8f8c2">getWorldLocation</a> ()</td></tr>
<tr class="separator:acbd42888d6bb7d5ff7e82bd61ed8f8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c06e3d090b282f172c0978c8ddeb17"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#af1c06e3d090b282f172c0978c8ddeb17">getWorldRotation</a> ()</td></tr>
<tr class="separator:af1c06e3d090b282f172c0978c8ddeb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e77c912ebf8f0877addcee649fdffe1"><td class="memItemLeft" align="right" valign="top">glm::quat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a9e77c912ebf8f0877addcee649fdffe1">getWorldRotationQuaternion</a> ()</td></tr>
<tr class="separator:a9e77c912ebf8f0877addcee649fdffe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac522941554b6f4f97f5eb1a2e29d31a"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aac522941554b6f4f97f5eb1a2e29d31a">getWorldScale</a> ()</td></tr>
<tr class="separator:aac522941554b6f4f97f5eb1a2e29d31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bba3a225a35cd40d5f04c98506aa4e"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#ac8bba3a225a35cd40d5f04c98506aa4e">getWorldForwardDirection</a> ()</td></tr>
<tr class="separator:ac8bba3a225a35cd40d5f04c98506aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2594545f207a1a4972eade6172cca66c"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a2594545f207a1a4972eade6172cca66c">getWorldRightDirection</a> ()</td></tr>
<tr class="separator:a2594545f207a1a4972eade6172cca66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95209d6c7572ee121505191652ed529b"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a95209d6c7572ee121505191652ed529b">getWorldUpDirection</a> ()</td></tr>
<tr class="separator:a95209d6c7572ee121505191652ed529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9becf3737c72d57008bbc87d37aea546"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a9becf3737c72d57008bbc87d37aea546">getWorldMatrix</a> ()</td></tr>
<tr class="separator:a9becf3737c72d57008bbc87d37aea546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa361d4f17cb0cac78ad7f4b1f33d2c05"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aa361d4f17cb0cac78ad7f4b1f33d2c05">getClosestSpatialParent</a> ()</td></tr>
<tr class="separator:aa361d4f17cb0cac78ad7f4b1f33d2c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1Node.html">ne::Node</a></td></tr>
<tr class="memitem:a869b03190702ccef1f85bad536bf1a4b inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a869b03190702ccef1f85bad536bf1a4b">Node</a> ()</td></tr>
<tr class="separator:a869b03190702ccef1f85bad536bf1a4b inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e8ff8b016048cb83b9bbfbe822a7e7 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a21e8ff8b016048cb83b9bbfbe822a7e7">Node</a> (const std::string &amp;sName)</td></tr>
<tr class="separator:a21e8ff8b016048cb83b9bbfbe822a7e7 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099cb0edca54481c58a99389d2f983bf inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a099cb0edca54481c58a99389d2f983bf" name="a099cb0edca54481c58a99389d2f983bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (const <a class="el" href="classne_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:a099cb0edca54481c58a99389d2f983bf inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09610eec6599d25609c9c6c383ee49c0 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a09610eec6599d25609c9c6c383ee49c0" name="a09610eec6599d25609c9c6c383ee49c0"></a>
<a class="el" href="classne_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1Node.html">Node</a> &amp;)=delete</td></tr>
<tr class="separator:a09610eec6599d25609c9c6c383ee49c0 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab095a12cd5b7f615b096e7d3db219c1b inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="ab095a12cd5b7f615b096e7d3db219c1b" name="ab095a12cd5b7f615b096e7d3db219c1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b> (<a class="el" href="classne_1_1Node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab095a12cd5b7f615b096e7d3db219c1b inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee6453dd5914d7250770af98e59a5eb inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a id="a3ee6453dd5914d7250770af98e59a5eb" name="a3ee6453dd5914d7250770af98e59a5eb"></a>
<a class="el" href="classne_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classne_1_1Node.html">Node</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3ee6453dd5914d7250770af98e59a5eb inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79642d37ba8f7a42e6bbb43285f8b0fb inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a79642d37ba8f7a42e6bbb43285f8b0fb">~Node</a> () override</td></tr>
<tr class="separator:a79642d37ba8f7a42e6bbb43285f8b0fb inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75cedd320fd643ad154bdceb4b0aad1 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa75cedd320fd643ad154bdceb4b0aad1">setNodeName</a> (const std::string &amp;sName)</td></tr>
<tr class="separator:aa75cedd320fd643ad154bdceb4b0aad1 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e2afe27909c7d87d39c048999ab190 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aa4e2afe27909c7d87d39c048999ab190">detachFromParentAndDespawn</a> ()</td></tr>
<tr class="separator:aa4e2afe27909c7d87d39c048999ab190 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a921f5e7fe4deb183e7910be557b1da inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a3a921f5e7fe4deb183e7910be557b1da">addChildNode</a> (const sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &amp;pNode, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> locationRule=AttachmentRule::KEEP_WORLD, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> rotationRule=AttachmentRule::KEEP_WORLD, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> scaleRule=AttachmentRule::KEEP_WORLD)</td></tr>
<tr class="separator:a3a921f5e7fe4deb183e7910be557b1da inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cb324f9de9b495f7bc223356540a44 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ad8cb324f9de9b495f7bc223356540a44">setSerialize</a> (bool <a class="el" href="classne_1_1Node.html#a7fe9ac405df914997905a4de2045c12b">bSerialize</a>)</td></tr>
<tr class="separator:ad8cb324f9de9b495f7bc223356540a44 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9b140812be7a938906e36f6e6188b inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a40e9b140812be7a938906e36f6e6188b">serializeNodeTree</a> (const std::filesystem::path &amp;pathToFile, bool bEnableBackup)</td></tr>
<tr class="separator:a40e9b140812be7a938906e36f6e6188b inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3b419efa656af7bf82b3e85532ceed inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aaf3b419efa656af7bf82b3e85532ceed">getNodeName</a> () const</td></tr>
<tr class="separator:aaf3b419efa656af7bf82b3e85532ceed inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470c2e53992a75304574a6c3c80a87d2 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a470c2e53992a75304574a6c3c80a87d2">getWorldRootNode</a> ()</td></tr>
<tr class="separator:a470c2e53992a75304574a6c3c80a87d2 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561de14810416e06b506a6c970c296e7 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a561de14810416e06b506a6c970c296e7">getParentNode</a> ()</td></tr>
<tr class="separator:a561de14810416e06b506a6c970c296e7 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874ddce54dfd82fcda801cb799bb1b85 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcVector&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a874ddce54dfd82fcda801cb799bb1b85">getChildNodes</a> ()</td></tr>
<tr class="separator:a874ddce54dfd82fcda801cb799bb1b85 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4ff3174738477037de125dff1a0707 inherit pub_methods_classne_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; <br />
requires std::derived_from&lt;NodeType, <a class="el" href="classne_1_1Node.html">Node</a>&gt;</td></tr>
<tr class="memitem:acc4ff3174738477037de125dff1a0707 inherit pub_methods_classne_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">sgc::GcPtr&lt; NodeType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#acc4ff3174738477037de125dff1a0707">getParentNodeOfType</a> (const std::string &amp;sParentNodeName=&quot;&quot;)</td></tr>
<tr class="separator:acc4ff3174738477037de125dff1a0707 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b03a7b88779e86fd7df6f158892c86b inherit pub_methods_classne_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; <br />
requires std::derived_from&lt;NodeType, <a class="el" href="classne_1_1Node.html">Node</a>&gt;</td></tr>
<tr class="memitem:a7b03a7b88779e86fd7df6f158892c86b inherit pub_methods_classne_1_1Node"><td class="memTemplItemLeft" align="right" valign="top">sgc::GcPtr&lt; NodeType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7b03a7b88779e86fd7df6f158892c86b">getChildNodeOfType</a> (const std::string &amp;sChildNodeName=&quot;&quot;)</td></tr>
<tr class="separator:a7b03a7b88779e86fd7df6f158892c86b inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5711513fe69f2771c6fc6bf84379768 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">TickGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ae5711513fe69f2771c6fc6bf84379768">getTickGroup</a> () const</td></tr>
<tr class="separator:ae5711513fe69f2771c6fc6bf84379768 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbae38dafd4765e9026028bd004b31c inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5cbae38dafd4765e9026028bd004b31c">getNodeId</a> () const</td></tr>
<tr class="separator:a5cbae38dafd4765e9026028bd004b31c inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0a06a7b62617e293529f2e0f89cd81 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#afe0a06a7b62617e293529f2e0f89cd81">isCalledEveryFrame</a> ()</td></tr>
<tr class="separator:afe0a06a7b62617e293529f2e0f89cd81 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab524a575030ca4f5a505c800680bcbb8 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab524a575030ca4f5a505c800680bcbb8">isReceivingInput</a> ()</td></tr>
<tr class="separator:ab524a575030ca4f5a505c800680bcbb8 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452b5f388d94b20c652ae661caca5fd inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab452b5f388d94b20c652ae661caca5fd">isSpawned</a> ()</td></tr>
<tr class="separator:ab452b5f388d94b20c652ae661caca5fd inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f66ab4ad5300e502fe964e8717f642 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab4f66ab4ad5300e502fe964e8717f642">isParentOf</a> (<a class="el" href="classne_1_1Node.html">Node</a> *pNode)</td></tr>
<tr class="separator:ab4f66ab4ad5300e502fe964e8717f642 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d48dcaa587589d0242d523d62bd9d27 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7d48dcaa587589d0242d523d62bd9d27">isChildOf</a> (<a class="el" href="classne_1_1Node.html">Node</a> *pNode)</td></tr>
<tr class="separator:a7d48dcaa587589d0242d523d62bd9d27 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0a97f3a5893d137ef01aa155426706 inherit pub_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#aca0a97f3a5893d137ef01aa155426706">isSerialized</a> () const</td></tr>
<tr class="separator:aca0a97f3a5893d137ef01aa155426706 inherit pub_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a2b1c9ee24ea69f0b6231eff5a262e348 inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a2b1c9ee24ea69f0b6231eff5a262e348">serialize</a> (std::filesystem::path pathToFile, bool bEnableBackup, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={})</td></tr>
<tr class="separator:a2b1c9ee24ea69f0b6231eff5a262e348 inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a79714019d1b40ce8d063b920bbdcf inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af0a79714019d1b40ce8d063b920bbdcf">serialize</a> (toml::value &amp;tomlData, const std::string &amp;sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:af0a79714019d1b40ce8d063b920bbdcf inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99dd41bee3fdcea40c80bf317cc590d inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#aa99dd41bee3fdcea40c80bf317cc590d">serialize</a> (toml::value &amp;tomlData, <a class="el" href="classne_1_1Serializable.html">Serializable</a> *pOriginalObject, std::string sEntityId=&quot;&quot;, const std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes={}, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={}, bool bEnableBackup=false)</td></tr>
<tr class="separator:aa99dd41bee3fdcea40c80bf317cc590d inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0404cdf34dc3fb25b7932a87ed9ade38 inherit pub_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a0404cdf34dc3fb25b7932a87ed9ade38">getPathDeserializedFromRelativeToRes</a> () const</td></tr>
<tr class="separator:a0404cdf34dc3fb25b7932a87ed9ade38 inherit pub_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4ef72e0c9e17fba2aeae88a87c424a84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a4ef72e0c9e17fba2aeae88a87c424a84">onAfterDeserialized</a> () override</td></tr>
<tr class="separator:a4ef72e0c9e17fba2aeae88a87c424a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af79f3d46f46b70636d67b70dab12d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a3af79f3d46f46b70636d67b70dab12d2">onSpawning</a> () override</td></tr>
<tr class="separator:a3af79f3d46f46b70636d67b70dab12d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae883c06ca2bc4bd917de5486cbbda0d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#ae883c06ca2bc4bd917de5486cbbda0d4">onAfterAttachedToNewParent</a> (bool bThisNodeBeingAttached) override</td></tr>
<tr class="separator:ae883c06ca2bc4bd917de5486cbbda0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf62ec87e7faeebafc764a2b71ae92b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#adf62ec87e7faeebafc764a2b71ae92b6">onWorldLocationRotationScaleChanged</a> ()</td></tr>
<tr class="separator:adf62ec87e7faeebafc764a2b71ae92b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classne_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classne_1_1Node')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classne_1_1Node.html">ne::Node</a></td></tr>
<tr class="memitem:a9294c7c58a8b4f85b7674c55751f4b13 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a9294c7c58a8b4f85b7674c55751f4b13">setIsCalledEveryFrame</a> (bool bEnable)</td></tr>
<tr class="separator:a9294c7c58a8b4f85b7674c55751f4b13 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138f69f892f8b80a89262b8a5f7625b8 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a138f69f892f8b80a89262b8a5f7625b8">setTickGroup</a> (TickGroup <a class="el" href="classne_1_1Node.html#aee673da17a5126031bbb957fa2833505">tickGroup</a>)</td></tr>
<tr class="separator:a138f69f892f8b80a89262b8a5f7625b8 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecdaaf48f89ae036a48ecb38d3ac382 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a8ecdaaf48f89ae036a48ecb38d3ac382">setIsReceivingInput</a> (bool bEnable)</td></tr>
<tr class="separator:a8ecdaaf48f89ae036a48ecb38d3ac382 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e80560b3b2f02be42285e60195f1b64 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Timer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a0e80560b3b2f02be42285e60195f1b64">createTimer</a> (const std::string &amp;sTimerName)</td></tr>
<tr class="separator:a0e80560b3b2f02be42285e60195f1b64 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2dca870a640ac24053a76b804ce111 inherit pro_methods_classne_1_1Node"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType &gt; </td></tr>
<tr class="memitem:a5f2dca870a640ac24053a76b804ce111 inherit pro_methods_classne_1_1Node"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classne_1_1NodeNotificationBroadcaster.html">NodeNotificationBroadcaster</a>&lt; FunctionType &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5f2dca870a640ac24053a76b804ce111">createNotificationBroadcaster</a> ()</td></tr>
<tr class="separator:a5f2dca870a640ac24053a76b804ce111 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77035ce347e8bf68b564b5358ef4b5cc inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, bool)&gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a77035ce347e8bf68b564b5358ef4b5cc">getActionEventBindings</a> ()</td></tr>
<tr class="separator:a77035ce347e8bf68b564b5358ef4b5cc inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062c7be217334d4bce02ce34c32e00cb inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, std::unordered_map&lt; unsigned int, std::function&lt; void(<a class="el" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>, float)&gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a062c7be217334d4bce02ce34c32e00cb">getAxisEventBindings</a> ()</td></tr>
<tr class="separator:a062c7be217334d4bce02ce34c32e00cb inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893cf9d4987d1b3ece76c0ffa0577e6d inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">std::recursive_mutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a893cf9d4987d1b3ece76c0ffa0577e6d">getSpawnDespawnMutex</a> ()</td></tr>
<tr class="separator:a893cf9d4987d1b3ece76c0ffa0577e6d inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5e6b60ec1e1fdf9d1b7d6cb8387b74 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a5b5e6b60ec1e1fdf9d1b7d6cb8387b74">onMouseMove</a> (double xOffset, double yOffset)</td></tr>
<tr class="separator:a5b5e6b60ec1e1fdf9d1b7d6cb8387b74 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde53f1d8c88385fb8ba338820e77c8e inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#adde53f1d8c88385fb8ba338820e77c8e">onMouseScrollMove</a> (int iOffset)</td></tr>
<tr class="separator:adde53f1d8c88385fb8ba338820e77c8e inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccde9ffedb8ce10cfb4cbdd8b6ea59a inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a6ccde9ffedb8ce10cfb4cbdd8b6ea59a">onBeforeNewFrame</a> (float timeSincePrevFrameInSec)</td></tr>
<tr class="separator:a6ccde9ffedb8ce10cfb4cbdd8b6ea59a inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2310c20abcd99331c4d6b104e1e919 inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#abe2310c20abcd99331c4d6b104e1e919">onSpawning</a> ()</td></tr>
<tr class="separator:abe2310c20abcd99331c4d6b104e1e919 inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cba5cd17e5e968ed92f162b5a9f08b inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a79cba5cd17e5e968ed92f162b5a9f08b">onChildNodesSpawned</a> ()</td></tr>
<tr class="separator:a79cba5cd17e5e968ed92f162b5a9f08b inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890cf446e639ac9dd1e9e7832cf796ed inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a890cf446e639ac9dd1e9e7832cf796ed">onDespawning</a> ()</td></tr>
<tr class="separator:a890cf446e639ac9dd1e9e7832cf796ed inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e4a732c0e3578d8a5551693b8c02aa inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a53e4a732c0e3578d8a5551693b8c02aa">onBeforeDetachedFromParent</a> (bool bThisNodeBeingDetached)</td></tr>
<tr class="separator:a53e4a732c0e3578d8a5551693b8c02aa inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e67ce1bfe3c1015630301e3c53411f inherit pro_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#ab7e67ce1bfe3c1015630301e3c53411f">onAfterAttachedToNewParent</a> (bool bThisNodeBeingAttached)</td></tr>
<tr class="separator:ab7e67ce1bfe3c1015630301e3c53411f inherit pro_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00002d59e5d0dcda6e53c20b59947150"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a00002d59e5d0dcda6e53c20b59947150">onAfterDeserialized</a> ()</td></tr>
<tr class="separator:a00002d59e5d0dcda6e53c20b59947150"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a26f0039cbde3055ea33a7090b3d03964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a26f0039cbde3055ea33a7090b3d03964">applyAttachmentRule</a> (<a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">Node::AttachmentRule</a> locationRule, const glm::vec3 &amp;worldLocationBeforeAttachment, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">Node::AttachmentRule</a> rotationRule, const glm::vec3 &amp;worldRotationBeforeAttachment, <a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">Node::AttachmentRule</a> scaleRule, const glm::vec3 &amp;worldScaleBeforeAttachment)</td></tr>
<tr class="separator:a26f0039cbde3055ea33a7090b3d03964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a9d48594b1c45a95dde0d1cf542805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#af6a9d48594b1c45a95dde0d1cf542805">recalculateWorldMatrix</a> (bool bNotifyChildren=true)</td></tr>
<tr class="separator:af6a9d48594b1c45a95dde0d1cf542805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9f01357ae4a798be84c588dfe11ecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#aae9f01357ae4a798be84c588dfe11ecc">recalculateLocalMatrix</a> ()</td></tr>
<tr class="separator:aae9f01357ae4a798be84c588dfe11ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b2b6516e8a31a398fa1207db20bc23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a62b2b6516e8a31a398fa1207db20bc23">recalculateWorldMatrixForNodeAndNotifyChildren</a> (<a class="el" href="classne_1_1Node.html">Node</a> *pNode)</td></tr>
<tr class="separator:a62b2b6516e8a31a398fa1207db20bc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a072475ef37d5d228a57d0f690a415d1d"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a072475ef37d5d228a57d0f690a415d1d">relativeLocation</a> = glm::vec3(0.0F, 0.0F, 0.0F)</td></tr>
<tr class="separator:a072475ef37d5d228a57d0f690a415d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a1af4e84b0808687ba2cc75671a226"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a51a1af4e84b0808687ba2cc75671a226">relativeRotation</a> = glm::vec3(0.0F, 0.0F, 0.0F)</td></tr>
<tr class="separator:a51a1af4e84b0808687ba2cc75671a226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c8e2b839f27ff29d797fa69a2fd8df"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a60c8e2b839f27ff29d797fa69a2fd8df">relativeScale</a> = glm::vec3(1.0F, 1.0F, 1.0F)</td></tr>
<tr class="separator:a60c8e2b839f27ff29d797fa69a2fd8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d77f27055f3775057ab0bf195b2c84a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a5d77f27055f3775057ab0bf195b2c84a">mtxSpatialParent</a> {}</td></tr>
<tr class="separator:a5d77f27055f3775057ab0bf195b2c84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada55492444a50c37c75d960d612400c8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1SpatialNode_1_1LocalSpaceInformation.html">LocalSpaceInformation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#ada55492444a50c37c75d960d612400c8">mtxLocalSpace</a> {}</td></tr>
<tr class="separator:ada55492444a50c37c75d960d612400c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624839dac964e36060f5cf43922549d9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1SpatialNode_1_1WorldMatrixInformation.html">WorldMatrixInformation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1SpatialNode.html#a624839dac964e36060f5cf43922549d9">mtxWorldMatrix</a> {}</td></tr>
<tr class="separator:a624839dac964e36060f5cf43922549d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6db9d28bd448a131448276ee03de1e6d"><td class="memItemLeft" align="right" valign="top"><a id="a6db9d28bd448a131448276ee03de1e6d" name="a6db9d28bd448a131448276ee03de1e6d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr class="separator:a6db9d28bd448a131448276ee03de1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classne_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classne_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classne_1_1Node.html">ne::Node</a></td></tr>
<tr class="memitem:a14bad364fb30a60063a147b95ab17acc inherit pub_types_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">AttachmentRule</a> { <b>RESET_RELATIVE</b>
, <b>KEEP_RELATIVE</b>
, <b>KEEP_WORLD</b>
 }</td></tr>
<tr class="separator:a14bad364fb30a60063a147b95ab17acc inherit pub_types_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classne_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classne_1_1Node')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classne_1_1Node.html">ne::Node</a></td></tr>
<tr class="memitem:a881561ee518c6b936d7b973c89b26b62 inherit pub_static_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a881561ee518c6b936d7b973c89b26b62">getAliveNodeCount</a> ()</td></tr>
<tr class="separator:a881561ee518c6b936d7b973c89b26b62 inherit pub_static_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b45ecbcfa73932f521f10154cd65e35 inherit pub_static_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; sgc::GcPtr&lt; <a class="el" href="classne_1_1Node.html">Node</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a7b45ecbcfa73932f521f10154cd65e35">deserializeNodeTree</a> (const std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:a7b45ecbcfa73932f521f10154cd65e35 inherit pub_static_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeb90fc6bd28ec3b54e9f8f641c3574 inherit pub_static_methods_classne_1_1Node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classne_1_1GameInstance.html">GameInstance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Node.html#a2aeb90fc6bd28ec3b54e9f8f641c3574">getGameInstance</a> ()</td></tr>
<tr class="separator:a2aeb90fc6bd28ec3b54e9f8f641c3574 inherit pub_static_methods_classne_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classne_1_1Serializable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classne_1_1Serializable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classne_1_1Serializable.html">ne::Serializable</a></td></tr>
<tr class="memitem:a6cd50b9cef87748dede76ba3ef125e43 inherit pub_static_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::pair&lt; std::set&lt; std::string &gt;, toml::value &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a6cd50b9cef87748dede76ba3ef125e43">getIdsFromFile</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a6cd50b9cef87748dede76ba3ef125e43 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f76ea78f80fb43e5e481277a930b364 inherit pub_static_methods_classne_1_1Serializable"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a1f76ea78f80fb43e5e481277a930b364">serializeMultiple</a> (std::filesystem::path pathToFile, std::vector&lt; <a class="el" href="structne_1_1SerializableObjectInformation.html">SerializableObjectInformation</a> &gt; vObjects, bool bEnableBackup)</td></tr>
<tr class="separator:a1f76ea78f80fb43e5e481277a930b364 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a464dd6597a8eb7793dfde75c36a44a24">deserialize</a> (const std::filesystem::path &amp;pathToFile)</td></tr>
<tr class="separator:a464dd6597a8eb7793dfde75c36a44a24 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a3162d0dbc003bfcef8c0ae0846b32f77">deserialize</a> (const std::filesystem::path &amp;pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes)</td></tr>
<tr class="separator:a3162d0dbc003bfcef8c0ae0846b32f77 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a32a58a89522b5cca64db7b6750a73a19">deserialize</a> (std::filesystem::path pathToFile, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:a32a58a89522b5cca64db7b6750a73a19 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#afb8e66a57cc108fca4d35ae40de8e22a">deserialize</a> (const std::filesystem::path &amp;pathToFile, const std::string &amp;sEntityId)</td></tr>
<tr class="separator:afb8e66a57cc108fca4d35ae40de8e22a inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::same_as&lt;SmartPointer, sgc::GcPtr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;<a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt;&gt;</td></tr>
<tr class="memitem:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; std::vector&lt; <a class="el" href="structne_1_1DeserializedObjectInformation.html">DeserializedObjectInformation</a>&lt; SmartPointer &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#a5d16d519e3d326cbdc101e78ca1a2478">deserializeMultiple</a> (std::filesystem::path pathToFile)</td></tr>
<tr class="separator:a5d16d519e3d326cbdc101e78ca1a2478 inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplParams" colspan="2">template&lt;typename SmartPointer , typename InnerType  = typename SmartPointer::element_type&gt; <br />
requires std::derived_from&lt;InnerType, <a class="el" href="classne_1_1Serializable.html">Serializable</a>&gt; &amp;&amp; (std::same_as&lt;SmartPointer, sgc::GcPtr&lt;InnerType&gt;&gt; || std::same_as&lt;SmartPointer, std::unique_ptr&lt;InnerType&gt;&gt;)</td></tr>
<tr class="memitem:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memTemplItemLeft" align="right" valign="top">static std::variant&lt; SmartPointer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classne_1_1Serializable.html#af67ef936c5d20e2f861430b48c69c95a">deserialize</a> (const toml::value &amp;tomlData, std::unordered_map&lt; std::string, std::string &gt; &amp;customAttributes, std::string sEntityId=&quot;&quot;, const std::optional&lt; std::filesystem::path &gt; &amp;optionalPathToFile={})</td></tr>
<tr class="separator:af67ef936c5d20e2f861430b48c69c95a inherit pub_static_methods_classne_1_1Serializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a node that can have a location, rotation and a scale in a 3D space. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac02b39a7177a89acf9613d4b1bb9f203" name="ac02b39a7177a89acf9613d4b1bb9f203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02b39a7177a89acf9613d4b1bb9f203">&#9670;&#160;</a></span>SpatialNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ne::SpatialNode::SpatialNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sNodeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new node with the specified name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sNodeName</td><td>Name of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a26f0039cbde3055ea33a7090b3d03964" name="a26f0039cbde3055ea33a7090b3d03964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f0039cbde3055ea33a7090b3d03964">&#9670;&#160;</a></span>applyAttachmentRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::applyAttachmentRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">Node::AttachmentRule</a>&#160;</td>
          <td class="paramname"><em>locationRule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>worldLocationBeforeAttachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">Node::AttachmentRule</a>&#160;</td>
          <td class="paramname"><em>rotationRule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>worldRotationBeforeAttachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html#a14bad364fb30a60063a147b95ab17acc">Node::AttachmentRule</a>&#160;</td>
          <td class="paramname"><em>scaleRule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>worldScaleBeforeAttachment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called by <code><a class="el" href="classne_1_1Node.html">Node</a></code> class after we have attached to a new parent node and now need to apply attachment rules based on this new parent node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locationRule</td><td>Defines how location should change. </td></tr>
    <tr><td class="paramname">worldLocationBeforeAttachment</td><td><a class="el" href="classne_1_1World.html">World</a> location of this node before being attached. </td></tr>
    <tr><td class="paramname">rotationRule</td><td>Defines how rotation should change. </td></tr>
    <tr><td class="paramname">worldRotationBeforeAttachment</td><td><a class="el" href="classne_1_1World.html">World</a> rotation of this node before being attached. </td></tr>
    <tr><td class="paramname">scaleRule</td><td>Defines how scale should change. </td></tr>
    <tr><td class="paramname">worldScaleBeforeAttachment</td><td><a class="el" href="classne_1_1World.html">World</a> scale of this node before being attached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa361d4f17cb0cac78ad7f4b1f33d2c05" name="aa361d4f17cb0cac78ad7f4b1f33d2c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa361d4f17cb0cac78ad7f4b1f33d2c05">&#9670;&#160;</a></span>getClosestSpatialParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex, sgc::GcPtr&lt; <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> &gt; &gt; * ne::SpatialNode::getClosestSpatialParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the first (most closer to this node) spatial node in the parent node chain (i.e. cached result of <code>getParentNodeOfType&lt;<a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a>&gt;</code> that can be used without any search operations).</p>
<dl class="section warning"><dt>Warning</dt><dd>Avoid saving returned raw pointer as it points to the node's field and does not guarantee that the node will always live while you hold this pointer. Returning raw pointer in order to avoid creating GC pointers (if you for example only want to check closes parent node), but you can always save GC pointer if you need.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> as a gc pointer (second value in the pair) if there is no <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent node chain, otherwise closest <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent node chain. </dd></dl>

</div>
</div>
<a id="aeb558a9f20e9501a3d8a4b0f4a769f2c" name="aeb558a9f20e9501a3d8a4b0f4a769f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb558a9f20e9501a3d8a4b0f4a769f2c">&#9670;&#160;</a></span>getRelativeLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getRelativeLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns node's relative location (see <a class="el" href="classne_1_1SpatialNode.html#a15d5413bbb88c9b259e8e9e48a271ab6">setRelativeLocation</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>Relative location. </dd></dl>

</div>
</div>
<a id="a277ebb64994069549f09f5148d890fb9" name="a277ebb64994069549f09f5148d890fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277ebb64994069549f09f5148d890fb9">&#9670;&#160;</a></span>getRelativeRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getRelativeRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns node's relative rotation in degrees (see <a class="el" href="classne_1_1SpatialNode.html#a32914b6236f0d2675736be0f1ea1cac2">setRelativeRotation</a>). Also see <a class="el" href="classne_1_1SpatialNode.html#a50e2381f0d40f43e050cfa9ac2c2d9fa">getRelativeRotationMatrix</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Relative rotation. </dd></dl>

</div>
</div>
<a id="a50e2381f0d40f43e050cfa9ac2c2d9fa" name="a50e2381f0d40f43e050cfa9ac2c2d9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e2381f0d40f43e050cfa9ac2c2d9fa">&#9670;&#160;</a></span>getRelativeRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 ne::SpatialNode::getRelativeRotationMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a rotation matrix that applies node's relative rotation.</p>
<dl class="section return"><dt>Returns</dt><dd>Rotation matrix. </dd></dl>

</div>
</div>
<a id="a2b030ce699a74fd273d64affd7c34963" name="a2b030ce699a74fd273d64affd7c34963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b030ce699a74fd273d64affd7c34963">&#9670;&#160;</a></span>getRelativeScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getRelativeScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns node's relative scale (see <a class="el" href="classne_1_1SpatialNode.html#aecf859b09995cfac54203d12d5527627">setRelativeScale</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>Relative scale. </dd></dl>

</div>
</div>
<a id="ac8bba3a225a35cd40d5f04c98506aa4e" name="ac8bba3a225a35cd40d5f04c98506aa4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bba3a225a35cd40d5f04c98506aa4e">&#9670;&#160;</a></span>getWorldForwardDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getWorldForwardDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's forward direction in world space.</p>
<dl class="section return"><dt>Returns</dt><dd>Unit vector that points in the node's world forward direction. </dd></dl>

</div>
</div>
<a id="acbd42888d6bb7d5ff7e82bd61ed8f8c2" name="acbd42888d6bb7d5ff7e82bd61ed8f8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd42888d6bb7d5ff7e82bd61ed8f8c2">&#9670;&#160;</a></span>getWorldLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getWorldLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's world location (see <a class="el" href="classne_1_1SpatialNode.html#a5505c98b284aaf4037e8bf2e31305f2b">setWorldLocation</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the node is not spawned and has no parent, returns <a class="el" href="classne_1_1SpatialNode.html#aeb558a9f20e9501a3d8a4b0f4a769f2c">getRelativeLocation</a>. If the node is not spawned but has a parent, returns its location in the hierarchy.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Location of the node in the world. </dd></dl>

</div>
</div>
<a id="a9becf3737c72d57008bbc87d37aea546" name="a9becf3737c72d57008bbc87d37aea546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9becf3737c72d57008bbc87d37aea546">&#9670;&#160;</a></span>getWorldMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 ne::SpatialNode::getWorldMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's world matrix (matrix that transforms node's data (for example vertices) to world space).</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1World.html">World</a> matrix. </dd></dl>

</div>
</div>
<a id="a2594545f207a1a4972eade6172cca66c" name="a2594545f207a1a4972eade6172cca66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2594545f207a1a4972eade6172cca66c">&#9670;&#160;</a></span>getWorldRightDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getWorldRightDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's right direction in world space.</p>
<dl class="section return"><dt>Returns</dt><dd>Unit vector that points in the node's right direction. </dd></dl>

</div>
</div>
<a id="af1c06e3d090b282f172c0978c8ddeb17" name="af1c06e3d090b282f172c0978c8ddeb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c06e3d090b282f172c0978c8ddeb17">&#9670;&#160;</a></span>getWorldRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getWorldRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's world rotation in degrees (see <a class="el" href="classne_1_1SpatialNode.html#afb2f513f7406d324c9927af5fec07c26">setWorldRotation</a>). Also see <a class="el" href="classne_1_1SpatialNode.html#a9e77c912ebf8f0877addcee649fdffe1">getWorldRotationQuaternion</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the node is not spawned and has no parent, returns <a class="el" href="classne_1_1SpatialNode.html#a277ebb64994069549f09f5148d890fb9">getRelativeRotation</a>. If the node is not spawned but has a parent, returns its rotation in the hierarchy.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Rotation of the node in the world. </dd></dl>

</div>
</div>
<a id="a9e77c912ebf8f0877addcee649fdffe1" name="a9e77c912ebf8f0877addcee649fdffe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e77c912ebf8f0877addcee649fdffe1">&#9670;&#160;</a></span>getWorldRotationQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::quat ne::SpatialNode::getWorldRotationQuaternion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's world rotation in the quaternion form (see <a class="el" href="classne_1_1SpatialNode.html#af1c06e3d090b282f172c0978c8ddeb17">getWorldRotation</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>Rotation of the node in the world. </dd></dl>

</div>
</div>
<a id="aac522941554b6f4f97f5eb1a2e29d31a" name="aac522941554b6f4f97f5eb1a2e29d31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac522941554b6f4f97f5eb1a2e29d31a">&#9670;&#160;</a></span>getWorldScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getWorldScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's world scale (see <a class="el" href="classne_1_1SpatialNode.html#a95c51087d2b8e3bd43ca218de57a7cca">setWorldScale</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the node is not spawned and has no parent, returns <a class="el" href="classne_1_1SpatialNode.html#a2b030ce699a74fd273d64affd7c34963">getRelativeScale</a>. If the node is not spawned but has a parent, returns its scale in the hierarchy.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Scale of the node in the world. </dd></dl>

</div>
</div>
<a id="a95209d6c7572ee121505191652ed529b" name="a95209d6c7572ee121505191652ed529b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95209d6c7572ee121505191652ed529b">&#9670;&#160;</a></span>getWorldUpDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::getWorldUpDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns node's up direction in world space.</p>
<dl class="section return"><dt>Returns</dt><dd>Unit vector that points in the node's up direction. </dd></dl>

</div>
</div>
<a id="ae883c06ca2bc4bd917de5486cbbda0d4" name="ae883c06ca2bc4bd917de5486cbbda0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae883c06ca2bc4bd917de5486cbbda0d4">&#9670;&#160;</a></span>onAfterAttachedToNewParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::onAfterAttachedToNewParent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bThisNodeBeingAttached</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after this node or one of the node's parents (in the parent hierarchy) was attached to a new parent node.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function will also be called on all child nodes after this function is finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bThisNodeBeingAttached</td><td><code>true</code> if this node was attached to a parent, <code>false</code> if some node in the parent hierarchy was attached to a parent. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classne_1_1Node.html#ab7e67ce1bfe3c1015630301e3c53411f">ne::Node</a>.</p>

<p>Reimplemented in <a class="el" href="classne_1_1EditorCameraNode.html#a08e4e5ace5a7e1f0c9267a3482f7f4ca">ne::EditorCameraNode</a>.</p>

</div>
</div>
<a id="a4ef72e0c9e17fba2aeae88a87c424a84" name="a4ef72e0c9e17fba2aeae88a87c424a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef72e0c9e17fba2aeae88a87c424a84">&#9670;&#160;</a></span>onAfterDeserialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::onAfterDeserialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after the object was successfully deserialized. Used to execute post-deserialization logic.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented from <a class="el" href="classne_1_1Serializable.html#a00002d59e5d0dcda6e53c20b59947150">ne::Serializable</a>.</p>

<p>Reimplemented in <a class="el" href="classne_1_1DirectionalLightNode.html#a5371921a835741ed94bc0c823e8f5424">ne::DirectionalLightNode</a>, <a class="el" href="classne_1_1PointLightNode.html#ae2b46df4a1cf71aafb64a05a2b03a98c">ne::PointLightNode</a>, <a class="el" href="classne_1_1SpotlightNode.html#aa34d6c205b21d9b7beeaa2769c0ecb96">ne::SpotlightNode</a>, and <a class="el" href="classne_1_1MeshNode.html#a453c3a079be0120c8c9fb7cd3a5a6899">ne::MeshNode</a>.</p>

</div>
</div>
<a id="a3af79f3d46f46b70636d67b70dab12d2" name="a3af79f3d46f46b70636d67b70dab12d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af79f3d46f46b70636d67b70dab12d2">&#9670;&#160;</a></span>onSpawning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::onSpawning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when this node was not spawned previously and it was either attached to a parent node that is spawned or set as world's root node to execute custom spawn logic.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This node will be marked as spawned before this function is called. </dd>
<dd>
This function is called before any of the child nodes are spawned.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic. </dd></dl>

<p>Reimplemented from <a class="el" href="classne_1_1Node.html#abe2310c20abcd99331c4d6b104e1e919">ne::Node</a>.</p>

<p>Reimplemented in <a class="el" href="classne_1_1DirectionalLightNode.html#a87cfb909061175db5c5ec9a0fc9ef899">ne::DirectionalLightNode</a>, <a class="el" href="classne_1_1PointLightNode.html#afd427bdca3170f84fe6d924e9ba9cde4">ne::PointLightNode</a>, <a class="el" href="classne_1_1SpotlightNode.html#ab2281ef335d11edcd87971e8ed3d92c1">ne::SpotlightNode</a>, and <a class="el" href="classne_1_1MeshNode.html#a7127ccc4f7cc62ab5f74583920ee93ee">ne::MeshNode</a>.</p>

</div>
</div>
<a id="adf62ec87e7faeebafc764a2b71ae92b6" name="adf62ec87e7faeebafc764a2b71ae92b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf62ec87e7faeebafc764a2b71ae92b6">&#9670;&#160;</a></span>onWorldLocationRotationScaleChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ne::SpatialNode::onWorldLocationRotationScaleChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after node's world location/rotation/scale was changed.</p>
<dl class="section warning"><dt>Warning</dt><dd>If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you change location/rotation/scale inside of this function, this function will not be called again (no recursion will occur). </dd></dl>

<p>Reimplemented in <a class="el" href="classne_1_1CameraNode.html#a9410fa3451b9d607ebdf851819cd03d2">ne::CameraNode</a>, <a class="el" href="classne_1_1DirectionalLightNode.html#a50234389cb5b38e47185e56802605663">ne::DirectionalLightNode</a>, <a class="el" href="classne_1_1PointLightNode.html#a6fa982be86ccabacc971b188f2632e14">ne::PointLightNode</a>, <a class="el" href="classne_1_1SpotlightNode.html#a9c37f11e3e4aae66a316dd7c5a2bc477">ne::SpotlightNode</a>, and <a class="el" href="classne_1_1MeshNode.html#a74b459c63b02d3f8fa269ba17d93bf5e">ne::MeshNode</a>.</p>

</div>
</div>
<a id="aae9f01357ae4a798be84c588dfe11ecc" name="aae9f01357ae4a798be84c588dfe11ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9f01357ae4a798be84c588dfe11ecc">&#9670;&#160;</a></span>recalculateLocalMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::recalculateLocalMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Recalculates node's local matrix based on local location/rotation/scale. </p>

</div>
</div>
<a id="af6a9d48594b1c45a95dde0d1cf542805" name="af6a9d48594b1c45a95dde0d1cf542805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a9d48594b1c45a95dde0d1cf542805">&#9670;&#160;</a></span>recalculateWorldMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::recalculateWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bNotifyChildren</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Recalculates node's world matrix based on the parent world matrix (can be identity if there's node parent) and optionally notifies spatial child nodes.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1SpatialNode.html#ada55492444a50c37c75d960d612400c8">mtxLocalSpace</a> to be up to date (see <a class="el" href="classne_1_1SpatialNode.html#aae9f01357ae4a798be84c588dfe11ecc">recalculateLocalMatrix</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bNotifyChildren</td><td>Whether to notify spatial child nodes so that could recalculate their world matrix or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62b2b6516e8a31a398fa1207db20bc23" name="a62b2b6516e8a31a398fa1207db20bc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b2b6516e8a31a398fa1207db20bc23">&#9670;&#160;</a></span>recalculateWorldMatrixForNodeAndNotifyChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::recalculateWorldMatrixForNodeAndNotifyChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Checks if the specified node is a <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> and calls <a class="el" href="classne_1_1SpatialNode.html#af6a9d48594b1c45a95dde0d1cf542805">recalculateWorldMatrix</a>, otherwise calls this function on all child nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNode</td><td><a class="el" href="classne_1_1Node.html">Node</a> to recalculate world matrix for (if <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15d5413bbb88c9b259e8e9e48a271ab6" name="a15d5413bbb88c9b259e8e9e48a271ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d5413bbb88c9b259e8e9e48a271ab6">&#9670;&#160;</a></span>setRelativeLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::setRelativeLocation </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets node's relative location, if there is another <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain then this location is relative to the first <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, otherwise if there is no <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, this location is relative to the world.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>Relative location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32914b6236f0d2675736be0f1ea1cac2" name="a32914b6236f0d2675736be0f1ea1cac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32914b6236f0d2675736be0f1ea1cac2">&#9670;&#160;</a></span>setRelativeRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::setRelativeRotation </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets node's relative rotation (roll, pitch, yaw in degrees), if there is another <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain then this rotation is relative to the first <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, otherwise if there is no <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, this rotation is relative to the world.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>Relative rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecf859b09995cfac54203d12d5527627" name="aecf859b09995cfac54203d12d5527627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf859b09995cfac54203d12d5527627">&#9670;&#160;</a></span>setRelativeScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::setRelativeScale </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets node's relative scale, if there is another <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain then this scale is relative to the first <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, otherwise if there is no <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, this scale is relative to the world.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>Relative scale. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5505c98b284aaf4037e8bf2e31305f2b" name="a5505c98b284aaf4037e8bf2e31305f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5505c98b284aaf4037e8bf2e31305f2b">&#9670;&#160;</a></span>setWorldLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::setWorldLocation </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets relative location in the way that the resulting node's location in the world would match the specified location.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the node is not spawned just sets node's relative location.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>Location that the node should take in the world. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb2f513f7406d324c9927af5fec07c26" name="afb2f513f7406d324c9927af5fec07c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2f513f7406d324c9927af5fec07c26">&#9670;&#160;</a></span>setWorldRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::setWorldRotation </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets relative rotation (roll, pitch, yaw in degrees) in the way that the resulting node's rotation in the world would match the specified rotation.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the node is not spawned just sets node's relative rotation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>Rotation that the node should take in the world. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95c51087d2b8e3bd43ca218de57a7cca" name="a95c51087d2b8e3bd43ca218de57a7cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c51087d2b8e3bd43ca218de57a7cca">&#9670;&#160;</a></span>setWorldScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ne::SpatialNode::setWorldScale </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets relative scale in the way that the resulting node's scale in the world would match the specified scale.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the node is not spawned just sets node's relative scale.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>Scale that the node should take in the world. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ada55492444a50c37c75d960d612400c8" name="ada55492444a50c37c75d960d612400c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada55492444a50c37c75d960d612400c8">&#9670;&#160;</a></span>mtxLocalSpace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1SpatialNode_1_1LocalSpaceInformation.html">LocalSpaceInformation</a>&gt; ne::SpatialNode::mtxLocalSpace {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Matrix that describes basis vectors that define node's local space. </p>

</div>
</div>
<a id="a5d77f27055f3775057ab0bf195b2c84a" name="a5d77f27055f3775057ab0bf195b2c84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d77f27055f3775057ab0bf195b2c84a">&#9670;&#160;</a></span>mtxSpatialParent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, sgc::GcPtr&lt;<a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a>&gt; &gt; ne::SpatialNode::mtxSpatialParent {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >First (most closer to this node) spatial node in the parent chain. </p>

</div>
</div>
<a id="a624839dac964e36060f5cf43922549d9" name="a624839dac964e36060f5cf43922549d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624839dac964e36060f5cf43922549d9">&#9670;&#160;</a></span>mtxWorldMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1SpatialNode_1_1WorldMatrixInformation.html">WorldMatrixInformation</a>&gt; ne::SpatialNode::mtxWorldMatrix {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classne_1_1World.html">World</a> related information, must be used with mutex. </p>

</div>
</div>
<a id="a072475ef37d5d228a57d0f690a415d1d" name="a072475ef37d5d228a57d0f690a415d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072475ef37d5d228a57d0f690a415d1d">&#9670;&#160;</a></span>relativeLocation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::relativeLocation = glm::vec3(0.0F, 0.0F, 0.0F)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classne_1_1Node.html">Node</a>'s location, if there is another <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain then this location is relative to the first <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, otherwise if there is no <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, relative to the world. </p>

</div>
</div>
<a id="a51a1af4e84b0808687ba2cc75671a226" name="a51a1af4e84b0808687ba2cc75671a226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a1af4e84b0808687ba2cc75671a226">&#9670;&#160;</a></span>relativeRotation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::relativeRotation = glm::vec3(0.0F, 0.0F, 0.0F)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classne_1_1Node.html">Node</a>'s rotation in degrees, if there is another <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain then this rotation is relative to the first <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, otherwise if there is no <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, relative to the world. </p>

</div>
</div>
<a id="a60c8e2b839f27ff29d797fa69a2fd8df" name="a60c8e2b839f27ff29d797fa69a2fd8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c8e2b839f27ff29d797fa69a2fd8df">&#9670;&#160;</a></span>relativeScale</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 ne::SpatialNode::relativeScale = glm::vec3(1.0F, 1.0F, 1.0F)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classne_1_1Node.html">Node</a>'s scale, if there is another <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain then this scale is relative to the first <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, otherwise if there is no <a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a> in the parent chain, relative to the world. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/public/game/node/<a class="el" href="SpatialNode_8h_source.html">SpatialNode.h</a></li>
<li>src/engine_lib/private/game/node/SpatialNode.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1SpatialNode.html">SpatialNode</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
