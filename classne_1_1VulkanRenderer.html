<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::VulkanRenderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classne_1_1VulkanRenderer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classne_1_1VulkanRenderer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::VulkanRenderer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="VulkanRenderer_8h_source.html">VulkanRenderer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ne::VulkanRenderer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classne_1_1VulkanRenderer.png" usemap="#ne::VulkanRenderer_map" alt=""/>
  <map id="ne::VulkanRenderer_map" name="ne::VulkanRenderer_map">
<area href="classne_1_1Renderer.html" alt="ne::Renderer" shape="rect" coords="0,0,124,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1VulkanRenderer_1_1QueueFamilyIndices.html">QueueFamilyIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1VulkanRenderer_1_1SwapChainImageSemaphores.html">SwapChainImageSemaphores</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1VulkanRenderer_1_1SwapChainSupportDetails.html">SwapChainSupportDetails</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a12a56e0f70335d2d7abff2eea9ab2a4c"><td class="memItemLeft" align="right" valign="top"><a id="a12a56e0f70335d2d7abff2eea9ab2a4c" name="a12a56e0f70335d2d7abff2eea9ab2a4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>VulkanRenderer</b> (const <a class="el" href="classne_1_1VulkanRenderer.html">VulkanRenderer</a> &amp;)=delete</td></tr>
<tr class="separator:a12a56e0f70335d2d7abff2eea9ab2a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab024ebd06943b89aa886e315a6082d0d"><td class="memItemLeft" align="right" valign="top"><a id="ab024ebd06943b89aa886e315a6082d0d" name="ab024ebd06943b89aa886e315a6082d0d"></a>
<a class="el" href="classne_1_1VulkanRenderer.html">VulkanRenderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1VulkanRenderer.html">VulkanRenderer</a> &amp;)=delete</td></tr>
<tr class="separator:ab024ebd06943b89aa886e315a6082d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ad698904e7c3373a657ea9261e29ac"><td class="memItemLeft" align="right" valign="top">VkSampler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a15ad698904e7c3373a657ea9261e29ac">getTextureSampler</a> (TextureFilteringQuality filtering)</td></tr>
<tr class="separator:a15ad698904e7c3373a657ea9261e29ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d3142a7256c58c9e5621ea1572df0a"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a66d3142a7256c58c9e5621ea1572df0a">getSupportedGpuNames</a> () const override</td></tr>
<tr class="separator:a66d3142a7256c58c9e5621ea1572df0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b99ca902231e396a0abef4fe3a1cdfb"><td class="memItemLeft" align="right" valign="top">virtual std::variant&lt; std::set&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a6b99ca902231e396a0abef4fe3a1cdfb">getSupportedRenderResolutions</a> () const override</td></tr>
<tr class="separator:a6b99ca902231e396a0abef4fe3a1cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d2498bc0ef0353911f54aa6bd6c2e6"><td class="memItemLeft" align="right" valign="top">virtual std::variant&lt; std::set&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a80d2498bc0ef0353911f54aa6bd6c2e6">getSupportedRefreshRates</a> () const override</td></tr>
<tr class="separator:a80d2498bc0ef0353911f54aa6bd6c2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87693c1fba2a1765915317d9ff817f28"><td class="memItemLeft" align="right" valign="top">virtual RendererType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a87693c1fba2a1765915317d9ff817f28">getType</a> () const override</td></tr>
<tr class="separator:a87693c1fba2a1765915317d9ff817f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9f5059b75b65b93f4f45325f7184a4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ada9f5059b75b65b93f4f45325f7184a4">getUsedApiVersion</a> () const override</td></tr>
<tr class="separator:ada9f5059b75b65b93f4f45325f7184a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603e6ac31825bf57a772c0e89a89ec8b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a603e6ac31825bf57a772c0e89a89ec8b">getCurrentlyUsedGpuName</a> () const override</td></tr>
<tr class="separator:a603e6ac31825bf57a772c0e89a89ec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba1205f16b9038da69db0c001550943"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a3ba1205f16b9038da69db0c001550943">waitForGpuToFinishWorkUpToThisPoint</a> () override</td></tr>
<tr class="separator:a3ba1205f16b9038da69db0c001550943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba6849ba3e37cc117afec21b339f97e"><td class="memItemLeft" align="right" valign="top">std::variant&lt; VkCommandBuffer, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a6ba6849ba3e37cc117afec21b339f97e">createOneTimeSubmitCommandBuffer</a> ()</td></tr>
<tr class="separator:a6ba6849ba3e37cc117afec21b339f97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be101433f7df8f6fedfd7d4d3f4985e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a5be101433f7df8f6fedfd7d4d3f4985e">submitWaitDestroyOneTimeSubmitCommandBuffer</a> (VkCommandBuffer pOneTimeSubmitCommandBuffer)</td></tr>
<tr class="separator:a5be101433f7df8f6fedfd7d4d3f4985e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363deaf734f4f58cd5106a0c8a0802ae"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a363deaf734f4f58cd5106a0c8a0802ae">transitionImageLayout</a> (VkImage pImage, VkFormat imageFormat, VkImageAspectFlags aspect, uint32_t levelCount, uint32_t layerCount, VkImageLayout oldLayout, VkImageLayout newLayout)</td></tr>
<tr class="separator:a363deaf734f4f58cd5106a0c8a0802ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7cba297c4619c36856488e11a63247"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aff7cba297c4619c36856488e11a63247">getRenderTargetSize</a> () const override</td></tr>
<tr class="separator:aff7cba297c4619c36856488e11a63247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664c90ee63237b1a5177bf5cbb9e54a3"><td class="memItemLeft" align="right" valign="top">VkDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a664c90ee63237b1a5177bf5cbb9e54a3">getLogicalDevice</a> () const</td></tr>
<tr class="separator:a664c90ee63237b1a5177bf5cbb9e54a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b515b9b5dfb8c1c7a95e98339f1c51"><td class="memItemLeft" align="right" valign="top">VkPhysicalDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aa6b515b9b5dfb8c1c7a95e98339f1c51">getPhysicalDevice</a> () const</td></tr>
<tr class="separator:aa6b515b9b5dfb8c1c7a95e98339f1c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070da1c1fd3bf14ab93a1ccba8908b52"><td class="memItemLeft" align="right" valign="top">VkInstance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a070da1c1fd3bf14ab93a1ccba8908b52">getInstance</a> () const</td></tr>
<tr class="separator:a070da1c1fd3bf14ab93a1ccba8908b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a06a845e9c0ae7d5b9f9ccf3e03b6d"><td class="memItemLeft" align="right" valign="top">VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a35a06a845e9c0ae7d5b9f9ccf3e03b6d">getMainRenderPass</a> () const</td></tr>
<tr class="separator:a35a06a845e9c0ae7d5b9f9ccf3e03b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20260337b2a82568f06e8f2d1bd2c4e4"><td class="memItemLeft" align="right" valign="top">VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a20260337b2a82568f06e8f2d1bd2c4e4">getDepthOnlyRenderPass</a> () const</td></tr>
<tr class="separator:a20260337b2a82568f06e8f2d1bd2c4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208c97cb75b621724bbd22a7b49c07d4"><td class="memItemLeft" align="right" valign="top">VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a208c97cb75b621724bbd22a7b49c07d4">getShadowMappingRenderPass</a> (bool bIsForPointLights) const</td></tr>
<tr class="separator:a208c97cb75b621724bbd22a7b49c07d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfac946f7d02bde23fc62106eed5561"><td class="memItemLeft" align="right" valign="top">VkCommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a4bfac946f7d02bde23fc62106eed5561">getCommandPool</a> () const</td></tr>
<tr class="separator:a4bfac946f7d02bde23fc62106eed5561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca6b972881780350eec71ce0869dc2d"><td class="memItemLeft" align="right" valign="top">VkQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#abca6b972881780350eec71ce0869dc2d">getGraphicsQueue</a> () const</td></tr>
<tr class="separator:abca6b972881780350eec71ce0869dc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841bbb1e1f79595e68c8f771dc17da6f"><td class="memItemLeft" align="right" valign="top">VkSampler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a841bbb1e1f79595e68c8f771dc17da6f">getComputeTextureSampler</a> () const</td></tr>
<tr class="separator:a841bbb1e1f79595e68c8f771dc17da6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e11b0f1ffac78a633cdcb9a3c40424"><td class="memItemLeft" align="right" valign="top">VkSampler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ae7e11b0f1ffac78a633cdcb9a3c40424">getShadowTextureSampler</a> () const</td></tr>
<tr class="separator:ae7e11b0f1ffac78a633cdcb9a3c40424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f8f4f08713e16f16fbf4937da819a3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; VkExtent2D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ac7f8f4f08713e16f16fbf4937da819a3">getSwapChainExtent</a> () const</td></tr>
<tr class="separator:ac7f8f4f08713e16f16fbf4937da819a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b0c33fd86d697831304e0a0dd098c2"><td class="memItemLeft" align="right" valign="top">VkSampleCountFlagBits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a41b0c33fd86d697831304e0a0dd098c2">getMsaaSampleCount</a> () const</td></tr>
<tr class="separator:a41b0c33fd86d697831304e0a0dd098c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26352c2baa0cdc7764911d55b15bc037"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a26352c2baa0cdc7764911d55b15bc037">getDepthTextureNoMultisampling</a> () override</td></tr>
<tr class="separator:a26352c2baa0cdc7764911d55b15bc037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classne_1_1Renderer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classne_1_1Renderer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classne_1_1Renderer.html">ne::Renderer</a></td></tr>
<tr class="memitem:af6b8363427b9874b923cbffb4fc821de inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a id="af6b8363427b9874b923cbffb4fc821de" name="af6b8363427b9874b923cbffb4fc821de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Renderer</b> (const <a class="el" href="classne_1_1Renderer.html">Renderer</a> &amp;)=delete</td></tr>
<tr class="separator:af6b8363427b9874b923cbffb4fc821de inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c61c1c287443f9da29f9ec60305c564 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a id="a6c61c1c287443f9da29f9ec60305c564" name="a6c61c1c287443f9da29f9ec60305c564"></a>
<a class="el" href="classne_1_1Renderer.html">Renderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classne_1_1Renderer.html">Renderer</a> &amp;)=delete</td></tr>
<tr class="separator:a6c61c1c287443f9da29f9ec60305c564 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87df2fda14247192847d5056e0ecfe3 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#aa87df2fda14247192847d5056e0ecfe3">getSupportedGpuNames</a> () const =0</td></tr>
<tr class="separator:aa87df2fda14247192847d5056e0ecfe3 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae620044334fb679c877d70e42c72b312 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual std::variant&lt; std::set&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ae620044334fb679c877d70e42c72b312">getSupportedRenderResolutions</a> () const =0</td></tr>
<tr class="separator:ae620044334fb679c877d70e42c72b312 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d73c28396846df0151e37f9a6a4830 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual std::variant&lt; std::set&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#aa2d73c28396846df0151e37f9a6a4830">getSupportedRefreshRates</a> () const =0</td></tr>
<tr class="separator:aa2d73c28396846df0151e37f9a6a4830 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bc0b11a97b3e92b8510f348d0fa28f inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual RendererType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a19bc0b11a97b3e92b8510f348d0fa28f">getType</a> () const =0</td></tr>
<tr class="separator:a19bc0b11a97b3e92b8510f348d0fa28f inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e357989d5b7239ded555a7298e35d1 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a03e357989d5b7239ded555a7298e35d1">getUsedApiVersion</a> () const =0</td></tr>
<tr class="separator:a03e357989d5b7239ded555a7298e35d1 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fd460314e60a79b027fba12d55a68d inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex *, <a class="el" href="classne_1_1RenderSettings.html">RenderSettings</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a12fd460314e60a79b027fba12d55a68d">getRenderSettings</a> ()</td></tr>
<tr class="separator:a12fd460314e60a79b027fba12d55a68d inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65404722ecba28c300763c04ab06712 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1RenderStatistics.html">RenderStatistics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ab65404722ecba28c300763c04ab06712">getRenderStatistics</a> ()</td></tr>
<tr class="separator:ab65404722ecba28c300763c04ab06712 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89d3ddad084a96bb1f348c96e0b7263 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ab89d3ddad084a96bb1f348c96e0b7263">getCurrentlyUsedGpuName</a> () const =0</td></tr>
<tr class="separator:ab89d3ddad084a96bb1f348c96e0b7263 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6736b43c6b2fe8a64ec02547e83b7ab5 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a6736b43c6b2fe8a64ec02547e83b7ab5">getTotalVideoMemoryInMb</a> () const</td></tr>
<tr class="separator:a6736b43c6b2fe8a64ec02547e83b7ab5 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155f3058794bf3ded4a8d4a1bc77dd71 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a155f3058794bf3ded4a8d4a1bc77dd71">getUsedVideoMemoryInMb</a> () const</td></tr>
<tr class="separator:a155f3058794bf3ded4a8d4a1bc77dd71 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82398bb159588b48ad20f09b02db47a9 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a82398bb159588b48ad20f09b02db47a9">waitForGpuToFinishWorkUpToThisPoint</a> ()=0</td></tr>
<tr class="separator:a82398bb159588b48ad20f09b02db47a9 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a086ceb56a27475014417e862175fe inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a29a086ceb56a27475014417e862175fe">getRenderTargetSize</a> () const =0</td></tr>
<tr class="separator:a29a086ceb56a27475014417e862175fe inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2060db01a347def8c4315f6aada1f8 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1Window.html">Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a4b2060db01a347def8c4315f6aada1f8">getWindow</a> () const</td></tr>
<tr class="separator:a4b2060db01a347def8c4315f6aada1f8 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a8871ad19fc9e5e91a618e0c47aaae inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1GameManager.html">GameManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#aa3a8871ad19fc9e5e91a618e0c47aaae">getGameManager</a> () const</td></tr>
<tr class="separator:aa3a8871ad19fc9e5e91a618e0c47aaae inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cde18dbde3564c907d839703c8f4193 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1ShaderManager.html">ShaderManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a9cde18dbde3564c907d839703c8f4193">getShaderManager</a> () const</td></tr>
<tr class="separator:a9cde18dbde3564c907d839703c8f4193 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1988bfc14749904750ba6dde70ffb2 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a2c1988bfc14749904750ba6dde70ffb2">getPipelineManager</a> () const</td></tr>
<tr class="separator:a2c1988bfc14749904750ba6dde70ffb2 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691ec87d1ca95da47e88b27cd0cfc4d0 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1GpuResourceManager.html">GpuResourceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a691ec87d1ca95da47e88b27cd0cfc4d0">getResourceManager</a> () const</td></tr>
<tr class="separator:a691ec87d1ca95da47e88b27cd0cfc4d0 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ba13de625c3e7137ffccafe418e54d inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1FrameResourceManager.html">FrameResourceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a50ba13de625c3e7137ffccafe418e54d">getFrameResourceManager</a> () const</td></tr>
<tr class="separator:a50ba13de625c3e7137ffccafe418e54d inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af291d346e7a157b4a519ebda87245dbd inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1ShaderCpuWriteResourceBindingManager.html">ShaderCpuWriteResourceBindingManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#af291d346e7a157b4a519ebda87245dbd">getShaderCpuWriteResourceManager</a> () const</td></tr>
<tr class="separator:af291d346e7a157b4a519ebda87245dbd inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a9c1d031f1b6ba3f2f86b81eadf561 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1ShaderTextureResourceBindingManager.html">ShaderTextureResourceBindingManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a06a9c1d031f1b6ba3f2f86b81eadf561">getShaderTextureResourceManager</a> () const</td></tr>
<tr class="separator:a06a9c1d031f1b6ba3f2f86b81eadf561 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065b2ac320b63d2651c706f1e98fab12 inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1LightingShaderResourceManager.html">LightingShaderResourceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a065b2ac320b63d2651c706f1e98fab12">getLightingShaderResourceManager</a> () const</td></tr>
<tr class="separator:a065b2ac320b63d2651c706f1e98fab12 inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ca55b01e064a85b554058e395e427a inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classne_1_1GlobalShaderResourceBindingManager.html">GlobalShaderResourceBindingManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a94ca55b01e064a85b554058e395e427a">getGlobalShaderResourceBindingManager</a> () const</td></tr>
<tr class="separator:a94ca55b01e064a85b554058e395e427a inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695dc78d2a55c2aa0d1c6d77265e286f inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::recursive_mutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a695dc78d2a55c2aa0d1c6d77265e286f">getRenderResourcesMutex</a> ()</td></tr>
<tr class="separator:a695dc78d2a55c2aa0d1c6d77265e286f inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad507d970274a84b8fbb2a0a97b30305e inherit pub_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classne_1_1GpuResource.html">GpuResource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ad507d970274a84b8fbb2a0a97b30305e">getDepthTextureNoMultisampling</a> ()=0</td></tr>
<tr class="separator:ad507d970274a84b8fbb2a0a97b30305e inherit pub_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acc334f432f35b32742ae93ba72e027b5"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#acc334f432f35b32742ae93ba72e027b5">getUsedVulkanVersion</a> ()</td></tr>
<tr class="separator:acc334f432f35b32742ae93ba72e027b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843071a0c9dde64b9eae832fde1b8e97"><td class="memItemLeft" align="right" valign="top">static constexpr VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a843071a0c9dde64b9eae832fde1b8e97">getDepthImageFormat</a> ()</td></tr>
<tr class="separator:a843071a0c9dde64b9eae832fde1b8e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347daefa40e801343ff6e3ee02b1cc39"><td class="memItemLeft" align="right" valign="top">static constexpr VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a347daefa40e801343ff6e3ee02b1cc39">getShadowMapFormat</a> ()</td></tr>
<tr class="separator:a347daefa40e801343ff6e3ee02b1cc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb781e6224b2efc4a54490d76c1ff10"><td class="memItemLeft" align="right" valign="top">static constexpr VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a1fb781e6224b2efc4a54490d76c1ff10">getShadowMappingPointLightColorTargetFormat</a> ()</td></tr>
<tr class="separator:a1fb781e6224b2efc4a54490d76c1ff10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f6619897fdb3232624e240783970ad"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1Renderer.html">Renderer</a> &gt;, std::pair&lt; <a class="el" href="classne_1_1Error.html">Error</a>, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a72f6619897fdb3232624e240783970ad">create</a> (<a class="el" href="classne_1_1GameManager.html">GameManager</a> *<a class="el" href="classne_1_1Renderer.html#a25e1de71d1ebe7b95281c7de8833986a">pGameManager</a>, const std::vector&lt; std::string &gt; &amp;vBlacklistedGpuNames)</td></tr>
<tr class="separator:a72f6619897fdb3232624e240783970ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e8afa9d6e86aeb33be8fa1c453c8e3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a73e8afa9d6e86aeb33be8fa1c453c8e3">setObjectDebugOnlyName</a> (<a class="el" href="classne_1_1Renderer.html">Renderer</a> *pRenderer, void *pObject, VkObjectType objectType, const std::string &amp;sResourceName)</td></tr>
<tr class="separator:a73e8afa9d6e86aeb33be8fa1c453c8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classne_1_1Renderer"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classne_1_1Renderer')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classne_1_1Renderer.html">ne::Renderer</a></td></tr>
<tr class="memitem:afb7a609075deb5b121a3218a92d4a1c6 inherit pub_static_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#afb7a609075deb5b121a3218a92d4a1c6">getMinDepth</a> ()</td></tr>
<tr class="separator:afb7a609075deb5b121a3218a92d4a1c6 inherit pub_static_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26cb2e1d65dc77d041466bd3155032a inherit pub_static_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#aa26cb2e1d65dc77d041466bd3155032a">getMaxDepth</a> ()</td></tr>
<tr class="separator:aa26cb2e1d65dc77d041466bd3155032a inherit pub_static_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329ab805808f20b4bf0b2b60f3f715c6 inherit pub_static_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1Renderer.html">Renderer</a> &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a329ab805808f20b4bf0b2b60f3f715c6">create</a> (<a class="el" href="classne_1_1GameManager.html">GameManager</a> *<a class="el" href="classne_1_1Renderer.html#a25e1de71d1ebe7b95281c7de8833986a">pGameManager</a>, std::optional&lt; RendererType &gt; preferredRenderer)</td></tr>
<tr class="separator:a329ab805808f20b4bf0b2b60f3f715c6 inherit pub_static_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2cd8cc2433f8da659e5e72f315f7ec4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a2cd8cc2433f8da659e5e72f315f7ec4c">VulkanRenderer</a> (<a class="el" href="classne_1_1GameManager.html">GameManager</a> *<a class="el" href="classne_1_1Renderer.html#a25e1de71d1ebe7b95281c7de8833986a">pGameManager</a>)</td></tr>
<tr class="separator:a2cd8cc2433f8da659e5e72f315f7ec4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e40ec2a4bc21add52ec0140806e9a6"><td class="memItemLeft" align="right" valign="top">virtual std::variant&lt; std::optional&lt; AntialiasingQuality &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aa6e40ec2a4bc21add52ec0140806e9a6">getMaxSupportedAntialiasingQuality</a> () const override</td></tr>
<tr class="separator:aa6e40ec2a4bc21add52ec0140806e9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51bddb238dd93b8653067c0c64fbc5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ac51bddb238dd93b8653067c0c64fbc5a">onFramebufferSizeChangedDerived</a> (int iWidth, int iHeight) override</td></tr>
<tr class="separator:ac51bddb238dd93b8653067c0c64fbc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044c441415996a4391768b740384871b"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a044c441415996a4391768b740384871b">onRenderSettingsChangedDerived</a> () override</td></tr>
<tr class="separator:a044c441415996a4391768b740384871b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa790a607caa70247e134dfc452a0a49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#afa790a607caa70247e134dfc452a0a49">waitForGpuToFinishUsingFrameResource</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pFrameResource) override</td></tr>
<tr class="separator:afa790a607caa70247e134dfc452a0a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9922f163c30de28d88bab2218841fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aba9922f163c30de28d88bab2218841fd">isInitialized</a> () const override</td></tr>
<tr class="separator:aba9922f163c30de28d88bab2218841fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classne_1_1Renderer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classne_1_1Renderer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classne_1_1Renderer.html">ne::Renderer</a></td></tr>
<tr class="memitem:a5b5369cf5d1a7dffbde1ff17d54ce7ff inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a5b5369cf5d1a7dffbde1ff17d54ce7ff">Renderer</a> (<a class="el" href="classne_1_1GameManager.html">GameManager</a> *<a class="el" href="classne_1_1Renderer.html#a25e1de71d1ebe7b95281c7de8833986a">pGameManager</a>)</td></tr>
<tr class="separator:a5b5369cf5d1a7dffbde1ff17d54ce7ff inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ba4b9ee40da30d3c5724fcdade5117 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a02ba4b9ee40da30d3c5724fcdade5117">compileEngineShaders</a> () const</td></tr>
<tr class="separator:a02ba4b9ee40da30d3c5724fcdade5117 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fe2980b8802431726d3da64ea6aeeb inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a46fe2980b8802431726d3da64ea6aeeb">updateFrameConstantsBuffer</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, <a class="el" href="classne_1_1CameraProperties.html">CameraProperties</a> *pCameraProperties)</td></tr>
<tr class="separator:a46fe2980b8802431726d3da64ea6aeeb inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539114f74384e2bbdd14d5b9049e8a3 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#aa539114f74384e2bbdd14d5b9049e8a3">resetGpuResourceManager</a> ()</td></tr>
<tr class="separator:aa539114f74384e2bbdd14d5b9049e8a3 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59727774d2199a7ea0354224ecc819d inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ae59727774d2199a7ea0354224ecc819d">resetPipelineManager</a> ()</td></tr>
<tr class="separator:ae59727774d2199a7ea0354224ecc819d inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b97ea2de9b0293f89fb4280618a333 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a38b97ea2de9b0293f89fb4280618a333">resetFrameResourceManager</a> ()</td></tr>
<tr class="separator:a38b97ea2de9b0293f89fb4280618a333 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08726652b7affeb260c8719aaf469ced inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a08726652b7affeb260c8719aaf469ced">resetLightingShaderResourceManager</a> ()</td></tr>
<tr class="separator:a08726652b7affeb260c8719aaf469ced inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47325c92b874a8057d8abcfa1684a2a0 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual std::variant&lt; std::optional&lt; AntialiasingQuality &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a47325c92b874a8057d8abcfa1684a2a0">getMaxSupportedAntialiasingQuality</a> () const =0</td></tr>
<tr class="separator:a47325c92b874a8057d8abcfa1684a2a0 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e9d40f1b603f016147f8788a6e0a6f inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ad5e9d40f1b603f016147f8788a6e0a6f">onFramebufferSizeChanged</a> (int iWidth, int iHeight)</td></tr>
<tr class="separator:ad5e9d40f1b603f016147f8788a6e0a6f inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57afd8ef14e2dfbae2391aaed4c57bb5 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a57afd8ef14e2dfbae2391aaed4c57bb5">onFramebufferSizeChangedDerived</a> (int iWidth, int iHeight)</td></tr>
<tr class="separator:a57afd8ef14e2dfbae2391aaed4c57bb5 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5cd211faa4ab6680cc7e8c20e99d04 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a0c5cd211faa4ab6680cc7e8c20e99d04">drawNextFrame</a> ()</td></tr>
<tr class="separator:a0c5cd211faa4ab6680cc7e8c20e99d04 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1104f4c7c926b7ac3d2cc13c0e8fa799 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a1104f4c7c926b7ac3d2cc13c0e8fa799">prepareRenderTargetForNextFrame</a> ()</td></tr>
<tr class="separator:a1104f4c7c926b7ac3d2cc13c0e8fa799 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4ce85fd3babdb2f5ca69a1d76b54d inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ad9e4ce85fd3babdb2f5ca69a1d76b54d">prepareForDrawingNextFrame</a> (<a class="el" href="classne_1_1CameraProperties.html">CameraProperties</a> *pCameraProperties, <a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource)=0</td></tr>
<tr class="separator:ad9e4ce85fd3babdb2f5ca69a1d76b54d inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406150bfe82ba580d6ed7b2ea780c4e6 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a406150bfe82ba580d6ed7b2ea780c4e6">drawShadowMappingPass</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, <a class="el" href="structne_1_1GraphicsPipelineRegistry.html">GraphicsPipelineRegistry</a> *pGraphicsPipelines)=0</td></tr>
<tr class="separator:a406150bfe82ba580d6ed7b2ea780c4e6 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade28a2acfbf0d842310ed09e43347a6a inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ade28a2acfbf0d842310ed09e43347a6a">drawMeshesDepthPrepass</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;vOpaquePipelines)=0</td></tr>
<tr class="separator:ade28a2acfbf0d842310ed09e43347a6a inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159404d107fc2b9c62609f7a4b29158e inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a159404d107fc2b9c62609f7a4b29158e">executeComputeShadersOnGraphicsQueue</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, ComputeExecutionStage stage)=0</td></tr>
<tr class="separator:a159404d107fc2b9c62609f7a4b29158e inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c93c8411ed36b3a1a1d548b3119ed4 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ae7c93c8411ed36b3a1a1d548b3119ed4">drawMeshesMainPass</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;vOpaquePipelines, const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;vTransparentPipelines)=0</td></tr>
<tr class="separator:ae7c93c8411ed36b3a1a1d548b3119ed4 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3408af535d34d9cf26ccac19975d6403 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a3408af535d34d9cf26ccac19975d6403">present</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex)=0</td></tr>
<tr class="separator:a3408af535d34d9cf26ccac19975d6403 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8810b0fa64b1de6124922d4c1ee49b2 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ab8810b0fa64b1de6124922d4c1ee49b2">onRenderSettingsChanged</a> (bool bShadowMapSizeChanged=false)</td></tr>
<tr class="separator:ab8810b0fa64b1de6124922d4c1ee49b2 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc725e2a6ccfaac9ea4ef4fa2201a66 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a3cc725e2a6ccfaac9ea4ef4fa2201a66">onRenderSettingsChangedDerived</a> ()=0</td></tr>
<tr class="separator:a3cc725e2a6ccfaac9ea4ef4fa2201a66 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64332a4c9b10010ec74584dddc91c68d inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a64332a4c9b10010ec74584dddc91c68d">waitForGpuToFinishUsingFrameResource</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pFrameResource)=0</td></tr>
<tr class="separator:a64332a4c9b10010ec74584dddc91c68d inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f920f8d11ab50acac502c896161522 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a71f920f8d11ab50acac502c896161522">isInitialized</a> () const =0</td></tr>
<tr class="separator:a71f920f8d11ab50acac502c896161522 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53240d9f15a95b2f5af5c219e7f65051 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a53240d9f15a95b2f5af5c219e7f65051">initializeRenderer</a> ()</td></tr>
<tr class="separator:a53240d9f15a95b2f5af5c219e7f65051 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0108568bca8e4457756c6c51f51005e3 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a0108568bca8e4457756c6c51f51005e3">initializeResourceManagers</a> ()</td></tr>
<tr class="separator:a0108568bca8e4457756c6c51f51005e3 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05657ef406f0ed434e044730120bc50 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ad05657ef406f0ed434e044730120bc50">clampSettingsToMaxSupported</a> ()</td></tr>
<tr class="separator:ad05657ef406f0ed434e044730120bc50 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e71fc6ecff7925b5cda79dbc8dbcc5a inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a7e71fc6ecff7925b5cda79dbc8dbcc5a">recalculateLightTileFrustums</a> ()</td></tr>
<tr class="separator:a7e71fc6ecff7925b5cda79dbc8dbcc5a inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb527a8099001d8c3f60f0f546ea8fc9 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum.html">MeshesInFrustum</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#aeb527a8099001d8c3f60f0f546ea8fc9">getMeshesInCameraFrustum</a> (<a class="el" href="classne_1_1CameraProperties.html">CameraProperties</a> *pActiveCameraProperties, <a class="el" href="structne_1_1GraphicsPipelineRegistry.html">GraphicsPipelineRegistry</a> *pGraphicsPipelines)</td></tr>
<tr class="separator:aeb527a8099001d8c3f60f0f546ea8fc9 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c65b8eeb863809e7287596f9cfc926c inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a4c65b8eeb863809e7287596f9cfc926c">cullLightsOutsideCameraFrustum</a> (<a class="el" href="classne_1_1CameraProperties.html">CameraProperties</a> *pActiveCameraProperties, size_t iCurrentFrameResourceIndex)</td></tr>
<tr class="separator:a4c65b8eeb863809e7287596f9cfc926c inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6576b5f7eac84e7846e5b5fb6c0d1a12 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::mutex, <a class="el" href="structne_1_1FrameConstants.html">FrameConstants</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a6576b5f7eac84e7846e5b5fb6c0d1a12">getFrameConstants</a> ()</td></tr>
<tr class="separator:a6576b5f7eac84e7846e5b5fb6c0d1a12 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb0d87cb12c66c71c5922f942d5da71 inherit pro_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a4cb0d87cb12c66c71c5922f942d5da71">getDrawCallCounter</a> ()</td></tr>
<tr class="separator:a4cb0d87cb12c66c71c5922f942d5da71 inherit pro_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3c46c72809425573ad938dfb4e131ccc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a3c46c72809425573ad938dfb4e131ccc">initialize</a> (const std::vector&lt; std::string &gt; &amp;vBlacklistedGpuNames)</td></tr>
<tr class="separator:a3c46c72809425573ad938dfb4e131ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bbc7d6b14f8a8b6a9ac9790ba1b8db"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a44bbc7d6b14f8a8b6a9ac9790ba1b8db">initializeVulkan</a> (const std::vector&lt; std::string &gt; &amp;vBlacklistedGpuNames)</td></tr>
<tr class="separator:a44bbc7d6b14f8a8b6a9ac9790ba1b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5f2dc988ff0dbbda8aabdfe393ae5f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a9a5f2dc988ff0dbbda8aabdfe393ae5f">createVulkanInstance</a> ()</td></tr>
<tr class="separator:a9a5f2dc988ff0dbbda8aabdfe393ae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586500bcb331bb423a61ac9bddb30436"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a586500bcb331bb423a61ac9bddb30436">createWindowSurface</a> ()</td></tr>
<tr class="separator:a586500bcb331bb423a61ac9bddb30436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4690a07dc723725e760768b1a454ec01"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a4690a07dc723725e760768b1a454ec01">rateGpuSuitability</a> (VkPhysicalDevice pGpuDevice)</td></tr>
<tr class="separator:a4690a07dc723725e760768b1a454ec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ad1d11a7975507e79ce9e1e9e7b610"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a81ad1d11a7975507e79ce9e1e9e7b610">isDeviceSuitable</a> (VkPhysicalDevice pGpu)</td></tr>
<tr class="separator:a81ad1d11a7975507e79ce9e1e9e7b610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b70ab9bf361cd01f7ccac5545766ba"><td class="memItemLeft" align="right" valign="top">std::variant&lt; <a class="el" href="structne_1_1VulkanRenderer_1_1SwapChainSupportDetails.html">SwapChainSupportDetails</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a47b70ab9bf361cd01f7ccac5545766ba">querySwapChainSupportDetails</a> (VkPhysicalDevice pGpu)</td></tr>
<tr class="separator:a47b70ab9bf361cd01f7ccac5545766ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1676cee71601db7969ab9993bfedb590"><td class="memItemLeft" align="right" valign="top">std::variant&lt; <a class="el" href="structne_1_1VulkanRenderer_1_1QueueFamilyIndices.html">VulkanRenderer::QueueFamilyIndices</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a1676cee71601db7969ab9993bfedb590">queryQueueFamilyIndices</a> (VkPhysicalDevice pGpu)</td></tr>
<tr class="separator:a1676cee71601db7969ab9993bfedb590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022a996bf0a4ffe8ff63a43b6af9b6e6"><td class="memItemLeft" align="right" valign="top">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a022a996bf0a4ffe8ff63a43b6af9b6e6">isGpuSupportsSwapChain</a> (VkPhysicalDevice pGpu)</td></tr>
<tr class="separator:a022a996bf0a4ffe8ff63a43b6af9b6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d17f56242f67d07950c3fb0169d9ffa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a2d17f56242f67d07950c3fb0169d9ffa">pickPhysicalDevice</a> (const std::vector&lt; std::string &gt; &amp;vBlacklistedGpuNames)</td></tr>
<tr class="separator:a2d17f56242f67d07950c3fb0169d9ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03701aac30a708bd63b42c77ce55618"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ac03701aac30a708bd63b42c77ce55618">createLogicalDevice</a> ()</td></tr>
<tr class="separator:ac03701aac30a708bd63b42c77ce55618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e7cdf043898ecb3941625e48e43d51"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a12e7cdf043898ecb3941625e48e43d51">createSwapChain</a> ()</td></tr>
<tr class="separator:a12e7cdf043898ecb3941625e48e43d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade11ccb2b6db9600acda37859587df57"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ade11ccb2b6db9600acda37859587df57">createCommandPool</a> ()</td></tr>
<tr class="separator:ade11ccb2b6db9600acda37859587df57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac673f06adac6b10b0d9773de553873d9"><td class="memItemLeft" align="right" valign="top">std::variant&lt; VkExtent2D, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ac673f06adac6b10b0d9773de553873d9">pickSwapChainExtent</a> (const VkSurfaceCapabilitiesKHR &amp;surfaceCapabilities)</td></tr>
<tr class="separator:ac673f06adac6b10b0d9773de553873d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d78098e6ef1c645f722fefcd8f494d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ab8d78098e6ef1c645f722fefcd8f494d">createRenderPasses</a> (bool bIsRendererInitialization)</td></tr>
<tr class="separator:ab8d78098e6ef1c645f722fefcd8f494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a2829ecb547e4bb6ccce2b92d8e943"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ac3a2829ecb547e4bb6ccce2b92d8e943">createMainRenderPass</a> ()</td></tr>
<tr class="separator:ac3a2829ecb547e4bb6ccce2b92d8e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0609c18ccac6662fa096258a93718"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aecb0609c18ccac6662fa096258a93718">createDepthOnlyRenderPass</a> ()</td></tr>
<tr class="separator:aecb0609c18ccac6662fa096258a93718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e46570dd6eff948ed4c9954002b433"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a34e46570dd6eff948ed4c9954002b433">createShadowMappingRenderPasses</a> ()</td></tr>
<tr class="separator:a34e46570dd6eff948ed4c9954002b433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245053a3aed78b4cc1b8e1c1c416d21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a245053a3aed78b4cc1b8e1c1c416d21c">destroySwapChainAndDependentResources</a> (bool bDestroyPipelineManager)</td></tr>
<tr class="separator:a245053a3aed78b4cc1b8e1c1c416d21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3eecaa238f8629a3a1932861dc891a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a6c3eecaa238f8629a3a1932861dc891a">createTextureSamplers</a> ()</td></tr>
<tr class="separator:a6c3eecaa238f8629a3a1932861dc891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1710a797dad8501705c06d307cf48c81"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a1710a797dad8501705c06d307cf48c81">createComputeTextureSampler</a> ()</td></tr>
<tr class="separator:a1710a797dad8501705c06d307cf48c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc002e2b0f9a23dfb3901201fb576cd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#afcc002e2b0f9a23dfb3901201fb576cd">createShadowTextureSampler</a> ()</td></tr>
<tr class="separator:afcc002e2b0f9a23dfb3901201fb576cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535406f12090a37dbdbb0c3de64c6265"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a535406f12090a37dbdbb0c3de64c6265">isUsedDepthImageFormatSupported</a> ()</td></tr>
<tr class="separator:a535406f12090a37dbdbb0c3de64c6265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1974da9773bc5908a0c8c482d9583a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a3c1974da9773bc5908a0c8c482d9583a">createDepthImage</a> ()</td></tr>
<tr class="separator:a3c1974da9773bc5908a0c8c482d9583a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa531822b46e63a1df0396bd9877b3eca"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aa531822b46e63a1df0396bd9877b3eca">createMsaaImage</a> ()</td></tr>
<tr class="separator:aa531822b46e63a1df0396bd9877b3eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a93662bc19a87d3df0afe21466941a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ab7a93662bc19a87d3df0afe21466941a">recreateSwapChainAndDependentResources</a> ()</td></tr>
<tr class="separator:ab7a93662bc19a87d3df0afe21466941a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baf0a69e479a0c765cbd89a7434695a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a1baf0a69e479a0c765cbd89a7434695a">createSwapChainFramebuffers</a> ()</td></tr>
<tr class="separator:a1baf0a69e479a0c765cbd89a7434695a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda042e148260fe4693b728775a91740"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aeda042e148260fe4693b728775a91740">prepareRenderTargetForNextFrame</a> () override</td></tr>
<tr class="separator:aeda042e148260fe4693b728775a91740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbedcc94ae5a0149ef01122c578fd68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aedbedcc94ae5a0149ef01122c578fd68">prepareForDrawingNextFrame</a> (<a class="el" href="classne_1_1CameraProperties.html">CameraProperties</a> *pCameraProperties, <a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource) override</td></tr>
<tr class="separator:aedbedcc94ae5a0149ef01122c578fd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02641d6d9eb0a4da9d07eca2f6df847"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ac02641d6d9eb0a4da9d07eca2f6df847">startMainRenderPass</a> (VkCommandBuffer pCommandBuffer, size_t iAcquiredImageIndex)</td></tr>
<tr class="separator:ac02641d6d9eb0a4da9d07eca2f6df847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4d6c9fdc4a49289136ba7d47946b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a4f4d6c9fdc4a49289136ba7d47946b38">startDepthOnlyRenderPass</a> (VkCommandBuffer pCommandBuffer, size_t iAcquiredImageIndex)</td></tr>
<tr class="separator:a4f4d6c9fdc4a49289136ba7d47946b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f11c831e45a8489c2e15ba2fbc26dc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a1f11c831e45a8489c2e15ba2fbc26dc9">drawShadowMappingPass</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, <a class="el" href="structne_1_1GraphicsPipelineRegistry.html">GraphicsPipelineRegistry</a> *pGraphicsPipelines) override</td></tr>
<tr class="separator:a1f11c831e45a8489c2e15ba2fbc26dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adfef1f5c1a3d766b60594b1671e310"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a9adfef1f5c1a3d766b60594b1671e310">drawMeshesDepthPrepass</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;vOpaquePipelines) override</td></tr>
<tr class="separator:a9adfef1f5c1a3d766b60594b1671e310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0491f1ed9a420d8758f7091398d2bc88"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a0491f1ed9a420d8758f7091398d2bc88">executeComputeShadersOnGraphicsQueue</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, ComputeExecutionStage stage) override</td></tr>
<tr class="separator:a0491f1ed9a420d8758f7091398d2bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab379f5bf43b961a79dfe11bd1cd2b0a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ab379f5bf43b961a79dfe11bd1cd2b0a9">drawMeshesMainPass</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;vOpaquePipelines, const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;vTransparentPipelines) override</td></tr>
<tr class="separator:ab379f5bf43b961a79dfe11bd1cd2b0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5e581efdf77fd3e927a5a58d4f89da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a1a5e581efdf77fd3e927a5a58d4f89da">present</a> (<a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex) override</td></tr>
<tr class="separator:a1a5e581efdf77fd3e927a5a58d4f89da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1ccacfb1ed1749dfb2c75aecdb7a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#afa1ccacfb1ed1749dfb2c75aecdb7a77">drawMeshesMainPassSpecificPipelines</a> (const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;pipelinesOfSpecificType, VkCommandBuffer pCommandBuffer, size_t iCurrentFrameResourceIndex)</td></tr>
<tr class="separator:afa1ccacfb1ed1749dfb2c75aecdb7a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8c74ba10f06441ddcdc4cb989e7aec"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a8a8c74ba10f06441ddcdc4cb989e7aec">updateMsaaSampleCount</a> ()</td></tr>
<tr class="separator:a8a8c74ba10f06441ddcdc4cb989e7aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ad54eb71349aae9c81c5068f43ea488e0"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::vector&lt; const char * &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ad54eb71349aae9c81c5068f43ea488e0">getRequiredVulkanInstanceExtensions</a> ()</td></tr>
<tr class="separator:ad54eb71349aae9c81c5068f43ea488e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba975934c63978e6abe5d81a18a63a92"><td class="memItemLeft" align="right" valign="top">static std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aba975934c63978e6abe5d81a18a63a92">isGpuSupportsUsedDeviceExtensions</a> (VkPhysicalDevice pGpuDevice)</td></tr>
<tr class="separator:aba975934c63978e6abe5d81a18a63a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc006ddec7ab5d6a4e495efaff01058a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#adc006ddec7ab5d6a4e495efaff01058a">startShadowMappingRenderPass</a> (VkRenderPass pShadowMappingRenderPass, VkCommandBuffer pCommandBuffer, VkFramebuffer pFramebufferToUse, uint32_t iShadowMapSize)</td></tr>
<tr class="separator:adc006ddec7ab5d6a4e495efaff01058a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dec7fcf5ddc1f4bcabb94a091fa68e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a71dec7fcf5ddc1f4bcabb94a091fa68e">dispatchComputeShadersOnGraphicsQueue</a> (<a class="el" href="structne_1_1VulkanFrameResource.html">VulkanFrameResource</a> *pCurrentFrameResource, size_t iCurrentFrameResourceIndex, std::unordered_map&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *, std::unordered_set&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> * &gt; &gt; &amp;computePipelinesToSubmit)</td></tr>
<tr class="separator:a71dec7fcf5ddc1f4bcabb94a091fa68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae7d8f3d9cbc80dfec91abfc84f8f4ef1"><td class="memItemLeft" align="right" valign="top">VkInstance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ae7d8f3d9cbc80dfec91abfc84f8f4ef1">pInstance</a> = nullptr</td></tr>
<tr class="separator:ae7d8f3d9cbc80dfec91abfc84f8f4ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4ef9ce95ed2cd2985a75e2a669dfda"><td class="memItemLeft" align="right" valign="top">VkSurfaceKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#adc4ef9ce95ed2cd2985a75e2a669dfda">pWindowSurface</a> = nullptr</td></tr>
<tr class="separator:adc4ef9ce95ed2cd2985a75e2a669dfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf590460af70c900d8f03e7f9c039b5a"><td class="memItemLeft" align="right" valign="top">VkPhysicalDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aaf590460af70c900d8f03e7f9c039b5a">pPhysicalDevice</a> = nullptr</td></tr>
<tr class="separator:aaf590460af70c900d8f03e7f9c039b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b72ac67263d9e718f95214a823c8865"><td class="memItemLeft" align="right" valign="top">VkDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> = nullptr</td></tr>
<tr class="separator:a4b72ac67263d9e718f95214a823c8865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94ec4223715e882d2a6a10fce46875a"><td class="memItemLeft" align="right" valign="top">VkQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#af94ec4223715e882d2a6a10fce46875a">pGraphicsQueue</a> = nullptr</td></tr>
<tr class="separator:af94ec4223715e882d2a6a10fce46875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57df121e6648a8ecf76af55bc3e7436d"><td class="memItemLeft" align="right" valign="top">VkQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a57df121e6648a8ecf76af55bc3e7436d">pPresentQueue</a> = nullptr</td></tr>
<tr class="separator:a57df121e6648a8ecf76af55bc3e7436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76aec9c5294592503420f83df985759"><td class="memItemLeft" align="right" valign="top">VkSwapchainKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ac76aec9c5294592503420f83df985759">pSwapChain</a> = nullptr</td></tr>
<tr class="separator:ac76aec9c5294592503420f83df985759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381afdbdc2e4df87806f51a443f02b62"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classne_1_1VulkanResource.html">VulkanResource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a381afdbdc2e4df87806f51a443f02b62">pDepthImage</a> = nullptr</td></tr>
<tr class="separator:a381afdbdc2e4df87806f51a443f02b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eae1fbd4b5d52b925ddf1521d8d7d58"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classne_1_1VulkanResource.html">VulkanResource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a6eae1fbd4b5d52b925ddf1521d8d7d58">pDepthImageNoMultisampling</a> = nullptr</td></tr>
<tr class="separator:a6eae1fbd4b5d52b925ddf1521d8d7d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a6cc1e77934c7974abcf2fafa4e13e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classne_1_1VulkanResource.html">VulkanResource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a57a6cc1e77934c7974abcf2fafa4e13e">pMsaaImage</a> = nullptr</td></tr>
<tr class="separator:a57a6cc1e77934c7974abcf2fafa4e13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef93999ba66bac87974a444092be9a52"><td class="memItemLeft" align="right" valign="top">VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aef93999ba66bac87974a444092be9a52">pDepthOnlyRenderPass</a> = nullptr</td></tr>
<tr class="separator:aef93999ba66bac87974a444092be9a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd3c39cbed7a71daca4113101946452"><td class="memItemLeft" align="right" valign="top">VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aecd3c39cbed7a71daca4113101946452">pMainRenderPass</a> = nullptr</td></tr>
<tr class="separator:aecd3c39cbed7a71daca4113101946452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e87cc69b9b840872f5a3bc67a4be30"><td class="memItemLeft" align="right" valign="top">VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a68e87cc69b9b840872f5a3bc67a4be30">pShadowMappingDirectionalSpotRenderPass</a> = nullptr</td></tr>
<tr class="separator:a68e87cc69b9b840872f5a3bc67a4be30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5aaea6b30613e856567eec78172039"><td class="memItemLeft" align="right" valign="top">VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a0c5aaea6b30613e856567eec78172039">pShadowMappingPointRenderPass</a> = nullptr</td></tr>
<tr class="separator:a0c5aaea6b30613e856567eec78172039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26466d01d327fa6c08f70952c1c4fcd1"><td class="memItemLeft" align="right" valign="top">VkCommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a26466d01d327fa6c08f70952c1c4fcd1">pCommandPool</a> = nullptr</td></tr>
<tr class="separator:a26466d01d327fa6c08f70952c1c4fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2226a46942e005cdc11124e4dd7b3638"><td class="memItemLeft" align="right" valign="top">VkSampler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a2226a46942e005cdc11124e4dd7b3638">pTextureSamplerPointFiltering</a> = nullptr</td></tr>
<tr class="separator:a2226a46942e005cdc11124e4dd7b3638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd88a0050737024ca1c3b09993fb6fb"><td class="memItemLeft" align="right" valign="top">VkSampler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aacd88a0050737024ca1c3b09993fb6fb">pTextureSamplerLinearFiltering</a> = nullptr</td></tr>
<tr class="separator:aacd88a0050737024ca1c3b09993fb6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c6940e0c054cf4e3863c046b31816c"><td class="memItemLeft" align="right" valign="top">VkSampler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aa7c6940e0c054cf4e3863c046b31816c">pTextureSamplerAnisotropicFiltering</a> = nullptr</td></tr>
<tr class="separator:aa7c6940e0c054cf4e3863c046b31816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcf2cea84ab332c38127a6730281b82"><td class="memItemLeft" align="right" valign="top">VkSampler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a5bcf2cea84ab332c38127a6730281b82">pComputeTextureSampler</a> = nullptr</td></tr>
<tr class="separator:a5bcf2cea84ab332c38127a6730281b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc1856c23bbdf9a97819a2cc9fcd6d7"><td class="memItemLeft" align="right" valign="top">VkSampler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#affc1856c23bbdf9a97819a2cc9fcd6d7">pShadowTextureSampler</a> = nullptr</td></tr>
<tr class="separator:affc1856c23bbdf9a97819a2cc9fcd6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c109ccbb605587115f78f679b9cd99"><td class="memItemLeft" align="right" valign="top">std::vector&lt; VkImage &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ad4c109ccbb605587115f78f679b9cd99">vSwapChainImages</a></td></tr>
<tr class="separator:ad4c109ccbb605587115f78f679b9cd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab177c322afec734df3855099a18ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; VkImageView &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a00ab177c322afec734df3855099a18ce">vSwapChainImageViews</a></td></tr>
<tr class="separator:a00ab177c322afec734df3855099a18ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71551705046c22f849d76ad47cdd732"><td class="memItemLeft" align="right" valign="top">std::vector&lt; VkFramebuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#af71551705046c22f849d76ad47cdd732">vSwapChainFramebuffersMainRenderPass</a></td></tr>
<tr class="separator:af71551705046c22f849d76ad47cdd732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4083804472a4c73560767f159f8486c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; VkFramebuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ab4083804472a4c73560767f159f8486c">vSwapChainFramebuffersDepthOnlyRenderPass</a></td></tr>
<tr class="separator:ab4083804472a4c73560767f159f8486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ae0ffb38e78bf0ba8f08b3f45cd44"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; VkFence, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#af43ae0ffb38e78bf0ba8f08b3f45cd44">vSwapChainImageFenceRefs</a></td></tr>
<tr class="separator:af43ae0ffb38e78bf0ba8f08b3f45cd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929cdba2f3e2706c1c3b505f7f349377"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structne_1_1VulkanRenderer_1_1SwapChainImageSemaphores.html">SwapChainImageSemaphores</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a929cdba2f3e2706c1c3b505f7f349377">vImageSemaphores</a></td></tr>
<tr class="separator:a929cdba2f3e2706c1c3b505f7f349377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad760e367dfdc6635cd2e4d8cd8c0f9ab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ad760e367dfdc6635cd2e4d8cd8c0f9ab">iCurrentImageSemaphore</a> = 0</td></tr>
<tr class="separator:ad760e367dfdc6635cd2e4d8cd8c0f9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f265697a9a8b83fbfe4753510b24763"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a5f265697a9a8b83fbfe4753510b24763">vSupportedGpuNames</a></td></tr>
<tr class="separator:a5f265697a9a8b83fbfe4753510b24763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4db7fe74b51ff3cc4f9f6aadff8dc6c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ac4db7fe74b51ff3cc4f9f6aadff8dc6c">sUsedGpuName</a></td></tr>
<tr class="separator:ac4db7fe74b51ff3cc4f9f6aadff8dc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8632129baa17acf6324c4ff9cf4fb6f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structne_1_1VulkanRenderer_1_1QueueFamilyIndices.html">QueueFamilyIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a8632129baa17acf6324c4ff9cf4fb6f8">physicalDeviceQueueFamilyIndices</a></td></tr>
<tr class="separator:a8632129baa17acf6324c4ff9cf4fb6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c46a9d3b0553c0a990bda93c7cbe6c9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; VkExtent2D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a2c46a9d3b0553c0a990bda93c7cbe6c9">swapChainExtent</a></td></tr>
<tr class="separator:a2c46a9d3b0553c0a990bda93c7cbe6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b42f573c4591e2778172503d8cd4d0d"><td class="memItemLeft" align="right" valign="top">VkSampleCountFlagBits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a9b42f573c4591e2778172503d8cd4d0d">msaaSampleCount</a> = VK_SAMPLE_COUNT_1_BIT</td></tr>
<tr class="separator:a9b42f573c4591e2778172503d8cd4d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cf860ba0c5cfee1a3b004e3059ebfb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a35cf860ba0c5cfee1a3b004e3059ebfb">iSwapChainImageCount</a> = 0</td></tr>
<tr class="separator:a35cf860ba0c5cfee1a3b004e3059ebfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcba807d95a120c70073fc34ee004ac"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a7fcba807d95a120c70073fc34ee004ac">iLastAcquiredImageIndex</a> = 0</td></tr>
<tr class="separator:a7fcba807d95a120c70073fc34ee004ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ef179470bc3740973f5f94567310b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a24ef179470bc3740973f5f94567310b9">bIsVulkanInitialized</a> = false</td></tr>
<tr class="separator:a24ef179470bc3740973f5f94567310b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260f960d9ffa0f044738eff73bdd4784"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a260f960d9ffa0f044738eff73bdd4784">bNeedToRecreateSwapchain</a> = false</td></tr>
<tr class="separator:a260f960d9ffa0f044738eff73bdd4784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bf971931daf9f0ca0adb71e763c4a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a75bf971931daf9f0ca0adb71e763c4a8">bIsUsingMsaaRenderTarget</a> = false</td></tr>
<tr class="separator:a75bf971931daf9f0ca0adb71e763c4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c02c3788b4cbf31e171783c416ce3b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a4c02c3788b4cbf31e171783c416ce3b0">bIsBeingDestroyed</a> = false</td></tr>
<tr class="separator:a4c02c3788b4cbf31e171783c416ce3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a1de07c4ad8280ce9dad181aa053bbc64"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a1de07c4ad8280ce9dad181aa053bbc64">iMainRenderPassColorAttachmentIndex</a> = 0</td></tr>
<tr class="separator:a1de07c4ad8280ce9dad181aa053bbc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba65d4956388418e59bc6deb8b613e"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a92ba65d4956388418e59bc6deb8b613e">iMainRenderPassDepthAttachmentIndex</a> = 1</td></tr>
<tr class="separator:a92ba65d4956388418e59bc6deb8b613e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf90eae1124256195e3940020aba0072"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#adf90eae1124256195e3940020aba0072">iMainRenderPassColorResolveTargetAttachmentIndex</a> = 2</td></tr>
<tr class="separator:adf90eae1124256195e3940020aba0072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a02beb2a5ddf30d137775ae689b7e42"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a7a02beb2a5ddf30d137775ae689b7e42">iDepthOnlyRenderPassDepthImageAttachmentIndex</a> = 0</td></tr>
<tr class="separator:a7a02beb2a5ddf30d137775ae689b7e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadb8a4947d61794e42e754432015a26"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#aaadb8a4947d61794e42e754432015a26">iDepthOnlyRenderPassDepthResolveTargetAttachmentIndex</a> = 1</td></tr>
<tr class="separator:aaadb8a4947d61794e42e754432015a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b79b60342a809010a052fa71970066"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ae8b79b60342a809010a052fa71970066">swapChainImageFormat</a> = VK_FORMAT_B8G8R8A8_UNORM</td></tr>
<tr class="separator:ae8b79b60342a809010a052fa71970066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bc1b785d9580a11a7607f5bc27654c"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a48bc1b785d9580a11a7607f5bc27654c">swapChainImageColorSpace</a> = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</td></tr>
<tr class="separator:a48bc1b785d9580a11a7607f5bc27654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277331e6e8951e7db11500a9adde3639"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a277331e6e8951e7db11500a9adde3639">depthImageFormat</a> = VK_FORMAT_D32_SFLOAT</td></tr>
<tr class="separator:a277331e6e8951e7db11500a9adde3639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae373f4efe6fdfd5e0b6bb7c11744b2ab"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#ae373f4efe6fdfd5e0b6bb7c11744b2ab">shadowMapFormat</a> = VK_FORMAT_D32_SFLOAT</td></tr>
<tr class="separator:ae373f4efe6fdfd5e0b6bb7c11744b2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6e8c90a17cdd220d2e283f6d477b07"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a8c6e8c90a17cdd220d2e283f6d477b07">shadowMappingPointLightColorTargetFormat</a> = VK_FORMAT_R32_SFLOAT</td></tr>
<tr class="separator:a8c6e8c90a17cdd220d2e283f6d477b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b309f5f59fed39563d3fe2893b82d1"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a59b309f5f59fed39563d3fe2893b82d1">depthImageTiling</a> = VK_IMAGE_TILING_OPTIMAL</td></tr>
<tr class="separator:a59b309f5f59fed39563d3fe2893b82d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bd70cca7ae7440e0cbe802ca81447f"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a97bd70cca7ae7440e0cbe802ca81447f">indexTypeFormat</a> = VK_INDEX_TYPE_UINT32</td></tr>
<tr class="separator:a97bd70cca7ae7440e0cbe802ca81447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2687dad58c52e725cda098c14582e0"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a5f2687dad58c52e725cda098c14582e0">depthResolveMode</a> = VK_RESOLVE_MODE_MAX_BIT</td></tr>
<tr class="separator:a5f2687dad58c52e725cda098c14582e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe61b6d29c18f3fe82834ab9cadab702"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#abe61b6d29c18f3fe82834ab9cadab702">stencilResolveMode</a> = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT</td></tr>
<tr class="separator:abe61b6d29c18f3fe82834ab9cadab702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53d53fb3c12c28b016fda142cdd18f2"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#af53d53fb3c12c28b016fda142cdd18f2">iUsedVulkanVersion</a> = VK_API_VERSION_1_2</td></tr>
<tr class="separator:af53d53fb3c12c28b016fda142cdd18f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f63236458627346b36fd4f34ec22850"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1VulkanRenderer.html#a7f63236458627346b36fd4f34ec22850">vUsedDeviceExtensionNames</a></td></tr>
<tr class="separator:a7f63236458627346b36fd4f34ec22850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_classne_1_1Renderer"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classne_1_1Renderer')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classne_1_1Renderer.html">ne::Renderer</a></td></tr>
<tr class="memitem:a71c2681a6e9f19c6bc27c40edd6957d8 inherit pro_static_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">static consteval unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a71c2681a6e9f19c6bc27c40edd6957d8">getRecommendedSwapChainBufferCount</a> ()</td></tr>
<tr class="separator:a71c2681a6e9f19c6bc27c40edd6957d8 inherit pro_static_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c1e754bb8669365ff64f726e22f253 inherit pro_static_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a20c1e754bb8669365ff64f726e22f253">getDirectionalLightNodeShadowMappingInfo</a> (<a class="el" href="classne_1_1DirectionalLightNode.html">DirectionalLightNode</a> *pNode, <a class="el" href="classne_1_1ShadowMapHandle.html">ShadowMapHandle</a> *&amp;pShadowMapHandle, unsigned int &amp;iShadowPassLightInfoArrayIndex)</td></tr>
<tr class="separator:a20c1e754bb8669365ff64f726e22f253 inherit pro_static_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08311905dc6df3bf29f08b23b2e30cb inherit pro_static_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ad08311905dc6df3bf29f08b23b2e30cb">getSpotlightNodeShadowMappingInfo</a> (<a class="el" href="classne_1_1SpotlightNode.html">SpotlightNode</a> *pNode, <a class="el" href="classne_1_1ShadowMapHandle.html">ShadowMapHandle</a> *&amp;pShadowMapHandle, unsigned int &amp;iShadowPassLightInfoArrayIndex)</td></tr>
<tr class="separator:ad08311905dc6df3bf29f08b23b2e30cb inherit pro_static_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fe9634ba28331a5c7808e41aee8280 inherit pro_static_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#ae3fe9634ba28331a5c7808e41aee8280">getPointLightShadowPassLightInfoArrayIndex</a> (<a class="el" href="classne_1_1PointLightNode.html">PointLightNode</a> *pNode, size_t iCubemapFaceIndex)</td></tr>
<tr class="separator:ae3fe9634ba28331a5c7808e41aee8280 inherit pro_static_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aacf3db90f19ab0153ba61d5d375d9 inherit pro_static_methods_classne_1_1Renderer"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classne_1_1ShadowMapHandle.html">ShadowMapHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classne_1_1Renderer.html#a89aacf3db90f19ab0153ba61d5d375d9">getPointLightNodeShadowMapHandle</a> (<a class="el" href="classne_1_1PointLightNode.html">PointLightNode</a> *pNode)</td></tr>
<tr class="separator:a89aacf3db90f19ab0153ba61d5d375d9 inherit pro_static_methods_classne_1_1Renderer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="classne_1_1Renderer.html">Renderer</a> made with Vulkan API. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2cd8cc2433f8da659e5e72f315f7ec4c" name="a2cd8cc2433f8da659e5e72f315f7ec4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd8cc2433f8da659e5e72f315f7ec4c">&#9670;&#160;</a></span>VulkanRenderer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ne::VulkanRenderer::VulkanRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1GameManager.html">GameManager</a> *&#160;</td>
          <td class="paramname"><em>pGameManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates an empty (uninitialized) renderer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Use <a class="el" href="classne_1_1VulkanRenderer.html#a3c46c72809425573ad938dfb4e131ccc">initialize</a> to initialize the renderer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGameManager</td><td><a class="el" href="classne_1_1GameManager.html">GameManager</a> object that owns this renderer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a72f6619897fdb3232624e240783970ad" name="a72f6619897fdb3232624e240783970ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f6619897fdb3232624e240783970ad">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::unique_ptr&lt; <a class="el" href="classne_1_1Renderer.html">Renderer</a> &gt;, std::pair&lt; <a class="el" href="classne_1_1Error.html">Error</a>, std::string &gt; &gt; ne::VulkanRenderer::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1GameManager.html">GameManager</a> *&#160;</td>
          <td class="paramname"><em>pGameManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vBlacklistedGpuNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new DirectX renderer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGameManager</td><td><a class="el" href="classne_1_1GameManager.html">GameManager</a> object that owns this renderer. </td></tr>
    <tr><td class="paramname">vBlacklistedGpuNames</td><td>Names of GPUs that should not be used, generally this means that these GPUs were previously used to create the renderer but something went wrong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created renderer if successful, otherwise multiple values in a pair: error and a name of the GPU that the renderer tried to use (can be empty if failed before picking a GPU or if all supported GPUs are blacklisted). </dd></dl>

</div>
</div>
<a id="ade11ccb2b6db9600acda37859587df57" name="ade11ccb2b6db9600acda37859587df57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade11ccb2b6db9600acda37859587df57">&#9670;&#160;</a></span>createCommandPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates <a class="el" href="classne_1_1VulkanRenderer.html#a26466d01d327fa6c08f70952c1c4fcd1">pCommandPool</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> to be valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a1710a797dad8501705c06d307cf48c81" name="a1710a797dad8501705c06d307cf48c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1710a797dad8501705c06d307cf48c81">&#9670;&#160;</a></span>createComputeTextureSampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createComputeTextureSampler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates <a class="el" href="classne_1_1VulkanRenderer.html#a5bcf2cea84ab332c38127a6730281b82">pComputeTextureSampler</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> is valid.</dd>
<dd>
Expected to be called only once so that this sampler will never be re-created.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a3c1974da9773bc5908a0c8c482d9583a" name="a3c1974da9773bc5908a0c8c482d9583a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1974da9773bc5908a0c8c482d9583a">&#9670;&#160;</a></span>createDepthImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createDepthImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates <a class="el" href="classne_1_1VulkanRenderer.html#a381afdbdc2e4df87806f51a443f02b62">pDepthImage</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that GPU resource manager and <a class="el" href="classne_1_1VulkanRenderer.html#a2c46a9d3b0553c0a990bda93c7cbe6c9">swapChainExtent</a> are valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="aecb0609c18ccac6662fa096258a93718" name="aecb0609c18ccac6662fa096258a93718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb0609c18ccac6662fa096258a93718">&#9670;&#160;</a></span>createDepthOnlyRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createDepthOnlyRenderPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates <a class="el" href="classne_1_1VulkanRenderer.html#aef93999ba66bac87974a444092be9a52">pDepthOnlyRenderPass</a> (z-prepass) using the current <a class="el" href="classne_1_1VulkanRenderer.html#a9b42f573c4591e2778172503d8cd4d0d">msaaSampleCount</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> to be valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="ac03701aac30a708bd63b42c77ce55618" name="ac03701aac30a708bd63b42c77ce55618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03701aac30a708bd63b42c77ce55618">&#9670;&#160;</a></span>createLogicalDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createLogicalDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#aaf590460af70c900d8f03e7f9c039b5a">pPhysicalDevice</a> to be valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="ac3a2829ecb547e4bb6ccce2b92d8e943" name="ac3a2829ecb547e4bb6ccce2b92d8e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a2829ecb547e4bb6ccce2b92d8e943">&#9670;&#160;</a></span>createMainRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createMainRenderPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates <a class="el" href="classne_1_1VulkanRenderer.html#aecd3c39cbed7a71daca4113101946452">pMainRenderPass</a> using the current <a class="el" href="classne_1_1VulkanRenderer.html#a9b42f573c4591e2778172503d8cd4d0d">msaaSampleCount</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> to be valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="aa531822b46e63a1df0396bd9877b3eca" name="aa531822b46e63a1df0396bd9877b3eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa531822b46e63a1df0396bd9877b3eca">&#9670;&#160;</a></span>createMsaaImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createMsaaImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates <a class="el" href="classne_1_1VulkanRenderer.html#a57a6cc1e77934c7974abcf2fafa4e13e">pMsaaImage</a> using the current <a class="el" href="classne_1_1VulkanRenderer.html#a9b42f573c4591e2778172503d8cd4d0d">msaaSampleCount</a> (does nothing if only 1 sample is used).</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that GPU resource manager and <a class="el" href="classne_1_1VulkanRenderer.html#a2c46a9d3b0553c0a990bda93c7cbe6c9">swapChainExtent</a> are valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a6ba6849ba3e37cc117afec21b339f97e" name="a6ba6849ba3e37cc117afec21b339f97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba6849ba3e37cc117afec21b339f97e">&#9670;&#160;</a></span>createOneTimeSubmitCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; VkCommandBuffer, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createOneTimeSubmitCommandBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new one-time submit command buffer to be later used with <a class="el" href="classne_1_1VulkanRenderer.html#a5be101433f7df8f6fedfd7d4d3f4985e">submitWaitDestroyOneTimeSubmitCommandBuffer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise created command buffer. </dd></dl>

</div>
</div>
<a id="ab8d78098e6ef1c645f722fefcd8f494d" name="ab8d78098e6ef1c645f722fefcd8f494d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d78098e6ef1c645f722fefcd8f494d">&#9670;&#160;</a></span>createRenderPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createRenderPasses </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsRendererInitialization</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates render passes using the current <a class="el" href="classne_1_1VulkanRenderer.html#a9b42f573c4591e2778172503d8cd4d0d">msaaSampleCount</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> to be valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIsRendererInitialization</td><td>Specify <code>true</code> if the renderer is doing initialization, <code>false</code> if some render settings (or similar) was changed and the renderer re-creates resources that may depend on changed settings/parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a34e46570dd6eff948ed4c9954002b433" name="a34e46570dd6eff948ed4c9954002b433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e46570dd6eff948ed4c9954002b433">&#9670;&#160;</a></span>createShadowMappingRenderPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createShadowMappingRenderPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates render passes used in shadow mapping.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> to be valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="afcc002e2b0f9a23dfb3901201fb576cd" name="afcc002e2b0f9a23dfb3901201fb576cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc002e2b0f9a23dfb3901201fb576cd">&#9670;&#160;</a></span>createShadowTextureSampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createShadowTextureSampler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates sampler for shadow mapping.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> is valid.</dd>
<dd>
Expected to be called only once so that this sampler will never be re-created.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a12e7cdf043898ecb3941625e48e43d51" name="a12e7cdf043898ecb3941625e48e43d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e7cdf043898ecb3941625e48e43d51">&#9670;&#160;</a></span>createSwapChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createSwapChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates <a class="el" href="classne_1_1VulkanRenderer.html#ac76aec9c5294592503420f83df985759">pSwapChain</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#aaf590460af70c900d8f03e7f9c039b5a">pPhysicalDevice</a> to be valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a1baf0a69e479a0c765cbd89a7434695a" name="a1baf0a69e479a0c765cbd89a7434695a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1baf0a69e479a0c765cbd89a7434695a">&#9670;&#160;</a></span>createSwapChainFramebuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createSwapChainFramebuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates swap chain framebuffers.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a6c3eecaa238f8629a3a1932861dc891a" name="a6c3eecaa238f8629a3a1932861dc891a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3eecaa238f8629a3a1932861dc891a">&#9670;&#160;</a></span>createTextureSamplers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createTextureSamplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates texture samplers that will never be recreated (destroyed during renderer's destruction).</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that <a class="el" href="classne_1_1VulkanRenderer.html#a4b72ac67263d9e718f95214a823c8865">pLogicalDevice</a> is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a9a5f2dc988ff0dbbda8aabdfe393ae5f" name="a9a5f2dc988ff0dbbda8aabdfe393ae5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5f2dc988ff0dbbda8aabdfe393ae5f">&#9670;&#160;</a></span>createVulkanInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createVulkanInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates Vulkan API instance.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a586500bcb331bb423a61ac9bddb30436" name="a586500bcb331bb423a61ac9bddb30436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586500bcb331bb423a61ac9bddb30436">&#9670;&#160;</a></span>createWindowSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::createWindowSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates Vulkan window representation object.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Should be called after <a class="el" href="classne_1_1VulkanRenderer.html#a9a5f2dc988ff0dbbda8aabdfe393ae5f">createVulkanInstance</a> but before <a class="el" href="classne_1_1VulkanRenderer.html#a2d17f56242f67d07950c3fb0169d9ffa">pickPhysicalDevice</a> as window surface is used when picking a device.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a245053a3aed78b4cc1b8e1c1c416d21c" name="a245053a3aed78b4cc1b8e1c1c416d21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245053a3aed78b4cc1b8e1c1c416d21c">&#9670;&#160;</a></span>destroySwapChainAndDependentResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::destroySwapChainAndDependentResources </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDestroyPipelineManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Destroys swap chain, framebuffers, graphics pipeline, render pass, image views, frees command buffers and other objects that depend on the swap chain images.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bDestroyPipelineManager</td><td><code>true</code> to destroy the pipeline manager, this is generally used when the renderer is being destroyed, otherwise if you just want to recreate some resources specify <code>false</code> and make sure all pipeline resources were released and will not be restored before this function is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71dec7fcf5ddc1f4bcabb94a091fa68e" name="a71dec7fcf5ddc1f4bcabb94a091fa68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71dec7fcf5ddc1f4bcabb94a091fa68e">&#9670;&#160;</a></span>dispatchComputeShadersOnGraphicsQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::VulkanRenderer::dispatchComputeShadersOnGraphicsQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structne_1_1VulkanFrameResource.html">VulkanFrameResource</a> *&#160;</td>
          <td class="paramname"><em>pCurrentFrameResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *, std::unordered_set&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>computePipelinesToSubmit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Submits compute dispatch commands using <a class="el" href="classne_1_1VulkanRenderer.html#af94ec4223715e882d2a6a10fce46875a">pGraphicsQueue</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCurrentFrameResource</td><td>Current frame resource. </td></tr>
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the current frame resource. </td></tr>
    <tr><td class="paramname">computePipelinesToSubmit</td><td>Compute shaders and their pipelines to dispatch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if dispatched some shaders, <code>false</code> if nothing to dispatch. </dd></dl>

</div>
</div>
<a id="a9adfef1f5c1a3d766b60594b1671e310" name="a9adfef1f5c1a3d766b60594b1671e310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adfef1f5c1a3d766b60594b1671e310">&#9670;&#160;</a></span>drawMeshesDepthPrepass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::drawMeshesDepthPrepass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *&#160;</td>
          <td class="paramname"><em>pCurrentFrameResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vOpaquePipelines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Submits commands to draw meshes and the specified depth only (vertex shader only) pipelines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCurrentFrameResource</td><td>Frame resource of the frame being submitted. </td></tr>
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the current frame resource. </td></tr>
    <tr><td class="paramname">vOpaquePipelines</td><td>Opaque pipelines (depth pipeline will be retrieved from them). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#ade28a2acfbf0d842310ed09e43347a6a">ne::Renderer</a>.</p>

</div>
</div>
<a id="ab379f5bf43b961a79dfe11bd1cd2b0a9" name="ab379f5bf43b961a79dfe11bd1cd2b0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab379f5bf43b961a79dfe11bd1cd2b0a9">&#9670;&#160;</a></span>drawMeshesMainPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::drawMeshesMainPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *&#160;</td>
          <td class="paramname"><em>pCurrentFrameResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vOpaquePipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vTransparentPipelines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Submits commands to draw meshes for main (color) pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCurrentFrameResource</td><td>Frame resource of the frame being submitted. </td></tr>
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the current frame resource. </td></tr>
    <tr><td class="paramname">vOpaquePipelines</td><td>Opaque pipelines to draw. </td></tr>
    <tr><td class="paramname">vTransparentPipelines</td><td>Transparent pipelines to draw. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#ae7c93c8411ed36b3a1a1d548b3119ed4">ne::Renderer</a>.</p>

</div>
</div>
<a id="afa1ccacfb1ed1749dfb2c75aecdb7a77" name="afa1ccacfb1ed1749dfb2c75aecdb7a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1ccacfb1ed1749dfb2c75aecdb7a77">&#9670;&#160;</a></span>drawMeshesMainPassSpecificPipelines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::drawMeshesMainPassSpecificPipelines </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structne_1_1Renderer_1_1MeshesInFrustum_1_1PipelineInFrustumInfo.html">Renderer::MeshesInFrustum::PipelineInFrustumInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelinesOfSpecificType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>pCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Submits commands to draw meshes and pipelines of specific types (only opaque or transparent).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelinesOfSpecificType</td><td>Pipelines to use. </td></tr>
    <tr><td class="paramname">pCommandBuffer</td><td>Command buffer to use. </td></tr>
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the current frame resource. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f11c831e45a8489c2e15ba2fbc26dc9" name="a1f11c831e45a8489c2e15ba2fbc26dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f11c831e45a8489c2e15ba2fbc26dc9">&#9670;&#160;</a></span>drawShadowMappingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::drawShadowMappingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *&#160;</td>
          <td class="paramname"><em>pCurrentFrameResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structne_1_1GraphicsPipelineRegistry.html">GraphicsPipelineRegistry</a> *&#160;</td>
          <td class="paramname"><em>pGraphicsPipelines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Submits commands to draw world from the perspective of all spawned light sources to capture shadow maps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCurrentFrameResource</td><td>Frame resource of the frame being submitted. </td></tr>
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the current frame resource. </td></tr>
    <tr><td class="paramname">pGraphicsPipelines</td><td>Graphics pipelines to draw. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a406150bfe82ba580d6ed7b2ea780c4e6">ne::Renderer</a>.</p>

</div>
</div>
<a id="a0491f1ed9a420d8758f7091398d2bc88" name="a0491f1ed9a420d8758f7091398d2bc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0491f1ed9a420d8758f7091398d2bc88">&#9670;&#160;</a></span>executeComputeShadersOnGraphicsQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::executeComputeShadersOnGraphicsQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *&#160;</td>
          <td class="paramname"><em>pCurrentFrameResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ComputeExecutionStage&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Executes compute shaders of the specified stage.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that mutex for compute shaders is locked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCurrentFrameResource</td><td>Frame resource of the frame being submitted. </td></tr>
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the current frame resource. </td></tr>
    <tr><td class="paramname">stage</td><td>Stage of compute shaders to execute. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a159404d107fc2b9c62609f7a4b29158e">ne::Renderer</a>.</p>

</div>
</div>
<a id="a4bfac946f7d02bde23fc62106eed5561" name="a4bfac946f7d02bde23fc62106eed5561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfac946f7d02bde23fc62106eed5561">&#9670;&#160;</a></span>getCommandPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandPool ne::VulkanRenderer::getCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns Vulkan command pool used in the renderer.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if command pool is not created yet, otherwise used command pool. </dd></dl>

</div>
</div>
<a id="a841bbb1e1f79595e68c8f771dc17da6f" name="a841bbb1e1f79595e68c8f771dc17da6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841bbb1e1f79595e68c8f771dc17da6f">&#9670;&#160;</a></span>getComputeTextureSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSampler ne::VulkanRenderer::getComputeTextureSampler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns Vulkan texture sampler for fetching texels in compute shaders.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Used for compute shaders that need to read textures.</dd>
<dd>
Guaranteed to never be re-created.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if not created yet, otherwise valid sampler. </dd></dl>

</div>
</div>
<a id="a603e6ac31825bf57a772c0e89a89ec8b" name="a603e6ac31825bf57a772c0e89a89ec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603e6ac31825bf57a772c0e89a89ec8b">&#9670;&#160;</a></span>getCurrentlyUsedGpuName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::VulkanRenderer::getCurrentlyUsedGpuName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the name of the GPU that is being currently used.</p>
<dl class="section return"><dt>Returns</dt><dd>Name of the GPU. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#ab89d3ddad084a96bb1f348c96e0b7263">ne::Renderer</a>.</p>

</div>
</div>
<a id="a843071a0c9dde64b9eae832fde1b8e97" name="a843071a0c9dde64b9eae832fde1b8e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843071a0c9dde64b9eae832fde1b8e97">&#9670;&#160;</a></span>getDepthImageFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr VkFormat ne::VulkanRenderer::getDepthImageFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns format used for depth image.</p>
<dl class="section return"><dt>Returns</dt><dd>Format. </dd></dl>

</div>
</div>
<a id="a20260337b2a82568f06e8f2d1bd2c4e4" name="a20260337b2a82568f06e8f2d1bd2c4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20260337b2a82568f06e8f2d1bd2c4e4">&#9670;&#160;</a></span>getDepthOnlyRenderPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkRenderPass ne::VulkanRenderer::getDepthOnlyRenderPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns depth only render pass (z-prepass).</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if render pass is not created yet, otherwise valid pointer. </dd></dl>

</div>
</div>
<a id="a26352c2baa0cdc7764911d55b15bc037" name="a26352c2baa0cdc7764911d55b15bc037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26352c2baa0cdc7764911d55b15bc037">&#9670;&#160;</a></span>getDepthTextureNoMultisampling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classne_1_1GpuResource.html">GpuResource</a> * ne::VulkanRenderer::getDepthTextureNoMultisampling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns pointer to the texture resource that represents renderer's depth texture without multisampling (resolved resource).</p>
<dl class="section warning"><dt>Warning</dt><dd>If MSAA is enabled this function will return one resource (pointer to a separate depth resolved resource), if it's disabled it will return the other resource (pointer to depth texture). So it may be a good idea to query this pointer every time you need it instead of saving it and reusing it because every frame this pointer may change (due to other reasons such as render target resize and etc).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to depth texture. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#ad507d970274a84b8fbb2a0a97b30305e">ne::Renderer</a>.</p>

</div>
</div>
<a id="abca6b972881780350eec71ce0869dc2d" name="abca6b972881780350eec71ce0869dc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca6b972881780350eec71ce0869dc2d">&#9670;&#160;</a></span>getGraphicsQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkQueue ne::VulkanRenderer::getGraphicsQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns Vulkan graphics queue used in the renderer.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if graphics queue is not created yet, otherwise used graphics queue. </dd></dl>

</div>
</div>
<a id="a070da1c1fd3bf14ab93a1ccba8908b52" name="a070da1c1fd3bf14ab93a1ccba8908b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070da1c1fd3bf14ab93a1ccba8908b52">&#9670;&#160;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkInstance ne::VulkanRenderer::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns Vulkan instance used in the renderer.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if Vulkan instance is not created yet, otherwise used Vulkan instance. </dd></dl>

</div>
</div>
<a id="a664c90ee63237b1a5177bf5cbb9e54a3" name="a664c90ee63237b1a5177bf5cbb9e54a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664c90ee63237b1a5177bf5cbb9e54a3">&#9670;&#160;</a></span>getLogicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkDevice ne::VulkanRenderer::getLogicalDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns logical device used in the renderer.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if logical device is not created yet, otherwise used logical device. </dd></dl>

</div>
</div>
<a id="a35a06a845e9c0ae7d5b9f9ccf3e03b6d" name="a35a06a845e9c0ae7d5b9f9ccf3e03b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a06a845e9c0ae7d5b9f9ccf3e03b6d">&#9670;&#160;</a></span>getMainRenderPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkRenderPass ne::VulkanRenderer::getMainRenderPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns main render pass.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if render pass is not created yet, otherwise valid pointer. </dd></dl>

</div>
</div>
<a id="aa6e40ec2a4bc21add52ec0140806e9a6" name="aa6e40ec2a4bc21add52ec0140806e9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e40ec2a4bc21add52ec0140806e9a6">&#9670;&#160;</a></span>getMaxSupportedAntialiasingQuality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::optional&lt; AntialiasingQuality &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::getMaxSupportedAntialiasingQuality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the maximum anti-aliasing quality that can be used on the picked GPU (<a class="el" href="classne_1_1VulkanRenderer.html#a603e6ac31825bf57a772c0e89a89ec8b">getCurrentlyUsedGpuName</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that the maximum supported AA quality can differ depending on the used GPU/renderer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise empty if AA is not supported. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a47325c92b874a8057d8abcfa1684a2a0">ne::Renderer</a>.</p>

</div>
</div>
<a id="a41b0c33fd86d697831304e0a0dd098c2" name="a41b0c33fd86d697831304e0a0dd098c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b0c33fd86d697831304e0a0dd098c2">&#9670;&#160;</a></span>getMsaaSampleCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSampleCountFlagBits ne::VulkanRenderer::getMsaaSampleCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns sample count of the current MSAA quality.</p>
<dl class="section return"><dt>Returns</dt><dd>MSAA sample count. </dd></dl>

</div>
</div>
<a id="aa6b515b9b5dfb8c1c7a95e98339f1c51" name="aa6b515b9b5dfb8c1c7a95e98339f1c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b515b9b5dfb8c1c7a95e98339f1c51">&#9670;&#160;</a></span>getPhysicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPhysicalDevice ne::VulkanRenderer::getPhysicalDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns physical device used in the renderer.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if physical device is not created yet, otherwise used physical device. </dd></dl>

</div>
</div>
<a id="aff7cba297c4619c36856488e11a63247" name="aff7cba297c4619c36856488e11a63247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7cba297c4619c36856488e11a63247">&#9670;&#160;</a></span>getRenderTargetSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned int, unsigned int &gt; ne::VulkanRenderer::getRenderTargetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns size of the render target (size of the underlying render image).</p>
<dl class="section return"><dt>Returns</dt><dd>Render image size in pixels (width and height). </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a29a086ceb56a27475014417e862175fe">ne::Renderer</a>.</p>

</div>
</div>
<a id="ad54eb71349aae9c81c5068f43ea488e0" name="ad54eb71349aae9c81c5068f43ea488e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54eb71349aae9c81c5068f43ea488e0">&#9670;&#160;</a></span>getRequiredVulkanInstanceExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::vector&lt; const char * &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::getRequiredVulkanInstanceExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns names of essential Vulkan instance extensions that the renderer will use.</p>
<dl class="section return"><dt>Returns</dt><dd>Names of Vulkan instance extension. </dd></dl>

</div>
</div>
<a id="a347daefa40e801343ff6e3ee02b1cc39" name="a347daefa40e801343ff6e3ee02b1cc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347daefa40e801343ff6e3ee02b1cc39">&#9670;&#160;</a></span>getShadowMapFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr VkFormat ne::VulkanRenderer::getShadowMapFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns texture format used for shadow maps.</p>
<dl class="section return"><dt>Returns</dt><dd>Shadow map format. </dd></dl>

</div>
</div>
<a id="a1fb781e6224b2efc4a54490d76c1ff10" name="a1fb781e6224b2efc4a54490d76c1ff10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb781e6224b2efc4a54490d76c1ff10">&#9670;&#160;</a></span>getShadowMappingPointLightColorTargetFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr VkFormat ne::VulkanRenderer::getShadowMappingPointLightColorTargetFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns texture format used for point lights as "color" target (does not actually store color) during shadow pass.</p>
<dl class="section return"><dt>Returns</dt><dd>Shadow map format. </dd></dl>

</div>
</div>
<a id="a208c97cb75b621724bbd22a7b49c07d4" name="a208c97cb75b621724bbd22a7b49c07d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208c97cb75b621724bbd22a7b49c07d4">&#9670;&#160;</a></span>getShadowMappingRenderPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkRenderPass ne::VulkanRenderer::getShadowMappingRenderPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsForPointLights</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns render pass used for shadow mapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIsForPointLights</td><td>Specify <code>false</code> if you need render pass for shadow mapping of directional and spot lights, otherwise specify <code>true</code> to get render pass for shadow mapping of point lights.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if render pass is not created yet, otherwise valid pointer. </dd></dl>

</div>
</div>
<a id="ae7e11b0f1ffac78a633cdcb9a3c40424" name="ae7e11b0f1ffac78a633cdcb9a3c40424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e11b0f1ffac78a633cdcb9a3c40424">&#9670;&#160;</a></span>getShadowTextureSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSampler ne::VulkanRenderer::getShadowTextureSampler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns Vulkan texture sampler for sampling shadow textures.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Guaranteed to never be re-created.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if not created yet, otherwise valid sampler. </dd></dl>

</div>
</div>
<a id="a66d3142a7256c58c9e5621ea1572df0a" name="a66d3142a7256c58c9e5621ea1572df0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d3142a7256c58c9e5621ea1572df0a">&#9670;&#160;</a></span>getSupportedGpuNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; ne::VulkanRenderer::getSupportedGpuNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Looks for video adapters (GPUs) that support this renderer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that returned array might differ depending on the used renderer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Empty array if no GPU supports used renderer, otherwise array with GPU names that can be used for this renderer. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#aa87df2fda14247192847d5056e0ecfe3">ne::Renderer</a>.</p>

</div>
</div>
<a id="a80d2498bc0ef0353911f54aa6bd6c2e6" name="a80d2498bc0ef0353911f54aa6bd6c2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d2498bc0ef0353911f54aa6bd6c2e6">&#9670;&#160;</a></span>getSupportedRefreshRates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::set&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::getSupportedRefreshRates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a list of supported screen refresh rates (pairs of numerator and denominator).</p>
<dl class="section remark"><dt>Remarks</dt><dd>The list of supported refresh rates depends on the currently used GPU, so if changing used GPU this list might return different values.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise refresh rates. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#aa2d73c28396846df0151e37f9a6a4830">ne::Renderer</a>.</p>

</div>
</div>
<a id="a6b99ca902231e396a0abef4fe3a1cdfb" name="a6b99ca902231e396a0abef4fe3a1cdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b99ca902231e396a0abef4fe3a1cdfb">&#9670;&#160;</a></span>getSupportedRenderResolutions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::set&lt; std::pair&lt; unsigned int, unsigned int &gt; &gt;, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::getSupportedRenderResolutions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a list of supported render resolution (pairs of width and height).</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise render resolutions. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#ae620044334fb679c877d70e42c72b312">ne::Renderer</a>.</p>

</div>
</div>
<a id="ac7f8f4f08713e16f16fbf4937da819a3" name="ac7f8f4f08713e16f16fbf4937da819a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f8f4f08713e16f16fbf4937da819a3">&#9670;&#160;</a></span>getSwapChainExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; VkExtent2D &gt; ne::VulkanRenderer::getSwapChainExtent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the size of images in the swap chain.</p>
<dl class="section return"><dt>Returns</dt><dd>Empty if the swap chain is not initialized, otherwise the size of images in the swap chain. </dd></dl>

</div>
</div>
<a id="a15ad698904e7c3373a657ea9261e29ac" name="a15ad698904e7c3373a657ea9261e29ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ad698904e7c3373a657ea9261e29ac">&#9670;&#160;</a></span>getTextureSampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSampler ne::VulkanRenderer::getTextureSampler </td>
          <td>(</td>
          <td class="paramtype">TextureFilteringQuality&#160;</td>
          <td class="paramname"><em>filtering</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a texture sampler the specified texture filtering option.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Returned pointer will always be valid (after the sampler was created) until the renderer is destroyed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filtering</td><td>Texture filtering mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if not created yet, otherwise valid pointer. </dd></dl>

</div>
</div>
<a id="a87693c1fba2a1765915317d9ff817f28" name="a87693c1fba2a1765915317d9ff817f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87693c1fba2a1765915317d9ff817f28">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RendererType ne::VulkanRenderer::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns renderer's type.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Renderer.html">Renderer</a>'s type. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a19bc0b11a97b3e92b8510f348d0fa28f">ne::Renderer</a>.</p>

</div>
</div>
<a id="ada9f5059b75b65b93f4f45325f7184a4" name="ada9f5059b75b65b93f4f45325f7184a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9f5059b75b65b93f4f45325f7184a4">&#9670;&#160;</a></span>getUsedApiVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::VulkanRenderer::getUsedApiVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns API version or a feature level that the renderer uses.</p>
<p >For example DirectX renderer will return used feature level and Vulkan renderer will return used Vulkan API version.</p>
<dl class="section return"><dt>Returns</dt><dd>Used API version. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a03e357989d5b7239ded555a7298e35d1">ne::Renderer</a>.</p>

</div>
</div>
<a id="acc334f432f35b32742ae93ba72e027b5" name="acc334f432f35b32742ae93ba72e027b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc334f432f35b32742ae93ba72e027b5">&#9670;&#160;</a></span>getUsedVulkanVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ne::VulkanRenderer::getUsedVulkanVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns used Vulkan API version.</p>
<dl class="section return"><dt>Returns</dt><dd>Vulkan API version that the renderer uses. </dd></dl>

</div>
</div>
<a id="a3c46c72809425573ad938dfb4e131ccc" name="a3c46c72809425573ad938dfb4e131ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c46c72809425573ad938dfb4e131ccc">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vBlacklistedGpuNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initializes the renderer.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is usually called after constructing a new empty (uninitialized) Vulkan renderer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vBlacklistedGpuNames</td><td>Names of GPUs that should not be used, generally this means that these GPUs were previously used to create the renderer but something went wrong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong (for ex. if the hardware does not support this renderer). </dd></dl>

</div>
</div>
<a id="a44bbc7d6b14f8a8b6a9ac9790ba1b8db" name="a44bbc7d6b14f8a8b6a9ac9790ba1b8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bbc7d6b14f8a8b6a9ac9790ba1b8db">&#9670;&#160;</a></span>initializeVulkan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::initializeVulkan </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vBlacklistedGpuNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initializes essential Vulkan entities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vBlacklistedGpuNames</td><td>Names of GPUs that should not be used, generally this means that these GPUs were previously used to create the renderer but something went wrong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a81ad1d11a7975507e79ce9e1e9e7b610" name="a81ad1d11a7975507e79ce9e1e9e7b610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ad1d11a7975507e79ce9e1e9e7b610">&#9670;&#160;</a></span>isDeviceSuitable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::isDeviceSuitable </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>pGpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Checks if the specified GPU fits all essential requirements of the renderer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGpu</td><td>GPU to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Empty string if the GPU is suitable, non-empty string with description on what the specified GPU does not support, error message if an internal error occurred. </dd></dl>

</div>
</div>
<a id="a022a996bf0a4ffe8ff63a43b6af9b6e6" name="a022a996bf0a4ffe8ff63a43b6af9b6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022a996bf0a4ffe8ff63a43b6af9b6e6">&#9670;&#160;</a></span>isGpuSupportsSwapChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::isGpuSupportsSwapChain </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>pGpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Checks if the specified GPU supports all used swap chain formats/modes.</p>
<dl class="section warning"><dt>Warning</dt><dd>Make sure to check that device extension <code>VK_KHR_SWAPCHAIN_EXTENSION_NAME</code> is supported before calling this function.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#adc4ef9ce95ed2cd2985a75e2a669dfda">pWindowSurface</a> to be valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGpu</td><td>GPU to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Empty string if the GPU suits swap chain requirements, non-empty string with description on what the specified GPU does not support, error message if an internal error occurred. </dd></dl>

</div>
</div>
<a id="aba975934c63978e6abe5d81a18a63a92" name="aba975934c63978e6abe5d81a18a63a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba975934c63978e6abe5d81a18a63a92">&#9670;&#160;</a></span>isGpuSupportsUsedDeviceExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; std::string, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::isGpuSupportsUsedDeviceExtensions </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>pGpuDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Checks if the specified physical device supports used device extensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGpuDevice</td><td>GPU to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Empty string if the GPU supports all used device extensions, non-empty string with device extension name that the specified GPU does not support, error message if an internal error occurred. </dd></dl>

</div>
</div>
<a id="aba9922f163c30de28d88bab2218841fd" name="aba9922f163c30de28d88bab2218841fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9922f163c30de28d88bab2218841fd">&#9670;&#160;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::VulkanRenderer::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tells whether the renderer is initialized or not.</p>
<p >Initialized renderer means that the hardware supports it and it's safe to use renderer functionality such as <a class="el" href="classne_1_1Renderer.html#ab8810b0fa64b1de6124922d4c1ee49b2">onRenderSettingsChanged</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Whether the renderer is initialized or not. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a71f920f8d11ab50acac502c896161522">ne::Renderer</a>.</p>

</div>
</div>
<a id="a535406f12090a37dbdbb0c3de64c6265" name="a535406f12090a37dbdbb0c3de64c6265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535406f12090a37dbdbb0c3de64c6265">&#9670;&#160;</a></span>isUsedDepthImageFormatSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::VulkanRenderer::isUsedDepthImageFormatSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tells if <a class="el" href="classne_1_1VulkanRenderer.html#a277331e6e8951e7db11500a9adde3639">depthImageFormat</a> is supported by the hardware.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if supported, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac51bddb238dd93b8653067c0c64fbc5a" name="ac51bddb238dd93b8653067c0c64fbc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51bddb238dd93b8653067c0c64fbc5a">&#9670;&#160;</a></span>onFramebufferSizeChangedDerived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::onFramebufferSizeChangedDerived </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iHeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called when the framebuffer size was changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iWidth</td><td>New width of the framebuffer (in pixels). </td></tr>
    <tr><td class="paramname">iHeight</td><td>New height of the framebuffer (in pixels). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classne_1_1Renderer.html#a57afd8ef14e2dfbae2391aaed4c57bb5">ne::Renderer</a>.</p>

</div>
</div>
<a id="a044c441415996a4391768b740384871b" name="a044c441415996a4391768b740384871b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044c441415996a4391768b740384871b">&#9670;&#160;</a></span>onRenderSettingsChangedDerived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::onRenderSettingsChangedDerived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called after some render setting is changed to recreate internal resources to match the current settings.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a3cc725e2a6ccfaac9ea4ef4fa2201a66">ne::Renderer</a>.</p>

</div>
</div>
<a id="a2d17f56242f67d07950c3fb0169d9ffa" name="a2d17f56242f67d07950c3fb0169d9ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d17f56242f67d07950c3fb0169d9ffa">&#9670;&#160;</a></span>pickPhysicalDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::pickPhysicalDevice </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vBlacklistedGpuNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Picks the first GPU that fits renderer's needs.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#ae7d8f3d9cbc80dfec91abfc84f8f4ef1">pInstance</a> to be valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vBlacklistedGpuNames</td><td>Names of GPUs that should not be used, generally this means that these GPUs were previously used to create the renderer but something went wrong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="ac673f06adac6b10b0d9773de553873d9" name="ac673f06adac6b10b0d9773de553873d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac673f06adac6b10b0d9773de553873d9">&#9670;&#160;</a></span>pickSwapChainExtent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; VkExtent2D, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::pickSwapChainExtent </td>
          <td>(</td>
          <td class="paramtype">const VkSurfaceCapabilitiesKHR &amp;&#160;</td>
          <td class="paramname"><em>surfaceCapabilities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Chooses the appropriate swap chain size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceCapabilities</td><td>Physical device surface's swap chain surface capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise swap chain size to use. </dd></dl>

</div>
</div>
<a id="aedbedcc94ae5a0149ef01122c578fd68" name="aedbedcc94ae5a0149ef01122c578fd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbedcc94ae5a0149ef01122c578fd68">&#9670;&#160;</a></span>prepareForDrawingNextFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::prepareForDrawingNextFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1CameraProperties.html">CameraProperties</a> *&#160;</td>
          <td class="paramname"><em>pCameraProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *&#160;</td>
          <td class="paramname"><em>pCurrentFrameResource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Setups everything for render commands to be recorded (resets command buffers and etc.).</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that render resources mutex is locked.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>When this function is called this means that the current frame resource is no longer used by the GPU.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCameraProperties</td><td>Camera properties to use. </td></tr>
    <tr><td class="paramname">pCurrentFrameResource</td><td>Frame resource of the frame being submitted. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#ad9e4ce85fd3babdb2f5ca69a1d76b54d">ne::Renderer</a>.</p>

</div>
</div>
<a id="aeda042e148260fe4693b728775a91740" name="aeda042e148260fe4693b728775a91740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda042e148260fe4693b728775a91740">&#9670;&#160;</a></span>prepareRenderTargetForNextFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::prepareRenderTargetForNextFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Called before <a class="el" href="classne_1_1VulkanRenderer.html#aedbedcc94ae5a0149ef01122c578fd68">prepareForDrawingNextFrame</a> to do early frame preparations.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It's expected that render target's size will not change after this function is finished and before a new frame is submitted. </dd></dl>

<p>Reimplemented from <a class="el" href="classne_1_1Renderer.html#a1104f4c7c926b7ac3d2cc13c0e8fa799">ne::Renderer</a>.</p>

</div>
</div>
<a id="a1a5e581efdf77fd3e927a5a58d4f89da" name="a1a5e581efdf77fd3e927a5a58d4f89da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5e581efdf77fd3e927a5a58d4f89da">&#9670;&#160;</a></span>present()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::present </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *&#160;</td>
          <td class="paramname"><em>pCurrentFrameResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iCurrentFrameResourceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Does the final frame rendering logic to present the frame on the screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCurrentFrameResource</td><td>Frame resource of the frame being submitted. </td></tr>
    <tr><td class="paramname">iCurrentFrameResourceIndex</td><td>Index of the current frame resource. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a3408af535d34d9cf26ccac19975d6403">ne::Renderer</a>.</p>

</div>
</div>
<a id="a1676cee71601db7969ab9993bfedb590" name="a1676cee71601db7969ab9993bfedb590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1676cee71601db7969ab9993bfedb590">&#9670;&#160;</a></span>queryQueueFamilyIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; <a class="el" href="structne_1_1VulkanRenderer_1_1QueueFamilyIndices.html">VulkanRenderer::QueueFamilyIndices</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::queryQueueFamilyIndices </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>pGpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Retrieves the information about used queue families and their indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGpu</td><td>GPU to query for queue families.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#adc4ef9ce95ed2cd2985a75e2a669dfda">pWindowSurface</a> to be valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise indices of used queue families returned by <code>vkGetPhysicalDeviceQueueFamilyProperties</code>. </dd></dl>

</div>
</div>
<a id="a47b70ab9bf361cd01f7ccac5545766ba" name="a47b70ab9bf361cd01f7ccac5545766ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b70ab9bf361cd01f7ccac5545766ba">&#9670;&#160;</a></span>querySwapChainSupportDetails()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; <a class="el" href="structne_1_1VulkanRenderer_1_1SwapChainSupportDetails.html">VulkanRenderer::SwapChainSupportDetails</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::querySwapChainSupportDetails </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>pGpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Queries swap chain support details from the specified GPU.</p>
<dl class="section warning"><dt>Warning</dt><dd>Make sure to check that device extension <code>VK_KHR_SWAPCHAIN_EXTENSION_NAME</code> is supported before calling this function.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Expects <a class="el" href="classne_1_1VulkanRenderer.html#adc4ef9ce95ed2cd2985a75e2a669dfda">pWindowSurface</a> to be valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGpu</td><td>GPU to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise swap chain support details. </dd></dl>

</div>
</div>
<a id="a4690a07dc723725e760768b1a454ec01" name="a4690a07dc723725e760768b1a454ec01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4690a07dc723725e760768b1a454ec01">&#9670;&#160;</a></span>rateGpuSuitability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::VulkanRenderer::rateGpuSuitability </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>pGpuDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tells how good the specified GPU suits the renderer's needs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGpuDevice</td><td>GPU to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if this GPU cannon be used (see logs for description), otherwise GPU's score (to compare with others). </dd></dl>

</div>
</div>
<a id="ab7a93662bc19a87d3df0afe21466941a" name="ab7a93662bc19a87d3df0afe21466941a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a93662bc19a87d3df0afe21466941a">&#9670;&#160;</a></span>recreateSwapChainAndDependentResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::recreateSwapChainAndDependentResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Recreates <a class="el" href="classne_1_1VulkanRenderer.html#ac76aec9c5294592503420f83df985759">pSwapChain</a> and all dependent resources after it was created using <a class="el" href="classne_1_1VulkanRenderer.html#a12e7cdf043898ecb3941625e48e43d51">createSwapChain</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a73e8afa9d6e86aeb33be8fa1c453c8e3" name="a73e8afa9d6e86aeb33be8fa1c453c8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e8afa9d6e86aeb33be8fa1c453c8e3">&#9670;&#160;</a></span>setObjectDebugOnlyName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::setObjectDebugOnlyName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1Renderer.html">Renderer</a> *&#160;</td>
          <td class="paramname"><em>pRenderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkObjectType&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sResourceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets name of the object for debugging purposes using Vulkan's debugging utils extension.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Does nothing in release builds.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRenderer</td><td>Vulkan renderer. </td></tr>
    <tr><td class="paramname">pObject</td><td>Object to name. </td></tr>
    <tr><td class="paramname">objectType</td><td>Type of the object. </td></tr>
    <tr><td class="paramname">sResourceName</td><td>Name to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f4d6c9fdc4a49289136ba7d47946b38" name="a4f4d6c9fdc4a49289136ba7d47946b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4d6c9fdc4a49289136ba7d47946b38">&#9670;&#160;</a></span>startDepthOnlyRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::startDepthOnlyRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>pCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iAcquiredImageIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds render pass start commands to the specified command buffer with <a class="el" href="classne_1_1VulkanRenderer.html#aef93999ba66bac87974a444092be9a52">pDepthOnlyRenderPass</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCommandBuffer</td><td>Command buffer to modify. </td></tr>
    <tr><td class="paramname">iAcquiredImageIndex</td><td>Index of the framebuffer to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac02641d6d9eb0a4da9d07eca2f6df847" name="ac02641d6d9eb0a4da9d07eca2f6df847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02641d6d9eb0a4da9d07eca2f6df847">&#9670;&#160;</a></span>startMainRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::startMainRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>pCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iAcquiredImageIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds render pass start commands to the specified command buffer with <a class="el" href="classne_1_1VulkanRenderer.html#aecd3c39cbed7a71daca4113101946452">pMainRenderPass</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCommandBuffer</td><td>Command buffer to modify. </td></tr>
    <tr><td class="paramname">iAcquiredImageIndex</td><td>Index of the framebuffer to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc006ddec7ab5d6a4e495efaff01058a" name="adc006ddec7ab5d6a4e495efaff01058a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc006ddec7ab5d6a4e495efaff01058a">&#9670;&#160;</a></span>startShadowMappingRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::startShadowMappingRenderPass </td>
          <td>(</td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>pShadowMappingRenderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>pCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFramebuffer&#160;</td>
          <td class="paramname"><em>pFramebufferToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iShadowMapSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds render pass start commands to the specified command buffer with the specified shadow mapping render pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pShadowMappingRenderPass</td><td><a class="el" href="classne_1_1VulkanRenderer.html#a68e87cc69b9b840872f5a3bc67a4be30">pShadowMappingDirectionalSpotRenderPass</a> or <a class="el" href="classne_1_1VulkanRenderer.html#a0c5aaea6b30613e856567eec78172039">pShadowMappingPointRenderPass</a>. </td></tr>
    <tr><td class="paramname">pCommandBuffer</td><td>Command buffer to modify. </td></tr>
    <tr><td class="paramname">pFramebufferToUse</td><td>Framebuffer to use. </td></tr>
    <tr><td class="paramname">iShadowMapSize</td><td>Size of the framebuffer image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5be101433f7df8f6fedfd7d4d3f4985e" name="a5be101433f7df8f6fedfd7d4d3f4985e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be101433f7df8f6fedfd7d4d3f4985e">&#9670;&#160;</a></span>submitWaitDestroyOneTimeSubmitCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::submitWaitDestroyOneTimeSubmitCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>pOneTimeSubmitCommandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Submits a one-time submit command buffer created by <a class="el" href="classne_1_1VulkanRenderer.html#a6ba6849ba3e37cc117afec21b339f97e">createOneTimeSubmitCommandBuffer</a>, then waits for a temporary fence to be signaled (meaning that submitted commands were executed on the GPU) and destroys the command buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pOneTimeSubmitCommandBuffer</td><td>Command buffer created by <a class="el" href="classne_1_1VulkanRenderer.html#a6ba6849ba3e37cc117afec21b339f97e">createOneTimeSubmitCommandBuffer</a> with recorded commands to submit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a363deaf734f4f58cd5106a0c8a0802ae" name="a363deaf734f4f58cd5106a0c8a0802ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363deaf734f4f58cd5106a0c8a0802ae">&#9670;&#160;</a></span>transitionImageLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::transitionImageLayout </td>
          <td>(</td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormat&#160;</td>
          <td class="paramname"><em>imageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>levelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a one-time submit command buffer to change image layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>Image to use. </td></tr>
    <tr><td class="paramname">imageFormat</td><td>Image format. </td></tr>
    <tr><td class="paramname">aspect</td><td>Aspect of the image that will be affected. </td></tr>
    <tr><td class="paramname">levelCount</td><td>Defines how much mipmaps will be affected. </td></tr>
    <tr><td class="paramname">layerCount</td><td>Defines how much image layers will be affected. </td></tr>
    <tr><td class="paramname">oldLayout</td><td>Old (current) image layout. </td></tr>
    <tr><td class="paramname">newLayout</td><td>New image layout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a8a8c74ba10f06441ddcdc4cb989e7aec" name="a8a8c74ba10f06441ddcdc4cb989e7aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8c74ba10f06441ddcdc4cb989e7aec">&#9670;&#160;</a></span>updateMsaaSampleCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::VulkanRenderer::updateMsaaSampleCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Queries the current render settings for MSAA quality and updates <a class="el" href="classne_1_1VulkanRenderer.html#a9b42f573c4591e2778172503d8cd4d0d">msaaSampleCount</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="afa790a607caa70247e134dfc452a0a49" name="afa790a607caa70247e134dfc452a0a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa790a607caa70247e134dfc452a0a49">&#9670;&#160;</a></span>waitForGpuToFinishUsingFrameResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::waitForGpuToFinishUsingFrameResource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structne_1_1FrameResource.html">FrameResource</a> *&#160;</td>
          <td class="paramname"><em>pFrameResource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Blocks the current thread until the GPU is finished using the specified frame resource.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Generally the current frame resource will be passed and so the current frame resource mutex will be locked at the time of calling and until the function is not finished it will not be unlocked.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFrameResource</td><td>Frame resource to wait for. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a64332a4c9b10010ec74584dddc91c68d">ne::Renderer</a>.</p>

</div>
</div>
<a id="a3ba1205f16b9038da69db0c001550943" name="a3ba1205f16b9038da69db0c001550943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba1205f16b9038da69db0c001550943">&#9670;&#160;</a></span>waitForGpuToFinishWorkUpToThisPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ne::VulkanRenderer::waitForGpuToFinishWorkUpToThisPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Blocks the current thread until the GPU finishes executing all queued commands up to this point.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Typically used while <a class="el" href="classne_1_1Renderer.html#a695dc78d2a55c2aa0d1c6d77265e286f">getRenderResourcesMutex</a> is locked. </dd></dl>

<p>Implements <a class="el" href="classne_1_1Renderer.html#a82398bb159588b48ad20f09b02db47a9">ne::Renderer</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4c02c3788b4cbf31e171783c416ce3b0" name="a4c02c3788b4cbf31e171783c416ce3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c02c3788b4cbf31e171783c416ce3b0">&#9670;&#160;</a></span>bIsBeingDestroyed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::VulkanRenderer::bIsBeingDestroyed = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Marked as <code>true</code> when entered destructor. </p>

</div>
</div>
<a id="a75bf971931daf9f0ca0adb71e763c4a8" name="a75bf971931daf9f0ca0adb71e763c4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bf971931daf9f0ca0adb71e763c4a8">&#9670;&#160;</a></span>bIsUsingMsaaRenderTarget</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::VulkanRenderer::bIsUsingMsaaRenderTarget = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tells if MSAA is enabled or not and whether we are using multisampled render target or not. </p>

</div>
</div>
<a id="a24ef179470bc3740973f5f94567310b9" name="a24ef179470bc3740973f5f94567310b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ef179470bc3740973f5f94567310b9">&#9670;&#160;</a></span>bIsVulkanInitialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::VulkanRenderer::bIsVulkanInitialized = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tells if <a class="el" href="classne_1_1VulkanRenderer.html#a44bbc7d6b14f8a8b6a9ac9790ba1b8db">initializeVulkan</a> was finished successfully or not. </p>

</div>
</div>
<a id="a260f960d9ffa0f044738eff73bdd4784" name="a260f960d9ffa0f044738eff73bdd4784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260f960d9ffa0f044738eff73bdd4784">&#9670;&#160;</a></span>bNeedToRecreateSwapchain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ne::VulkanRenderer::bNeedToRecreateSwapchain = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><code>true</code> if we received <code>VK_SUBOPTIMAL_KHR</code> and need to re-create the swapchain, <code>false</code> otherwise. </p>

</div>
</div>
<a id="a277331e6e8951e7db11500a9adde3639" name="a277331e6e8951e7db11500a9adde3639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277331e6e8951e7db11500a9adde3639">&#9670;&#160;</a></span>depthImageFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::depthImageFormat = VK_FORMAT_D32_SFLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Format of <a class="el" href="classne_1_1VulkanRenderer.html#a381afdbdc2e4df87806f51a443f02b62">pDepthImage</a>. </p>

</div>
</div>
<a id="a59b309f5f59fed39563d3fe2893b82d1" name="a59b309f5f59fed39563d3fe2893b82d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b309f5f59fed39563d3fe2893b82d1">&#9670;&#160;</a></span>depthImageTiling</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::depthImageTiling = VK_IMAGE_TILING_OPTIMAL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tiling option for <a class="el" href="classne_1_1VulkanRenderer.html#a381afdbdc2e4df87806f51a443f02b62">pDepthImage</a>. </p>

</div>
</div>
<a id="a5f2687dad58c52e725cda098c14582e0" name="a5f2687dad58c52e725cda098c14582e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2687dad58c52e725cda098c14582e0">&#9670;&#160;</a></span>depthResolveMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::depthResolveMode = VK_RESOLVE_MODE_MAX_BIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Used mode for resolving multisampled depth image. </p>

</div>
</div>
<a id="ad760e367dfdc6635cd2e4d8cd8c0f9ab" name="ad760e367dfdc6635cd2e4d8cd8c0f9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad760e367dfdc6635cd2e4d8cd8c0f9ab">&#9670;&#160;</a></span>iCurrentImageSemaphore</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::VulkanRenderer::iCurrentImageSemaphore = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Index into <a class="el" href="classne_1_1VulkanRenderer.html#a929cdba2f3e2706c1c3b505f7f349377">vImageSemaphores</a>. </p>

</div>
</div>
<a id="a7a02beb2a5ddf30d137775ae689b7e42" name="a7a02beb2a5ddf30d137775ae689b7e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a02beb2a5ddf30d137775ae689b7e42">&#9670;&#160;</a></span>iDepthOnlyRenderPassDepthImageAttachmentIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t ne::VulkanRenderer::iDepthOnlyRenderPassDepthImageAttachmentIndex = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Index of <a class="el" href="classne_1_1VulkanRenderer.html#a381afdbdc2e4df87806f51a443f02b62">pDepthImage</a> in <a class="el" href="classne_1_1VulkanRenderer.html#aef93999ba66bac87974a444092be9a52">pDepthOnlyRenderPass</a>. </p>

</div>
</div>
<a id="aaadb8a4947d61794e42e754432015a26" name="aaadb8a4947d61794e42e754432015a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadb8a4947d61794e42e754432015a26">&#9670;&#160;</a></span>iDepthOnlyRenderPassDepthResolveTargetAttachmentIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t ne::VulkanRenderer::iDepthOnlyRenderPassDepthResolveTargetAttachmentIndex = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Index of <a class="el" href="classne_1_1VulkanRenderer.html#a6eae1fbd4b5d52b925ddf1521d8d7d58">pDepthImageNoMultisampling</a> in <a class="el" href="classne_1_1VulkanRenderer.html#aef93999ba66bac87974a444092be9a52">pDepthOnlyRenderPass</a>. </p>

</div>
</div>
<a id="a7fcba807d95a120c70073fc34ee004ac" name="a7fcba807d95a120c70073fc34ee004ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcba807d95a120c70073fc34ee004ac">&#9670;&#160;</a></span>iLastAcquiredImageIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ne::VulkanRenderer::iLastAcquiredImageIndex = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Index of the last acquired image from the swap chain. </p>

</div>
</div>
<a id="a1de07c4ad8280ce9dad181aa053bbc64" name="a1de07c4ad8280ce9dad181aa053bbc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de07c4ad8280ce9dad181aa053bbc64">&#9670;&#160;</a></span>iMainRenderPassColorAttachmentIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t ne::VulkanRenderer::iMainRenderPassColorAttachmentIndex = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Index of the color attachment in <a class="el" href="classne_1_1VulkanRenderer.html#aecd3c39cbed7a71daca4113101946452">pMainRenderPass</a>. </p>

</div>
</div>
<a id="adf90eae1124256195e3940020aba0072" name="adf90eae1124256195e3940020aba0072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf90eae1124256195e3940020aba0072">&#9670;&#160;</a></span>iMainRenderPassColorResolveTargetAttachmentIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t ne::VulkanRenderer::iMainRenderPassColorResolveTargetAttachmentIndex = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Index of the color resolve target attachment in <a class="el" href="classne_1_1VulkanRenderer.html#aecd3c39cbed7a71daca4113101946452">pMainRenderPass</a>. </p>

</div>
</div>
<a id="a92ba65d4956388418e59bc6deb8b613e" name="a92ba65d4956388418e59bc6deb8b613e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ba65d4956388418e59bc6deb8b613e">&#9670;&#160;</a></span>iMainRenderPassDepthAttachmentIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t ne::VulkanRenderer::iMainRenderPassDepthAttachmentIndex = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Index of the depth attachment in <a class="el" href="classne_1_1VulkanRenderer.html#aecd3c39cbed7a71daca4113101946452">pMainRenderPass</a>. </p>

</div>
</div>
<a id="a97bd70cca7ae7440e0cbe802ca81447f" name="a97bd70cca7ae7440e0cbe802ca81447f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bd70cca7ae7440e0cbe802ca81447f">&#9670;&#160;</a></span>indexTypeFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::indexTypeFormat = VK_INDEX_TYPE_UINT32</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Format of indices. </p>

</div>
</div>
<a id="a35cf860ba0c5cfee1a3b004e3059ebfb" name="a35cf860ba0c5cfee1a3b004e3059ebfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cf860ba0c5cfee1a3b004e3059ebfb">&#9670;&#160;</a></span>iSwapChainImageCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ne::VulkanRenderer::iSwapChainImageCount = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The number of swap chain images that we have in <a class="el" href="classne_1_1VulkanRenderer.html#ac76aec9c5294592503420f83df985759">pSwapChain</a>. </p>

</div>
</div>
<a id="af53d53fb3c12c28b016fda142cdd18f2" name="af53d53fb3c12c28b016fda142cdd18f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53d53fb3c12c28b016fda142cdd18f2">&#9670;&#160;</a></span>iUsedVulkanVersion</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t ne::VulkanRenderer::iUsedVulkanVersion = VK_API_VERSION_1_2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Version of the Vulkan API that the renderer uses. </p>

</div>
</div>
<a id="a9b42f573c4591e2778172503d8cd4d0d" name="a9b42f573c4591e2778172503d8cd4d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b42f573c4591e2778172503d8cd4d0d">&#9670;&#160;</a></span>msaaSampleCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkSampleCountFlagBits ne::VulkanRenderer::msaaSampleCount = VK_SAMPLE_COUNT_1_BIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Used MSAA sample count. </p>

</div>
</div>
<a id="a26466d01d327fa6c08f70952c1c4fcd1" name="a26466d01d327fa6c08f70952c1c4fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26466d01d327fa6c08f70952c1c4fcd1">&#9670;&#160;</a></span>pCommandPool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandPool ne::VulkanRenderer::pCommandPool = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Used to create command buffers. </p>

</div>
</div>
<a id="a5bcf2cea84ab332c38127a6730281b82" name="a5bcf2cea84ab332c38127a6730281b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcf2cea84ab332c38127a6730281b82">&#9670;&#160;</a></span>pComputeTextureSampler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkSampler ne::VulkanRenderer::pComputeTextureSampler = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Texture sampler with nearest filtering and mipmapping for fetching texels in compute shader.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Always valid and not re-created when texture filtering (render setting) is changed. </dd></dl>

</div>
</div>
<a id="a381afdbdc2e4df87806f51a443f02b62" name="a381afdbdc2e4df87806f51a443f02b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381afdbdc2e4df87806f51a443f02b62">&#9670;&#160;</a></span>pDepthImage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classne_1_1VulkanResource.html">VulkanResource</a>&gt; ne::VulkanRenderer::pDepthImage = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Depth buffer. </p>

</div>
</div>
<a id="a6eae1fbd4b5d52b925ddf1521d8d7d58" name="a6eae1fbd4b5d52b925ddf1521d8d7d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eae1fbd4b5d52b925ddf1521d8d7d58">&#9670;&#160;</a></span>pDepthImageNoMultisampling</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classne_1_1VulkanResource.html">VulkanResource</a>&gt; ne::VulkanRenderer::pDepthImageNoMultisampling = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Depth buffer without multisampling (for light culling compute shader).</p>
<dl class="section warning"><dt>Warning</dt><dd>When <a class="el" href="classne_1_1VulkanRenderer.html#a381afdbdc2e4df87806f51a443f02b62">pDepthImage</a> does not use multisampling this buffer is not used and does not store contents of <a class="el" href="classne_1_1VulkanRenderer.html#a381afdbdc2e4df87806f51a443f02b62">pDepthImage</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Stores non-multisampled depth data from <a class="el" href="classne_1_1VulkanRenderer.html#a381afdbdc2e4df87806f51a443f02b62">pDepthImage</a> for shaders. </dd></dl>

</div>
</div>
<a id="aef93999ba66bac87974a444092be9a52" name="aef93999ba66bac87974a444092be9a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef93999ba66bac87974a444092be9a52">&#9670;&#160;</a></span>pDepthOnlyRenderPass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkRenderPass ne::VulkanRenderer::pDepthOnlyRenderPass = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Render pass for z-prepass. </p>

</div>
</div>
<a id="af94ec4223715e882d2a6a10fce46875a" name="af94ec4223715e882d2a6a10fce46875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94ec4223715e882d2a6a10fce46875a">&#9670;&#160;</a></span>pGraphicsQueue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkQueue ne::VulkanRenderer::pGraphicsQueue = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Graphics queue. </p>

</div>
</div>
<a id="a8632129baa17acf6324c4ff9cf4fb6f8" name="a8632129baa17acf6324c4ff9cf4fb6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8632129baa17acf6324c4ff9cf4fb6f8">&#9670;&#160;</a></span>physicalDeviceQueueFamilyIndices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structne_1_1VulkanRenderer_1_1QueueFamilyIndices.html">QueueFamilyIndices</a> ne::VulkanRenderer::physicalDeviceQueueFamilyIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Queue family indices of current <a class="el" href="classne_1_1VulkanRenderer.html#aaf590460af70c900d8f03e7f9c039b5a">pPhysicalDevice</a>. </p>

</div>
</div>
<a id="ae7d8f3d9cbc80dfec91abfc84f8f4ef1" name="ae7d8f3d9cbc80dfec91abfc84f8f4ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d8f3d9cbc80dfec91abfc84f8f4ef1">&#9670;&#160;</a></span>pInstance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkInstance ne::VulkanRenderer::pInstance = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Vulkan API instance. </p>

</div>
</div>
<a id="a4b72ac67263d9e718f95214a823c8865" name="a4b72ac67263d9e718f95214a823c8865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b72ac67263d9e718f95214a823c8865">&#9670;&#160;</a></span>pLogicalDevice</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkDevice ne::VulkanRenderer::pLogicalDevice = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Logical device to interface with <a class="el" href="classne_1_1VulkanRenderer.html#aaf590460af70c900d8f03e7f9c039b5a">pPhysicalDevice</a>. </p>

</div>
</div>
<a id="aecd3c39cbed7a71daca4113101946452" name="aecd3c39cbed7a71daca4113101946452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd3c39cbed7a71daca4113101946452">&#9670;&#160;</a></span>pMainRenderPass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkRenderPass ne::VulkanRenderer::pMainRenderPass = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Render pass for main pass. </p>

</div>
</div>
<a id="a57a6cc1e77934c7974abcf2fafa4e13e" name="a57a6cc1e77934c7974abcf2fafa4e13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a6cc1e77934c7974abcf2fafa4e13e">&#9670;&#160;</a></span>pMsaaImage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classne_1_1VulkanResource.html">VulkanResource</a>&gt; ne::VulkanRenderer::pMsaaImage = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Image with multiple samples per pixel for MSAA. </p>

</div>
</div>
<a id="aaf590460af70c900d8f03e7f9c039b5a" name="aaf590460af70c900d8f03e7f9c039b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf590460af70c900d8f03e7f9c039b5a">&#9670;&#160;</a></span>pPhysicalDevice</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkPhysicalDevice ne::VulkanRenderer::pPhysicalDevice = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >GPU that is being used by this renderer. </p>

</div>
</div>
<a id="a57df121e6648a8ecf76af55bc3e7436d" name="a57df121e6648a8ecf76af55bc3e7436d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57df121e6648a8ecf76af55bc3e7436d">&#9670;&#160;</a></span>pPresentQueue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkQueue ne::VulkanRenderer::pPresentQueue = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Presentation queue. </p>

</div>
</div>
<a id="a68e87cc69b9b840872f5a3bc67a4be30" name="a68e87cc69b9b840872f5a3bc67a4be30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e87cc69b9b840872f5a3bc67a4be30">&#9670;&#160;</a></span>pShadowMappingDirectionalSpotRenderPass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkRenderPass ne::VulkanRenderer::pShadowMappingDirectionalSpotRenderPass = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Render pass for shadow mapping of directional and spot lights. </p>

</div>
</div>
<a id="a0c5aaea6b30613e856567eec78172039" name="a0c5aaea6b30613e856567eec78172039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5aaea6b30613e856567eec78172039">&#9670;&#160;</a></span>pShadowMappingPointRenderPass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkRenderPass ne::VulkanRenderer::pShadowMappingPointRenderPass = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Render pass for shadow mapping of point lights. </p>

</div>
</div>
<a id="affc1856c23bbdf9a97819a2cc9fcd6d7" name="affc1856c23bbdf9a97819a2cc9fcd6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc1856c23bbdf9a97819a2cc9fcd6d7">&#9670;&#160;</a></span>pShadowTextureSampler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkSampler ne::VulkanRenderer::pShadowTextureSampler = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Texture sampler for directional and spot shadow maps.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Always valid and not re-created when texture filtering (render setting) is changed. </dd></dl>

</div>
</div>
<a id="ac76aec9c5294592503420f83df985759" name="ac76aec9c5294592503420f83df985759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76aec9c5294592503420f83df985759">&#9670;&#160;</a></span>pSwapChain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkSwapchainKHR ne::VulkanRenderer::pSwapChain = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Swap chain. </p>

</div>
</div>
<a id="aa7c6940e0c054cf4e3863c046b31816c" name="aa7c6940e0c054cf4e3863c046b31816c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c6940e0c054cf4e3863c046b31816c">&#9670;&#160;</a></span>pTextureSamplerAnisotropicFiltering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkSampler ne::VulkanRenderer::pTextureSamplerAnisotropicFiltering = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Texture sampler with anisotropic filtering.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Will never be recreated (destroyed during renderer's destruction). </dd></dl>

</div>
</div>
<a id="aacd88a0050737024ca1c3b09993fb6fb" name="aacd88a0050737024ca1c3b09993fb6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd88a0050737024ca1c3b09993fb6fb">&#9670;&#160;</a></span>pTextureSamplerLinearFiltering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkSampler ne::VulkanRenderer::pTextureSamplerLinearFiltering = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Texture sampler with linear filtering.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Will never be recreated (destroyed during renderer's destruction). </dd></dl>

</div>
</div>
<a id="a2226a46942e005cdc11124e4dd7b3638" name="a2226a46942e005cdc11124e4dd7b3638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2226a46942e005cdc11124e4dd7b3638">&#9670;&#160;</a></span>pTextureSamplerPointFiltering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkSampler ne::VulkanRenderer::pTextureSamplerPointFiltering = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Texture sampler with point filtering.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Will never be recreated (destroyed during renderer's destruction). </dd></dl>

</div>
</div>
<a id="adc4ef9ce95ed2cd2985a75e2a669dfda" name="adc4ef9ce95ed2cd2985a75e2a669dfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4ef9ce95ed2cd2985a75e2a669dfda">&#9670;&#160;</a></span>pWindowSurface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkSurfaceKHR ne::VulkanRenderer::pWindowSurface = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Vulkan window representation. </p>

</div>
</div>
<a id="ae373f4efe6fdfd5e0b6bb7c11744b2ab" name="ae373f4efe6fdfd5e0b6bb7c11744b2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae373f4efe6fdfd5e0b6bb7c11744b2ab">&#9670;&#160;</a></span>shadowMapFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::shadowMapFormat = VK_FORMAT_D32_SFLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Format used for shadow maps. </p>

</div>
</div>
<a id="a8c6e8c90a17cdd220d2e283f6d477b07" name="a8c6e8c90a17cdd220d2e283f6d477b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6e8c90a17cdd220d2e283f6d477b07">&#9670;&#160;</a></span>shadowMappingPointLightColorTargetFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::shadowMappingPointLightColorTargetFormat = VK_FORMAT_R32_SFLOAT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Format used for point lights as "color" target (does not actually store color) during shadow pass. </p>

</div>
</div>
<a id="abe61b6d29c18f3fe82834ab9cadab702" name="abe61b6d29c18f3fe82834ab9cadab702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe61b6d29c18f3fe82834ab9cadab702">&#9670;&#160;</a></span>stencilResolveMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::stencilResolveMode = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Used mode for resolving multisampled depth image. </p>

</div>
</div>
<a id="ac4db7fe74b51ff3cc4f9f6aadff8dc6c" name="ac4db7fe74b51ff3cc4f9f6aadff8dc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4db7fe74b51ff3cc4f9f6aadff8dc6c">&#9670;&#160;</a></span>sUsedGpuName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ne::VulkanRenderer::sUsedGpuName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Name of the <a class="el" href="classne_1_1VulkanRenderer.html#aaf590460af70c900d8f03e7f9c039b5a">pPhysicalDevice</a>. </p>

</div>
</div>
<a id="a2c46a9d3b0553c0a990bda93c7cbe6c9" name="a2c46a9d3b0553c0a990bda93c7cbe6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c46a9d3b0553c0a990bda93c7cbe6c9">&#9670;&#160;</a></span>swapChainExtent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;VkExtent2D&gt; ne::VulkanRenderer::swapChainExtent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Size of images in the swap chain. </p>

</div>
</div>
<a id="a48bc1b785d9580a11a7607f5bc27654c" name="a48bc1b785d9580a11a7607f5bc27654c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bc1b785d9580a11a7607f5bc27654c">&#9670;&#160;</a></span>swapChainImageColorSpace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::swapChainImageColorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Color space of <a class="el" href="classne_1_1VulkanRenderer.html#ad4c109ccbb605587115f78f679b9cd99">vSwapChainImages</a>. </p>

</div>
</div>
<a id="ae8b79b60342a809010a052fa71970066" name="ae8b79b60342a809010a052fa71970066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b79b60342a809010a052fa71970066">&#9670;&#160;</a></span>swapChainImageFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto ne::VulkanRenderer::swapChainImageFormat = VK_FORMAT_B8G8R8A8_UNORM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Format of <a class="el" href="classne_1_1VulkanRenderer.html#ad4c109ccbb605587115f78f679b9cd99">vSwapChainImages</a>. </p>

</div>
</div>
<a id="a929cdba2f3e2706c1c3b505f7f349377" name="a929cdba2f3e2706c1c3b505f7f349377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929cdba2f3e2706c1c3b505f7f349377">&#9670;&#160;</a></span>vImageSemaphores</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structne_1_1VulkanRenderer_1_1SwapChainImageSemaphores.html">SwapChainImageSemaphores</a>&gt; ne::VulkanRenderer::vImageSemaphores</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Semaphores related to swap chain images.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Size of this array is equal to <a class="el" href="classne_1_1VulkanRenderer.html#a35cf860ba0c5cfee1a3b004e3059ebfb">iSwapChainImageCount</a>. </dd></dl>

</div>
</div>
<a id="a5f265697a9a8b83fbfe4753510b24763" name="a5f265697a9a8b83fbfe4753510b24763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f265697a9a8b83fbfe4753510b24763">&#9670;&#160;</a></span>vSupportedGpuNames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; ne::VulkanRenderer::vSupportedGpuNames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >List of supported GPUs, filled during <a class="el" href="classne_1_1VulkanRenderer.html#a2d17f56242f67d07950c3fb0169d9ffa">pickPhysicalDevice</a>. </p>

</div>
</div>
<a id="ab4083804472a4c73560767f159f8486c" name="ab4083804472a4c73560767f159f8486c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4083804472a4c73560767f159f8486c">&#9670;&#160;</a></span>vSwapChainFramebuffersDepthOnlyRenderPass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;VkFramebuffer&gt; ne::VulkanRenderer::vSwapChainFramebuffersDepthOnlyRenderPass</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Framebuffers that point to <a class="el" href="classne_1_1VulkanRenderer.html#a00ab177c322afec734df3855099a18ce">vSwapChainImageViews</a> and reference depth only render pass.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Size of this array is equal to <a class="el" href="classne_1_1VulkanRenderer.html#a35cf860ba0c5cfee1a3b004e3059ebfb">iSwapChainImageCount</a>. </dd></dl>

</div>
</div>
<a id="af71551705046c22f849d76ad47cdd732" name="af71551705046c22f849d76ad47cdd732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71551705046c22f849d76ad47cdd732">&#9670;&#160;</a></span>vSwapChainFramebuffersMainRenderPass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;VkFramebuffer&gt; ne::VulkanRenderer::vSwapChainFramebuffersMainRenderPass</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Framebuffers that point to <a class="el" href="classne_1_1VulkanRenderer.html#a00ab177c322afec734df3855099a18ce">vSwapChainImageViews</a> and reference main render pass.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Size of this array is equal to <a class="el" href="classne_1_1VulkanRenderer.html#a35cf860ba0c5cfee1a3b004e3059ebfb">iSwapChainImageCount</a>. </dd></dl>

</div>
</div>
<a id="af43ae0ffb38e78bf0ba8f08b3f45cd44" name="af43ae0ffb38e78bf0ba8f08b3f45cd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43ae0ffb38e78bf0ba8f08b3f45cd44">&#9670;&#160;</a></span>vSwapChainImageFenceRefs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;VkFence, size_t&gt; &gt; ne::VulkanRenderer::vSwapChainImageFenceRefs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores pairs of "references to fences of a frame resources" - "frame resource index".</p>
<dl class="section remark"><dt>Remarks</dt><dd>Used to synchronize <code>vkAcquireNextImageKHR</code> calls and wait for a frame resource that uses the swap chain image.</dd>
<dd>
Size of this array is equal to <a class="el" href="classne_1_1VulkanRenderer.html#a35cf860ba0c5cfee1a3b004e3059ebfb">iSwapChainImageCount</a>. </dd></dl>

</div>
</div>
<a id="ad4c109ccbb605587115f78f679b9cd99" name="ad4c109ccbb605587115f78f679b9cd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c109ccbb605587115f78f679b9cd99">&#9670;&#160;</a></span>vSwapChainImages</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;VkImage&gt; ne::VulkanRenderer::vSwapChainImages</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Swap chain images.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Size of this array is equal to <a class="el" href="classne_1_1VulkanRenderer.html#a35cf860ba0c5cfee1a3b004e3059ebfb">iSwapChainImageCount</a>. </dd></dl>

</div>
</div>
<a id="a00ab177c322afec734df3855099a18ce" name="a00ab177c322afec734df3855099a18ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ab177c322afec734df3855099a18ce">&#9670;&#160;</a></span>vSwapChainImageViews</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;VkImageView&gt; ne::VulkanRenderer::vSwapChainImageViews</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Views to <a class="el" href="classne_1_1VulkanRenderer.html#ad4c109ccbb605587115f78f679b9cd99">vSwapChainImages</a>.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Size of this array is equal to <a class="el" href="classne_1_1VulkanRenderer.html#a35cf860ba0c5cfee1a3b004e3059ebfb">iSwapChainImageCount</a>. </dd></dl>

</div>
</div>
<a id="a7f63236458627346b36fd4f34ec22850" name="a7f63236458627346b36fd4f34ec22850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f63236458627346b36fd4f34ec22850">&#9670;&#160;</a></span>vUsedDeviceExtensionNames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;const char*&gt; ne::VulkanRenderer::vUsedDeviceExtensionNames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">            VK_KHR_SWAPCHAIN_EXTENSION_NAME}</div>
</div><!-- fragment --><p >Array of physical device extensions that we use. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/engine_lib/private/render/vulkan/<a class="el" href="VulkanRenderer_8h_source.html">VulkanRenderer.h</a></li>
<li>src/engine_lib/private/render/vulkan/VulkanRenderer.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1VulkanRenderer.html">VulkanRenderer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
