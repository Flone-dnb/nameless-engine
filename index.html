<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_docs_Manual"></a> This is a manual - a step-by-step guide to introduce you to various aspects of the engine. More specific documentation can be always found in the class/function/variable documentation in the source code or on this page (see left panel for navigation), every code entity is documented so you should not get lost.</p>
<p >Note that this manual contains many sections and instead of scrolling this page you can click on a little arrow button in the left (navigation) panel, the little arrow button becomes visible once you hover your mouse cursor over a section name, by clicking on that litte arrow you can expand the section and see its subsections and quickly jump to needed sections.</p>
<p >This manual expects that you have a solid knowledge in writing programs using C++ language.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Introduction to the engine</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Prerequisites</h2>
<p >First of all, read the repository's <code>README.md</code> file, specifically the <code>Prerequisites</code> section, make sure you have all required things installed.</p>
<p >The engine relies on CMake as its build system. CMake is a very common build system for C++ projects so generally most of the developers should be familiar with it. If you don't know what CMake is or haven't used it before it's about the time to learn the basics of CMake right now. Your project will be represented as several CMake targets: one target for standalone game, one target for tests, one target for editor and etc. So you will work on <code>CMakeLists.txt</code> files as with usual C++! There are of course some litte differences compared to the usual CMake usage, for example if you want to define external dependencing in your CMake file you need to do one additional step (compared to the usual CMake usage) that will be covered later in a separate section.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Creating a new project</h2>
<h3><a class="anchor" id="autotoc_md4"></a>
Preparing project path (only for Windows users)</h3>
<p >Because Windows limits paths to ~255 characters it's impossible to operate on files that have long paths, thus, you need to make sure that path to your project directory will not be very long, this does not mean that you need to create your project in disk root (for ex. C:\myproject) - there's no need for that but the shorter the path to the project the most likely you won't have weird issues with your project. If you need exact numbers a path with 30-40 characters will be good but you can try using longer paths. Just don't forget about this path limitation thing.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Project generator</h3>
<p >Currently we don't have a proper project generator but it's planned. Once the project generator will be implemented this section will be updated.</p>
<p >Right now you can clone the repository and don't forget to update submodules. Once you have a project with <code>CMakeLists.txt</code> file in the root directory you can open it in your IDE. For example Qt Creator or Visual Studio allow opening <code>CMakeLists.txt</code> files as C++ projects, other IDEs also might have this functionality.</p>
<p >Note for Visual Studio users: </p><blockquote class="doxtable">
<p >&zwj;If you use Visual Studio the proper way to work on <code>CMakeLists.txt</code> files as C++ projects is to open up Visual Studio without any code then press <code>File</code> -&gt; <code>Open</code> -&gt; <code>Cmake</code> and select the <code>CMakeLists.txt</code> file in the root directory (may be changed in the new VS versions). Then a tab called <code>CMake Overview Pages</code> should be opened in which you might want to click <code>Open CMake Settings Editor</code> and inside of that change <code>Build root</code> to just <code>${projectDir}\build\</code> to store built data inside of the <code>build</code> directory (because by default Visual Studio stores build in an unusual path <code>out/&lt;build mode&gt;/</code>). When you open <code>CMakeLists.txt</code> in Visual Studio near the green button to run your project you might see a text <code>Select Startup Item...</code>, you should press a litte arrow near this text to expand a list of available targets to use. Then select a target that you want to build/use and that's it, you are ready to work on the project. </p>
</blockquote>
<p>Note for Windows users: </p><blockquote class="doxtable">
<p >&zwj;Windows 10 users need to run their IDE with admin privileges when building the project for the first time (only for the first build) when executing a post-build script the engine creates a symlink next to the built executable that points to the directory with engine/editor/game resources (called <code>res</code>). Creating symlinks on Windows requires admin privileges. When releasing your project we expect you to put an actual copy of your <code>res</code> directory next to the built executable but we will discuss this topic later in a separate section. </p>
</blockquote>
<p>Before you go ahead and dive into the engine yourself make sure to read a few more sections, there is one really important section further in the manual that you have to read, it contains general tips about things you need to keep an eye out!</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Project structure</h3>
<p >Let's looks at the directories/files that a typical project will have:</p><ul>
<li><code>build</code> this directory generally used in CMake projects to store built binaries.</li>
<li><code>docs</code> this directory stores documentation, generally it contains a <code>Doxyfile</code> config that <code>doxygen</code> (generates documentation pages from source code comments) uses and maybe a hand-written documentation page (a manual, like the one your are reading right now).</li>
<li><code>ext</code> this directory is used to store external dependencies, generally it stores git submodules but sometimes it also stores non-submodule directories.</li>
<li><code>res</code> this directory stores all resources (shaders, images, 3D objects, sound, etc.), if you look in this directory you might see subdirectories like <code>editor</code>, <code>engine</code>, <code>game</code> and <code>test</code>, each one stores resources for one specific thing, <code>editor</code> stores editor resources, <code>game</code> stores resources that your game needs, <code>test</code> stores resources used in automated testing and etc.</li>
<li><code>src</code> this directory stores all source code: source code for the editor, engine, your game, etc.</li>
<li><code>.clang-format</code> this file is used by <code>clang-format</code> a code formatter that automatically formats our source code according to the config file, we will talk about code formatting in one of the next sections.</li>
<li><code>.clang-tidy</code> this file is used by <code>clang-tidy</code> a static analyzer that checks our code for common mistakes/bugs and also controls some code style, we will talk about static analyzers in one of the next sections.</li>
<li><code>CMakeLists.txt</code> is a top-level CMake file that we open in our IDEs, it adds other CMake files from the <code>src</code> directory.</li>
</ul>
<p >The <code>src</code> directory contains a directory per CMake target, for example: <code>editor</code> (executable CMake target), <code>editor_lib</code> (library CMake target) and some additional helper directories such as <code>.cmake</code> (contains helper CMake functions) and <code>.scripts</code> (contains Go scripts that we use in our CMake files).</p>
<p >Inside of each CMake target directory will be a target-specific <code>CMakeLists.txt</code> file (for example: <code>src/editor_lib/CMakeLists.txt</code>), directories for source code and maybe a <code>.generated</code> directory that contains reflection code (we will talk about source code directories and reflection in one of the next sections).</p>
<p >Note that generally you should add all functionality of your game into a library target (so that it can be used in other executable targets such as <code>tests</code>) while executable targets will generally will only have <code>main.cpp</code>.</p>
<p >Your game target <code>CMakeLists.txt</code> is fully yours, it will have some configuration code inside of it but you are free to change it as you want (you can disable/change <code>doxygen</code>, <code>clang-tidy</code>, reflection generation and anything else you don't like).</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Which header files to include and which not to include</h2>
<h3><a class="anchor" id="autotoc_md8"></a>
General</h3>
<p ><code>src/engine_lib</code> is divided into 2 directories: public and private. You are free to include anything from the <code>public</code> directory, you can also include header files from the <code>private</code> directory in some special/advanced cases but generally there should be no need for that. Note that this division (public/private) is only conceptual, your project already includes both directories because some engine <code>public</code> headers use <code>private</code> headers and thus both included in cmake targets that use the engine (in some cases it may cause your IDE to suggest lots of headers when attempting to include some header from some directory so it may be helpful to just look at the specific public directory to look for the header name if you feel overwhelmed).</p>
<p >Inside of the <code>public</code> directory you will see other directories that group header files by their purpose, for example <code>io</code> directory stands for <code>in/out</code> which means that this directory contains files for working with disk (loading/saving configuration files, logging information to log files that are stored on disk, etc.).</p>
<p >You might also notice that some header files have <code>.h</code> extension and some have <code>.hpp</code> extension. The difference here is only conceptual: files with <code>.hpp</code> extension don't have according <code>.cpp</code> file, this is just a small hint for developers.</p>
<p >You are not required to use the <code>private</code>/<code>public</code> directory convention, moreover directories that store executable cmake targets just use <code>src</code> directory (you can look into <code>engine_tests</code> or <code>editor</code> directories to see an example) so you can group your source files as you want.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Math headers</h3>
<p >The engine uses GLM (a well known math library, hosted at <a href="https://github.com/g-truc/glm">https://github.com/g-truc/glm</a>). Although you can include original GLM headers it's highly recommended to include the header <code><a class="el" href="GLMath_8hpp_source.html">math/GLMath.hpp</a></code> instead of the original GLM headers when math is needed. This header includes main GLM headers and defines engine specific macros so that GLM will behave as the engine expects.</p>
<p >You should always prefer to include <code><a class="el" href="GLMath_8hpp_source.html">math/GLMath.hpp</a></code> instead of the original GLM headers and only if this header does not have needed functionality you can include original GLM headers afterwards.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Automatic code formatters and static analyzers</h2>
<p >The engine uses <code>clang-format</code> and <code>clang-tidy</code> a classic pair of tools that you will commonly find in C++ projects. If you don't know what they do it's a good time to read about them on the Internet.</p>
<p >The engine does not require you to use them but their usage is highly recommended.</p>
<p ><code>clang-format</code> can be used in your IDE to automatically format your code (for example) each time you press Ctrl+S. If you want to make sure that your IDE is using our <code>.clang-format</code> config you can do the following check: in your source code create 2 or more consecutive empty lines, since our <code>.clang-format</code> config contains a rule <code>MaxEmptyLinesToKeep: 1</code> after you format the file only 1 empty line should remain. The action with which you format your source code depends on your IDE settings that you might want to configure, generally IDEs have a shortcut to "format" your source code but some have option to automatically use "format" action when you are saving your file.</p>
<p ><code>clang-tidy</code> has a lot of checks enabled and is generally not that fast as you might expect, because of this we have <code>clang-tidy</code> enabled only in release builds to speed up build times for debug builds. This means that if your game builds in debug mode it may very well fail to build in release mode due to some <code>clang-tidy</code> warnings that are treated as errors. Because of this it's highly recommended to regularly (say once or twice a week) build your project in release mode to check for <code>clang-tidy</code> warnings/errors.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Node system</h2>
<p >Have you used Godot game engine? If the answer is "yes" you're in luck, this engine uses a similar node system for game entities. We have a base class <code>Node</code> and derived nodes like <code>SpatialNode</code>, <code>MeshNode</code> and etc.</p>
<p >If you don't know what node system is or haven't used Godot, here is a small introduction to the node system: </p><blockquote class="doxtable">
<p >&zwj;Generally game engines have some sort of ECS (Entity component system) in use. There are various forms of ECS like data-driven, object-oriented and etc. Entities can be represented in different ways in different engines: an entity might be a complex class like Unreal Engine's <code>Actor</code> that contains both data and logic or an entity might be just a number (a unique identifier). Components can also be represented in different ways: a component might be a special class that implements some specific logic like Unreal Engine's <code>CharacterMovementComponent</code> that implements functionality for your entity to be able to move, swim, fly and etc. so it contains both data and logic or a component may just group some data and have no logic at all. Node system is an ECS-like system that is slightly similar to how Unreal Engine's entity-component framework works. If you worked with Unreal Engine imagine that there are no actors but only components and world consists of only components - that's roughly how node system works. In node system each entity in the game is a node. A node contains both logic and data. The base class <code>Node</code> implements some general node functionality such as: being able to attach child nodes or attach to some parent node, determining if the node should receive user input or if it should be called every frame to do some per-frame logic and etc. We have various types of nodes like <code>SpatialNode</code> that has a location/rotation/scale in 3D space or <code>MeshNode</code> that derives from <code>SpatialNode</code> but adds functionality to display a 3D geometry. Nodes attach other nodes as child nodes thus creating a node hierarchy or a node tree. A node tree is a game level or a game map. Your game's character is also a node tree because it will most likely be built of a mesh node, a camera node, a collision node, maybe your custom derived node that handles some character specific logic and maybe something else. Your game's UI is also a node tree because it will most likely have a container node, various button nodes and text nodes. When you combine everything together you attach your character's node tree and your UI node tree to your game map's node tree thus creating a game level. That's how node system works. </p>
</blockquote>
<p>Nodes are generally used to take place in the node hierarchy, to be part of some parent node for example. Nodes are special and they use special garbage collected smart pointers (we will talk about them in one of the next sections) but not everything should be a node. If you want to implement some class that does not need to take a place in the node hierarchy, does not belong to some node or does not interact with nodes, for example a class to send bug reports, there's really no point in deriving you bug reporter class from <code>Node</code>, although nobody is stopping you from using nodes for everything and it's perfectly fine to do so, right now we want to smoothly transition to other important thing in your game. Your class/object might exist apart from node system and you can use it outside of the node system. For example, you can store your class/object in a <code>GameInstance</code>.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Game instance</h2>
<blockquote class="doxtable">
<p >&zwj;If you used Unreal Engine the <code>GameInstance</code> class works similarly (but not exactly) to how Unreal Engine's <code>UGameInstance</code> class works. </p>
</blockquote>
<p>In order to start your game you create a <code>Window</code>, a window creates <code>GameManager</code> - the heart of your game, the most important manager of your game, but generally you don't interact with <code>GameManager</code> directly since it's located in the <code>src/engine_lib/private</code> directory, the <code>GameManager</code> creates essential game objects such as renderer, physics engine, audio manager and your <code>GameInstance</code>. While the window that your have created is not closed the <code>GameInstance</code> lives and your game runs. Once the user closes your window or your game code submits a "close window" command the <code>GameManager</code> starts to destroy all created systems: <code>World</code> (which despawns and destroys all nodes), <code>GameInstance</code>, renderer and other things.</p>
<p >When <code>GameInstance</code> is created and everything is setup for the game to start <code>GameInstance::onGameStarted</code> is called. In this function you generally create/load a game world and spawn some nodes. Generally there is no need to store pointers to nodes in your <code>GameInstance</code> since nodes are self-contained and each node knows what to do except that nodes sometimes ask <code>GameInstance</code> for various global information by using the static function <code>Node::getGameInstance</code>.</p>
<p >So "global" (world independent) classes/objects are generally stored in <code>GameInstance</code> but sometimes they can be represented by a node.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Reflection basics</h2>
<h3><a class="anchor" id="autotoc_md14"></a>
General</h3>
<p >Have you used other game engines? Generally game engines have an editor application that allows placing your custom objects on the map and construct levels. The general process goes like this: you create a new class in the code, compile the code, open up the editor and the editor is able to see you newly created class and allows you to place objects of the class on the level/map. The ability to see/analyze your code is what reflection is about.</p>
<p >Generally reflection comes down to writing additional code to your class, this additional code allows other systems to see/analyze your class/objects (see functions/fields, even private).</p>
<p >Reflection helps us save time and ease up some processes. Let's consider an example: you want to have a save file for your game where you store player's progress. For this you can use a <code>ConfigManager</code> and save your variables like this:</p>
<div class="fragment"><div class="line">ConfigManager manager;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Save.</span></div>
<div class="line">manager.setValue&lt;std::string&gt;(<span class="stringliteral">&quot;player progress&quot;</span>, <span class="stringliteral">&quot;player name&quot;</span>, playerConfig.getName());</div>
<div class="line">manager.setValue&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;player progress&quot;</span>, <span class="stringliteral">&quot;player level&quot;</span>, playerConfig.getLevel());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Load.</span></div>
<div class="line"><span class="keyword">auto</span> sPlayerName = manager.getValue&lt;std::string&gt;(<span class="stringliteral">&quot;player progress&quot;</span>, <span class="stringliteral">&quot;player name&quot;</span>, <span class="stringliteral">&quot;default name&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> iPlayerLevel = manager.setValue&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;player progress&quot;</span>, <span class="stringliteral">&quot;player level&quot;</span>, 1);</div>
</div><!-- fragment --><p >but each time you need to save a new variable in the save file you need to append new code to save/load functions. With reflection you don't need to care about this. Here is the same example as above but it uses reflection:</p>
<div class="fragment"><div class="line"><span class="comment">// PlayerConfig.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;PlayerConfig.generated_impl.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// PlayerConfig.h ------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;io/Serializable.h&quot;</span> <span class="comment">// base class for types that use reflection to be able to</span></div>
<div class="line">                             <span class="comment">// save/load on disk</span></div>
<div class="line"><span class="comment">// ... your other includes here ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;PlayerConfig.generated.h&quot;</span> <span class="comment">// must be included last, contains generated reflection code</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne; <span class="comment">// engine namespace, all engine types are located in this namespace</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>mygame RNAMESPACE(){</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;9ae433d9-2cba-497a-8061-26f2683b4f35&quot;</span>)) PlayerConfig : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1Serializable.html">Serializable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PlayerConfig() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> ~PlayerConfig() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    std::string sPlayerName;</div>
<div class="line"> </div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    <span class="keywordtype">int</span> iPlayerLevel = 1;</div>
<div class="line"> </div>
<div class="line">    mygame_PlayerConfig_GENERATED</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">File_PlayerConfig_GENERATED</div>
<div class="ttc" id="aclassne_1_1Guid_html"><div class="ttname"><a href="classne_1_1Guid.html">ne::Guid</a></div><div class="ttdef"><b>Definition:</b> GuidProperty.h:30</div></div>
<div class="ttc" id="aclassne_1_1Serializable_html"><div class="ttname"><a href="classne_1_1Serializable.html">ne::Serializable</a></div><div class="ttdef"><b>Definition:</b> Serializable.h:113</div></div>
<div class="ttc" id="aclassne_1_1Serialize_html"><div class="ttname"><a href="classne_1_1Serialize.html">ne::Serialize</a></div><div class="ttdef"><b>Definition:</b> SerializeProperty.h:42</div></div>
</div><!-- fragment --><p >now when you add a new variable you just need to mark it as <code>RPROPERTY(Serialize)</code> and that's it, it will be saved and loaded from save file on the disk. Thanks to reflection the engine is able to see fields marked as <code>RPROPERTY(Serialize)</code> and when you ask the engine to serialize an object of <code>PlayerConfig</code> type it will save all <code>RPROPERTY(Serialize)</code> fields to the save file.</p>
<p >We will talk about serialization (using various ways) in more details with more detailed examples in one of the next sections.</p>
<p >Note that reflection that we use relies on code generation, this means that when you create a class and add reflection specific code (include generated header, add <code>RPROPERTY</code> and etc.) your IDE will mark them as errors since the generated header is not created yet and thus macros like <code>RPROPERTY</code> are unknown. You need to ignore those errors, finish writing reflection specific code and compile your program. During the compilation, as one of the first build steps the reflection generator will analyze all source files in your project and see if some "generated" headers needs to be generated, then it generates them in <code>src/*yourtarget*/.generated</code> directory and after the reflection generator your compiler comes in and compiles your program, it will find no issues since the generated headers now exist and all included macros are known. After the compilation your IDE should also start to see new generated headers and will hide previously shown errors.</p>
<p >Let's analyze the example from above:</p>
<ul>
<li><code>#include "PlayerConfig.generated.h"</code><ul>
<li>an include with name <code>*yourheadername*.generated.h</code> needs to be included as the last <code>#include</code> in your header, it contains reflection macros/code</li>
<li>as you may have noticed you also need to include <code>#include "*yourheadername*.generated_impl.h"</code> in your .cpp file</li>
</ul>
</li>
<li><code>namespace mygame RNAMESPACE()</code><ul>
<li>here <code>RNAMESPACE</code> is a reflection macro (R stands for Reflected) that is used to mark a namespace to be added to reflection database</li>
</ul>
</li>
<li><code>class RCLASS(Guid("9ae433d9-2cba-497a-8061-26f2683b4f35")) PlayerConfig</code><ul>
<li>here <code>RCLASS</code> is a reflection macro that is used to mark class to be added to reflection database, if you have a struct you need to use <code>RSTRUCT</code> macro</li>
<li><code>Guid</code> is a property of <code>RCLASS</code> macro that is used to specify a unique GUID that the class should be associated with, for example when you serialize an object of this class into a file on the disk this GUID will be saved in the file to mark that <code>PlayerConfig</code> class is saved here, you can generate a GUID by simply searching something like "generate GUID" on the Internet, any GUID will be fine but if some type already uses this GUID the engine will let you know at startup, in debug builds the engine checks for GUID uniqueness</li>
</ul>
</li>
<li><code>RPROPERTY(Serialize)</code><ul>
<li><code>RPROPERTY</code> is a macro that marks a field to be added to reflection database as part of the class, you can have this macro defined without other properties but in this case we use a property named <code>Serialize</code> - this property tells the engine that when an object of this class is being serialized the value of this field should also be serialized, additionally when you deserialize a file that value will be deserialized into this field</li>
</ul>
</li>
<li><code>mygame_PlayerConfig_GENERATED</code><ul>
<li>a macro <code>*namespace*_*typename*_GENERATED</code> should be specified in the end of your type for reflection to work correctly, if you use nested types/namespaces this macro name will contain them all: <code>*outerouter*_*outerinner*_*typename*_GENERATED</code></li>
</ul>
</li>
<li><code>File_PlayerConfig_GENERATED</code><ul>
<li>a macro <code>File_*headername*_GENERATED</code> should be specfiied in the end of your header file for reflection to work correctly</li>
</ul>
</li>
</ul>
<p >Note that in order to use reflection you don't need to derive from <code>Serializable</code> in this example we derive from <code>Serializable</code> for serialization/deserialization functionality. Also note that <code>Node</code> class derives from <code>Serializable</code>, this means that all <code>Node</code> and derived classes have serialization/deserialization functionality.</p>
<p >For more information about reflection generator see our reflection generator fork: <a href="https://github.com/Flone-dnb/Refureku">https://github.com/Flone-dnb/Refureku</a></p>
<p >Documentation for the original reflection generator: <a href="https://github.com/jsoysouvanh/Refureku/wiki">https://github.com/jsoysouvanh/Refureku/wiki</a></p>
<h3><a class="anchor" id="autotoc_md15"></a>
Using reflection for your new type</h3>
<p >Let's sum up what you need to do in order to use reflection:</p>
<ol type="1">
<li>Include <code>*filename*.generated.h</code> as the last include in your .h file (where <em>filename</em> is file name without extension).</li>
<li>Include <code>*filename*.generated_impl.h</code> as the last include in your .cpp file (where <em>filename</em> is file name without extension).</li>
<li>If you have a namespace add a <code>RNAMESPACE()</code> macro, for example: <code>namespace mygame RNAMESPACE()</code>.</li>
<li>Mark your class/struct with <code>RCLASS</code>/<code>RSTRUCT</code>, for example: <code>class RCLASS() PlayerConfig</code>.</li>
<li>In the end of your type (as the last line of your type) add a macro <code>*namespace*_*typename*_GENERATED</code> or just <code>*typename*_GENERATED</code> if you don't have a namespace, if you use nested types/namespaces this macro name will contain them all: <code>*outerouter*_*outerinner*_*typename*_GENERATED</code>, for example: <code>mygame_PlayerConfig_GENERATED</code>.</li>
<li>In the end of your header file add a macro <code>File_*filename* _GENERATED</code> (where <em>filename</em> is file name without extension), for example: <code>File_PlayerConfig_GENERATED</code>.</li>
</ol>
<p >After this you can use reflection macros like <code>RPROPERTY</code>/<code>RFUNCTION</code>. We will talk about reflection macros/properties in more details in one of the next sections.</p>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;Steps from above describe basic reflection usage and generally this will not be enough for engine-related things such as serialization and some editor features. Other sections of this manual will describe additional steps that you need to apply to your type in order to use various engine-related features that use reflection. </p>
</blockquote>
<p>For more examples see <code>src/engine_tests/io/ReflectionTest.h</code>.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Common mistakes when using reflection</h3>
<p >If you changed something in your header file and your IDE now shows errors in <code>GENERATED</code> macros just compile your project, it will run reflection generator and update reflection code, then the errors should disappear.</p>
<p >If you created/changes something in your header file related to reflection (renamed reflection macro, changed class name, etc.) and your compiler gives you and error about reflection files/macros, look at the build log and make sure that the reflection generator was actually run. Some IDEs like JetBrains Rider (maybe fixed) have an issue where they don't run pre-build steps of CMake targets (Qt Creator and Visual Studio 2022 were tested and they run reflection generator correctly). It's essential that reflection generator is run before the compiler, see the build log, when reflection generator is running you will see something like this in the build log:</p>
<div class="fragment"><div class="line">[2/109 1.0/sec] engine_lib: running reflection generator...</div>
<div class="line">[Info] Working Directory: ...\nameless-engine\ext\Refureku\build\Bin</div>
<div class="line">[Info] [TOML] Load cppVersion: c++20</div>
<div class="line">[Info] [TOML] Load shouldParseAllNamespaces: false</div>
<div class="line">[Info] [TOML] Load shouldParseAllClasses: false</div>
<div class="line">[Info] [TOML] Load compiler: clang++</div>
<div class="line">[Info] [TOML] Load new project include directory: C:\Prog\ne\nameless-engine\ext\Refureku\build\Include</div>
<div class="line">[Info] [TOML] Load new project include directory: C:\Prog\ne\nameless-engine\src\engine_lib\.generated</div>
<div class="line">...</div>
<div class="line">... // some output here</div>
<div class="line">...</div>
<div class="line">[Info] (Re)generated metadata for 0 file(s) in 0.005000 seconds.</div>
<div class="line">[Info] Metadata of 1 file(s) up-to-date.</div>
</div><!-- fragment --><p >If you get a compilation error like &lsquo;Cannot open include file: &rsquo;....generated.h': No such file or directory<code>this might either mean that the reflection generator was not run (see solution from the above) or that your CMake target does not have reflection generator enabled. Open your</code>CMakeLists.txt<code>file and make sure it has</code>add_refureku<code>command if there is no such command then reflection generator is not enabled and you might want to look at</code>CMakeLists.txt` of other targets to see how they use this command (not all CMake targets use reflection generator, generally only library targets use it).</p>
<p >If you added the reflection code but your project fails to compile at the linking stage make sure your <code>.cpp</code> file includes <code>*filename*.generated_impl.h</code> as its last include file.</p>
<p >In some rare cases you need to manually delete generated reflection files. For example if you made a typo and wrote <code>RPROPERTY(Serializable)</code> (while the correct macro/property is <code>RPROPERTY(Serialize)</code>), started compiling your project, the reflection generator run but there is a compilation error related to the reflection code. In this case even if you rename your macro/property to be correct you still might not be able to compile your project, if this is the case, go to the directory with generated code at <code>src/*yourtarget*/.generated</code> find a generated file named after your header file and delete 2 files <code>*yourfile*.generated.h</code> and <code>*yourfile*.generated_impl.h</code> (where <em>yourfile</em> is the file in which you had a mistake) then try to compile your project, it should succeed.</p>
<p >You can delete <code>.generated</code> directory but before building your project you need to re-run CMake configuration so that CMake will create a new <code>.generated</code> directory with a fresh new config files inside of it.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Error handling</h2>
<p >The engine uses the <code>Error</code> class (<code><a class="el" href="Error_8h_source.html">misc/Error.h</a></code>) to handle and propagate errors. Some engine functions return it and you should know how to use them.</p>
<p >The <code>Error</code> class stores 2 things:</p><ul>
<li>initial error message (description of what went wrong)</li>
<li>"error call stack" (not an actual call stack, see below)</li>
</ul>
<p >This class has some handy constructors, for example:</p><ul>
<li>(most commonly used) you can construct an <code>Error</code> object from a message string, it will be used as "initial error message",</li>
<li>you can construct an <code>Error</code> object from a Windows <code>HRESULT</code> object, in such constructor the <code>Error</code> class will convert it to an error description, append the error code of the <code>HRESULT</code> object and use it as "initial error message",</li>
<li>you can construct an <code>Error</code> object from an error code returned by Windows <code>GetLastError</code> function, just like with <code>HRESULT</code>, it will be converted to an error description.</li>
</ul>
<p >When you construct an <code>Error</code> object it will use <code>std::source_location</code> to capture the name of the source file it was constructed from, plus a line where this <code>Error</code> object was constructed.</p>
<p >After constructing an <code>Error</code> object you can use <code>Error::addEntry</code> to capture the name of the source file this function is called from, plus a line where this function was called from.</p>
<p >To get the string that contains the initial error message and all captured source "entries" you can use <code>Error::getFullErrorMessage</code>.</p>
<p >To show a message box with the full error message and additionally print it to the log you can use <code>Error::showError</code>.</p>
<p >Let's see how this works together in an example of window creation:</p>
<div class="fragment"><div class="line"><span class="comment">// inside of your main.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> result = Window::getBuilder()</div>
<div class="line">                  .withTitle(<span class="stringliteral">&quot;My window&quot;</span>)</div>
<div class="line">                  .withMaximizedState(<span class="keyword">true</span>)</div>
<div class="line">                  .withIcon(<span class="stringliteral">&quot;res/game/mylogo.png&quot;</span>)</div>
<div class="line">                  .build(); <span class="comment">// returns `std::variant&lt;std::unique_ptr&lt;Window&gt;, Error&gt;`</span></div>
<div class="line"><span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(result)) {</div>
<div class="line">    <span class="comment">// An error occurred while creating the window.</span></div>
<div class="line">    <a class="code hl_class" href="classne_1_1Error.html">Error</a> error = std::get&lt;Error&gt;(std::move(result));</div>
<div class="line">    error.addEntry(); <span class="comment">// add this line to the error stack</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since here we won&#39;t propagate the error up (because we are in the `main.cpp` file) we show an error message.</span></div>
<div class="line">    <span class="comment">// If we want to propagate the error up we can return the error object after using the `Error::addEntry`.</span></div>
<div class="line">    error.<a class="code hl_function" href="classne_1_1Error.html#ade90dc178bddb9810268ecdcf987b5ec">showError</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... and throw an exception to show an unrecoverable error.</span></div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(error.<a class="code hl_function" href="classne_1_1Error.html#a5b6c8b66765051c98f6d4d5bd81e941f">getFullErrorMessage</a>());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Window was created successfully.</span></div>
<div class="line"><span class="keyword">const</span> std::unique_ptr&lt;Window&gt; pMainWindow = std::get&lt;std::unique_ptr&lt;Window&gt;&gt;(std::move(result));</div>
<div class="ttc" id="aclassne_1_1Error_html"><div class="ttname"><a href="classne_1_1Error.html">ne::Error</a></div><div class="ttdef"><b>Definition:</b> Error.h:27</div></div>
<div class="ttc" id="aclassne_1_1Error_html_a5b6c8b66765051c98f6d4d5bd81e941f"><div class="ttname"><a href="classne_1_1Error.html#a5b6c8b66765051c98f6d4d5bd81e941f">ne::Error::getFullErrorMessage</a></div><div class="ttdeci">std::string getFullErrorMessage() const</div><div class="ttdef"><b>Definition:</b> Error.cpp:84</div></div>
<div class="ttc" id="aclassne_1_1Error_html_ade90dc178bddb9810268ecdcf987b5ec"><div class="ttname"><a href="classne_1_1Error.html#ade90dc178bddb9810268ecdcf987b5ec">ne::Error::showError</a></div><div class="ttdeci">void showError() const</div><div class="ttdef"><b>Definition:</b> Error.cpp:102</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Logging</h2>
<p >The engine has a simple <code>Logger</code> class (<code><a class="el" href="Logger_8h_source.html">io/Logger.h</a></code>) that you can use to write to log files and to console (note that logging to console is disabled in release builds).</p>
<p >On Windows log files are located at <code>%localappdata%/nameless-engine/*yourtargetname*/logs</code>. On Linux log files are located at <code>~/.config/nameless-engine/*yourtargetname*/logs</code>.</p>
<p >Here is an example of <code>Logger</code> usage:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;misc/Logger.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(){</div>
<div class="line">    Logger::get().info(<span class="stringliteral">&quot;some information&quot;</span>);</div>
<div class="line">    Logger::get().warn(<span class="stringliteral">&quot;some warning&quot;</span>);</div>
<div class="line">    Logger::get().error(<span class="stringliteral">&quot;some error&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p >You can also combine <code>std::format</code> with logger:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;misc/Logger.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;format&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar(){</div>
<div class="line">    <span class="keywordtype">int</span> iAnswer = 42;</div>
<div class="line">    Logger::get().info(std::format(<span class="stringliteral">&quot;the value of the variable is {}&quot;</span>, iAnswer));</div>
<div class="line">}</div>
</div><!-- fragment --><p >Then your log file might look like this:</p>
<div class="fragment"><div class="line">[16:14:49] [info] [MyFile.cpp, 31] some information</div>
<div class="line">[16:14:49] [warning] [MyFile.cpp, 32] some warning</div>
<div class="line">[16:14:49] [error] [MyFile.cpp, 33] some error</div>
<div class="line">[16:14:49] [info] [MyFile.cpp, 46] the value of the variable is 42</div>
</div><!-- fragment --><p >As you can see each log entry has a file name and a line number included.</p>
<p >Looking at your logs and finding if there were any warnings/errors might be tiresome if you have a big game with lots of systems (even if you just use Ctrl+F), to instantly identify if your game had warnings/errors in the log when you close your game the last log entry will be summary of total warnings/errors logged (if there was any, if there was no warnings/errors nothing will be logged in the end), it might look like this:</p>
<div class="fragment"><div class="line">[16:14:50] [info]</div>
<div class="line">---------------------------------------------------</div>
<div class="line">Total WARNINGS produced: 1.</div>
<div class="line">Total ERRORS produced: 1.</div>
<div class="line">---------------------------------------------------</div>
</div><!-- fragment --><p >You will see this message in the console and in the log files as the last message if there were any warnings and/or errors logged. So pay attention to the logs/console after closing your game.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Project paths</h2>
<p >In order for your game to be able to access files in the <code>res</code> directory when you build your project the engine creates symlinks to the <code>res</code> directory next to the build binaries of you game. This means that if you need to access some file from the <code>res</code> directory, in your app you can just type <code>"res/game/somepath"</code>. For release builds the engine will not create symlinks and will require you to copy your <code>res</code> directory manually but we will talk about this in more details in one of the next sections.</p>
<p >Instead of hardcoding you paths like <code>"res/game/somepath"</code> you should use <code>ProjectPaths</code> (<code><a class="el" href="ProjectPaths_8h_source.html">misc/ProjectPaths.h</a></code>). This class provides static functions to access various paths, here are a few examples:</p>
<div class="fragment"><div class="line"><span class="comment">// same as &quot;res/game/myfile.png&quot;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> absolutePathToMyFile = ProjectPaths::getPathToResDirectory(ResourceDirectory::GAME) / <span class="stringliteral">&quot;myfile.png&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// same as &quot;%localappdata%/nameless-engine/*targetname*/logs&quot; on Windows</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pathToLogsDir = ProjectPaths::getPathToLogsDirectory();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// same as &quot;%localappdata%/nameless-engine/*targetname*/progress&quot; on Windows</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pathToLogsDir = ProjectPaths::getPathToPlayerProgressDirectory();</div>
</div><!-- fragment --><p >See <code><a class="el" href="ProjectPaths_8h_source.html">misc/ProjectPaths.h</a></code> for more.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Memory leaks and garbage collection</h2>
<h3><a class="anchor" id="autotoc_md21"></a>
Memory leak checks</h3>
<p >By default in Debug builds memory leak checks are enabled, look for the output/debugger output tab of your IDE after running your project. If any leaks occurred it should print about them. You can test whether the memory leak checks are enabled or not by doing something like this: </p><div class="fragment"><div class="line"><span class="keyword">new</span> int(42);</div>
<div class="line"><span class="comment">// don&#39;t `delete`</span></div>
</div><!-- fragment --><p> run your program that runs this code and after your program is finished you should see a message about the memory leak in the output/debugger output tab of your IDE.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
About raw pointers</h3>
<p >Some engine functions return raw pointers. Generally, when the engine returns a raw pointer to you this means that you should not free/delete it and it is guaranteed to be valid for the (most) time of its usage. For more information read the documentation for the functions you are using.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Garbage collector overview</h3>
<p >The engine uses the following garbage collector: <a href="https://github.com/Flone-dnb/sgc">https://github.com/Flone-dnb/sgc</a>. The main reason why we need a garbage collector is to resolve cyclic references. The game has a node hierarchy that can change dynamically, nodes can reference other nodes that exist in the world and cyclic references could occur easily.</p>
<p >The garbage collector library provides a smart pointer <code>sgc::GcPtr&lt;T&gt;</code> that acts as a <code>std::shared_ptr&lt;T&gt;</code>, the library also has <code>sgc::GarbageCollector::get().collectGarbage()</code> function that is used to resolve cyclic references and free objects that are stuck in cyclic references. By default the engine runs garbage collection regularly so you don't have to care about it (and you don't need to call <code>sgc::GarbageCollector::get().collectGarbage()</code> from your game code). Here is an example on how to use these <code>sgc::GcPtr</code> objects:</p>
<div class="fragment"><div class="line">sgc::GcPtr&lt;MyNode&gt; pNode = sgc::makeGc&lt;MyNode&gt;(); <span class="comment">// it&#39;s like `std::make_shared&lt;MyNode&gt;()`</span></div>
</div><!-- fragment --><p >And here is a cyclic reference example that will be resolved by the garbage collector:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;GcPtr.h&quot;</span> <span class="comment">// include for `GC` pointers</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Foo{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    sgc::GcPtr&lt;Foo&gt; pFoo;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> pFoo = sgc::makeGc&lt;Foo&gt;();</div>
<div class="line">    pFoo-&gt;pFoo = pFoo; <span class="comment">// cyclic reference</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `Foo` still exists and was not freed, waiting for GC...</span></div>
<div class="line">sgc::GarbageCollector::get().collectGarbage(); <span class="comment">// this will be run regularly somewhere in the engine code</span></div>
<div class="line">                                               <span class="comment">// so you don&#39;t have to care about it</span></div>
<div class="line"><span class="comment">// `Foo` was freed</span></div>
</div><!-- fragment --><p >Because the engine runs garbage collection regularly we want to minimize the amount of <code>gc</code> pointers to minimize the amount of work that the garbage collector will do. If we would have used only <code>gc</code> pointers and used them a lot, the garbage collection would probably cause stutters or freezes that players would not appreciate.</p>
<p >"When should I use `gc` pointers" you might ask? The answer is simple: start by thinking with <code>std::unique_ptr</code>s, if you need more than just one owner think of <code>std::shared_ptr</code>s for the part of the code you are planning/developing, if you know that cyclic reference can occur - use <code>gc</code> pointers, otherwise - don't, because there would be no need for that. For example, we use <code>gc</code> pointers in the node system because we know that nodes can reference other nodes and can dynamically change references so cyclic references could occur easily.</p>
<p >Of course, not everything will work magically. There is one or two cases where garbage collector can fail (leak memory), but don't worry, if this will happen the engine will let you know by logging an error message with possible reasons on why that happend so pay attention to the logs and always read the documentation for the functions you are using.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
Storing GC pointers in containers</h3>
<p >Probably the most common mistake that could cause the garbage collection to fail is related to containers, because it's the most common mistake that developers could make, let's see how to avoid it. Imagine you want to store an array of <code>gc</code> pointers or store them in another container like <code>std::unordered_map</code>, you could write something like this:</p>
<div class="fragment"><div class="line">std::vector&lt;sgc::GcPtr&lt;MyNode&gt;&gt; vMyNodes; <span class="comment">// DON&#39;T DO THIS, this may leak</span></div>
</div><!-- fragment --><p >but due to garbage collector limitations this might cause memory leaks. Don't worry, when these leaks will happen the engine will log an error message with possible reasons on why that happend and possible solutions, so you will instantly know what to do. The right way to store <code>gc</code> pointers in a container will be the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;gccontainers/GcVector.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line">sgc::GcVector&lt;sgc::GcPtr&lt;MyNode&gt;&gt; vMyNodes; <span class="comment">// works just like `std::vector&lt;T&gt;`</span></div>
</div><!-- fragment --><p >Not all STL containers have <code>gc</code> alternative, see the garbage collector's repository for more information.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
GC limitations and thread safety with examples</h3>
<p >It's really important that you know how to properly use the GC objects.</p>
<p >Use the link to the garbage collector's repository (see above) and make sure to read the <code>README</code> file (especially the limitations and thread safety sections).</p>
<p >Here's what you don't need to care about in your game's code:</p>
<ul>
<li>No need to set GC info callbacks because the engine does that for you.</li>
<li>No need to directly interact with <code>sgc::GarbageCollector</code> because the engine runs garbage collector regularly and in some special situations.</li>
<li>No need to add GC to your game's cmake file because it's already included in the engine's cmake target.</li>
</ul>
<h3><a class="anchor" id="autotoc_md26"></a>
Interacting with garbage collector</h3>
<p ><code>GameInstance</code> class has function to interact with the garbage collector, such as:</p>
<ul>
<li><code>getGarbageCollectorRunIntervalInSec</code> to get the time interval after which the GC runs again.</li>
<li><code>setGarbageCollectorRunInterval</code> to set the time interval after which the GC runs again.</li>
<li>and probably more, see the <code>GameInstance</code> class for more details...</li>
</ul>
<p >Just note that you don't need to directly use <code>sgc::GarbageCollector</code> (if you maybe saw this somewhere in examples), the engine will use it, you on the other hand should use <code>GameInstance</code> functions for garbage collection.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Deferred tasks and thread pool</h2>
<p >The engine has 2 kind tasks you might be interested in:</p>
<ul>
<li>a <code>deferred task</code> is a function/lambda that is executed on the main thread,<ul>
<li>you can submit deferred tasks from non-main thread to run some logic on the main thread,</li>
<li>you can also submit deferred tasks while being on the main thread, this will just queue your task and execute in slightly later on the main thread</li>
<li>deferred tasks are processed every time before a new frame is drawn</li>
</ul>
</li>
<li>a <code>thread pool task</code> is a function/lambda that is executed inside of a thread pool (non-main thread), you can submit a function/lambda to a thread pool to run asynchronous logic</li>
</ul>
<p >The engine guarantees that:</p><ul>
<li>all deferred tasks and all thread pool tasks will be finished before your <code>GameInstance</code> is destroyed so you don't need to check whether the game is closing or not in your deferred/thread pool tasks</li>
<li>all deferred tasks submitted from the main thread will be finished before garbage collector runs, this means that if you submit deferred tasks from the main thread you can pass raw node pointers (such as <code>Node*</code>) and use them in deferred tasks without risking to hit deleted memory</li>
</ul>
<p >Submitting a deferred task from a <code>non-main thread</code> where in deferred task you operate on a <code>gc</code> controlled object such as Node can be dangerous as you may operate on a deleted (freed) memory. The engine roughly speaking does the following:</p>
<div class="fragment"><div class="line">executeDeferredTasks();</div>
<div class="line">runGarbageCollector();</div>
</div><!-- fragment --><p >and if you are submitting a deferred task from a non-main thread you might get into the following situation:</p>
<div class="fragment"><div class="line">executeDeferredTasks();</div>
<div class="line"><span class="comment">// your non-main thread added a new deferred task here</span></div>
<div class="line">runGarbageCollector();</div>
<div class="line"><span class="comment">// or your non-main thread added a new deferred task here</span></div>
</div><!-- fragment --><p >In this case use additional checks in the beginning of your deferred task to check if the node you want to use is still valid:</p>
<div class="fragment"><div class="line"><span class="comment">// We are on a non-main thread inside of a node:</span></div>
<div class="line">addDeferredTask([<span class="keyword">this</span>, iNodeId](){ <span class="comment">// capturing `this` to use `Node` (self) functions, also capturing self ID</span></div>
<div class="line">    <span class="comment">// We are inside of a deferred task (on the main thread) and we don&#39;t know if the node (`this`)</span></div>
<div class="line">    <span class="comment">// was garbage collected or not because we submitted our task from a non-main thread.</span></div>
<div class="line">    <span class="comment">// REMEMBER: we can&#39;t capture `gc` pointers in `std::function`, this is not supported</span></div>
<div class="line">    <span class="comment">// and will cause memory leaks/crashes!</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pGameManager = GameManager::get(); <span class="comment">// using engine&#39;s private class `GameManager`</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// `pGameManager` is guaranteed to be valid inside of a deferred task.</span></div>
<div class="line">    <span class="comment">// Otherwise, if running this code outside of a deferred task you need to do 2 checks:</span></div>
<div class="line">    <span class="comment">// if (pGameManager == nullptr) return;</span></div>
<div class="line">    <span class="comment">// if (pGameManager-&gt;isBeingDestroyed()) return;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!pGameManager-&gt;isNodeSpawned(iNodeId)){</div>
<div class="line">        <span class="comment">// Node was despawned and it may be dangerous to run the callback.</span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Can safely interact with `this` (self) - we are on the main thread.</span></div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
World creation</h2>
<h3><a class="anchor" id="autotoc_md29"></a>
World axes and world units</h3>
<p >The engine uses a left handed coordinate system. +X is world "forward" direction, +Y is world "right" direction and +Z is world "up" direction. These directions are stored in <code>Globals::WorldDirection</code> (<code><a class="el" href="Globals_8h_source.html">misc/Globals.h</a></code>).</p>
<p >Rotations are applied in the following order: ZYX, so "yaw" is applied first, then "pitch" and then "roll". If you need to do manual math with rotations you can use <code>MathHelpers::buildRotationMatrix</code> that builds a rotation matrix with correct rotation order.</p>
<p >1 world unit is expected to be equal to 1 meter in your game.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Creating a world using C++</h3>
<p >Let's first make sure you know how to create a window, your <code>main.cpp</code> should generally look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Standard.</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;MyGameInstance.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/Window.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;misc/ProjectPaths.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a game window.</span></div>
<div class="line">    <span class="keyword">auto</span> result =</div>
<div class="line">        Window::getBuilder()</div>
<div class="line">            .withTitle(<span class="stringliteral">&quot;My Game&quot;</span>)</div>
<div class="line">            .withMaximizedState(<span class="keyword">true</span>)</div>
<div class="line">            .withIcon(</div>
<div class="line">                ProjectPaths::getPathToResDirectory(ResourceDirectory::GAME) / <span class="stringliteral">&quot;my_game_icon.png&quot;</span>)</div>
<div class="line">            .build();</div>
<div class="line">    <span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(result)) {</div>
<div class="line">        <a class="code hl_class" href="classne_1_1Error.html">Error</a> error = std::get&lt;Error&gt;(std::move(result));</div>
<div class="line">        error.<a class="code hl_function" href="classne_1_1Error.html#ab597ff09fa96e109686cc66081a0ca80">addCurrentLocationToErrorStack</a>();</div>
<div class="line">        error.<a class="code hl_function" href="classne_1_1Error.html#ade90dc178bddb9810268ecdcf987b5ec">showError</a>();</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error(error.<a class="code hl_function" href="classne_1_1Error.html#a5b6c8b66765051c98f6d4d5bd81e941f">getFullErrorMessage</a>());</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">auto</span> pMainWindow = std::get&lt;std::unique_ptr&lt;Window&gt;&gt;(std::move(result));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Run game loop.</span></div>
<div class="line">    pMainWindow-&gt;processEvents&lt;MyGameInstance&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassne_1_1Error_html_ab597ff09fa96e109686cc66081a0ca80"><div class="ttname"><a href="classne_1_1Error.html#ab597ff09fa96e109686cc66081a0ca80">ne::Error::addCurrentLocationToErrorStack</a></div><div class="ttdeci">void addCurrentLocationToErrorStack(const std::source_location location=std::source_location::current())</div><div class="ttdef"><b>Definition:</b> Error.cpp:80</div></div>
</div><!-- fragment --><p >And your game instance would generally look like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/GameInstance.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classne_1_1Window.html">Window</a>;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classne_1_1GameManager.html">GameManager</a>;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classne_1_1InputManager.html">InputManager</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyGameInstance : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1GameInstance.html">GameInstance</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyGameInstance(<a class="code hl_class" href="classne_1_1Window.html">Window</a>* pWindow, <a class="code hl_class" href="classne_1_1GameManager.html">GameManager</a>* pGameManager, <a class="code hl_class" href="classne_1_1InputManager.html">InputManager</a>* pInputManager);</div>
<div class="line">    <span class="keyword">virtual</span> ~MyGameInstance() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onGameStarted() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassne_1_1GameInstance_html"><div class="ttname"><a href="classne_1_1GameInstance.html">ne::GameInstance</a></div><div class="ttdef"><b>Definition:</b> GameInstance.h:32</div></div>
<div class="ttc" id="aclassne_1_1GameManager_html"><div class="ttname"><a href="classne_1_1GameManager.html">ne::GameManager</a></div><div class="ttdef"><b>Definition:</b> GameManager.h:34</div></div>
<div class="ttc" id="aclassne_1_1InputManager_html"><div class="ttname"><a href="classne_1_1InputManager.html">ne::InputManager</a></div><div class="ttdef"><b>Definition:</b> InputManager.h:77</div></div>
<div class="ttc" id="aclassne_1_1Window_html"><div class="ttname"><a href="classne_1_1Window.html">ne::Window</a></div><div class="ttdef"><b>Definition:</b> Window.h:198</div></div>
</div><!-- fragment --><p >Now let's see how we can create a world in <code>onGameStarted</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MyGameInstance.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/node/MeshNode.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;misc/PrimitiveMeshGenerator.h&quot;</span></div>
<div class="line"> </div>
<div class="line">MyGameInstance::MyGameInstance(</div>
<div class="line">    <a class="code hl_class" href="classne_1_1Window.html">Window</a>* pWindow, <a class="code hl_class" href="classne_1_1GameManager.html">GameManager</a>* pGameManager, <a class="code hl_class" href="classne_1_1InputManager.html">InputManager</a>* pInputManager)</div>
<div class="line">    : <a class="code hl_class" href="classne_1_1GameInstance.html">GameInstance</a>(pWindow, pGameManager, pInputManager) {}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted(){</div>
<div class="line">    <span class="comment">// Create world.</span></div>
<div class="line">    createWorld([<span class="keyword">this</span>](<span class="keyword">const</span> std::optional&lt;Error&gt;&amp; optionalWorldError) {</div>
<div class="line">        <span class="comment">// Show error if failed.</span></div>
<div class="line">        <span class="keywordflow">if</span> (optionalWorldError.has_value()) [[unlikely]] {</div>
<div class="line">            auto error = optionalWorldError.value();</div>
<div class="line">            error.addCurrentLocationToErrorStack();</div>
<div class="line">            error.showError();</div>
<div class="line">            throw std::runtime_error(error.getFullErrorMessage());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn sample mesh.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pMeshNode = sgc::makeGc&lt;MeshNode&gt;();</div>
<div class="line">        pMeshNode-&gt;setMeshData(PrimitiveMeshGenerator::createCube(1.0F));</div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pMeshNode);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set mesh node location.</span></div>
<div class="line">        pMeshNode-&gt;setWorldLocation(glm::vec3(1.0F, 0.0F, 0.0F));</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p >The code from above creates a new world with just 2 nodes: a root node and a mesh node. As you can see you specify a callback function that will be called once the world is created.</p>
<p >Unfortunatelly you would also need a camera to see your world but we will discuss this in the next section, for now let's talk about world creation.</p>
<p >If you instead want to load some level/map as your new world you need to use <code>loadNodeTreeAsWorld</code> instead of <code>createWorld</code>, see an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MyGameInstance.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/node/MeshNode.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;misc/PrimitiveMeshGenerator.h&quot;</span></div>
<div class="line"> </div>
<div class="line">MyGameInstance::MyGameInstance(</div>
<div class="line">    <a class="code hl_class" href="classne_1_1Window.html">Window</a>* pWindow, <a class="code hl_class" href="classne_1_1GameManager.html">GameManager</a>* pGameManager, <a class="code hl_class" href="classne_1_1InputManager.html">InputManager</a>* pInputManager)</div>
<div class="line">    : <a class="code hl_class" href="classne_1_1GameInstance.html">GameInstance</a>(pWindow, pGameManager, pInputManager) {}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted(){</div>
<div class="line">    <span class="comment">// Prepare path to your node tree to load.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pathToMyLevel = ProjectPaths::getPathToResDirectory(ResourceDirectory::GAME) / <span class="stringliteral">&quot;mylevel.toml&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Deserialize world.</span></div>
<div class="line">    loadNodeTreeAsWorld(</div>
<div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> std::optional&lt;Error&gt;&amp; optionalWorldError) {</div>
<div class="line">            <span class="comment">// Show error if failed.</span></div>
<div class="line">            <span class="keywordflow">if</span> (optionalWorldError.has_value()) [[unlikely]] {</div>
<div class="line">                auto error = optionalWorldError.value();</div>
<div class="line">                error.addCurrentLocationToErrorStack();</div>
<div class="line">                error.showError();</div>
<div class="line">                throw std::runtime_error(error.getFullErrorMessage());</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// World is loaded.</span></div>
<div class="line">        },</div>
<div class="line">        pathToMyLevel);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
Lighting</h2>
<p >Light source nodes (such as point/spot/directional) are stored in <code>game/node/light</code>. Just spawn one of these nodes and configure their setting using <code>setLight...</code> functions and <code>setWorldLocation</code>/<code>setWorldRotation</code>. Here is an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;game/node/light/PointLightNode.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted(){</div>
<div class="line">    <span class="comment">// Create world.</span></div>
<div class="line">    createWorld([<span class="keyword">this</span>](<span class="keyword">const</span> std::optional&lt;Error&gt;&amp; optionalWorldError) {</div>
<div class="line">        <span class="comment">// Show error if failed.</span></div>
<div class="line">        <span class="keywordflow">if</span> (optionalWorldError.has_value()) [[unlikely]] {</div>
<div class="line">            auto error = optionalWorldError.value();</div>
<div class="line">            error.addCurrentLocationToErrorStack();</div>
<div class="line">            error.showError();</div>
<div class="line">            throw std::runtime_error(error.getFullErrorMessage());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn sample mesh.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pMeshNode = sgc::makeGc&lt;MeshNode&gt;();</div>
<div class="line">        pMeshNode-&gt;setMeshData(PrimitiveMeshGenerator::createCube(1.0F));</div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pMeshNode);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set mesh node location.</span></div>
<div class="line">        pMeshNode-&gt;setWorldLocation(glm::vec3(1.0F, 0.0F, 0.0F));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn point light.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pPointLightNode = sgc::makeGc&lt;PointLightNode&gt;();</div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pPointLightNode);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Configure point light.</span></div>
<div class="line">        pPointLightNode-&gt;setLightColor(glm::vec3(0.0F, 1.0F, 0.0F));      <span class="comment">// emit green light</span></div>
<div class="line">        pPointLightNode-&gt;setLightHalfDistance(20.0F);                     <span class="comment">// change light radius</span></div>
<div class="line">        pPointLightNode-&gt;setWorldLocation(glm::vec3(-1.0F, 5.0F, 5.0F));  <span class="comment">// move the light</span></div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Environment</h2>
<p >Using <code>EnvironmentNode</code> you can configure environment settings such as ambient light, skybox, etc. Here is an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;game/node/EnvironmentNode.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted(){</div>
<div class="line">    <span class="comment">// Create world.</span></div>
<div class="line">    createWorld([<span class="keyword">this</span>](<span class="keyword">const</span> std::optional&lt;Error&gt;&amp; optionalWorldError) {</div>
<div class="line">        <span class="comment">// Show error if failed.</span></div>
<div class="line">        <span class="keywordflow">if</span> (optionalWorldError.has_value()) [[unlikely]] {</div>
<div class="line">            auto error = optionalWorldError.value();</div>
<div class="line">            error.addCurrentLocationToErrorStack();</div>
<div class="line">            error.showError();</div>
<div class="line">            throw std::runtime_error(error.getFullErrorMessage());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn sample mesh.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pMeshNode = sgc::makeGc&lt;MeshNode&gt;();</div>
<div class="line">        pMeshNode-&gt;setMeshData(PrimitiveMeshGenerator::createCube(1.0F));</div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pMeshNode);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set mesh node location.</span></div>
<div class="line">        pMeshNode-&gt;setWorldLocation(glm::vec3(1.0F, 0.0F, 0.0F));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn environment node.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pEnvironmentNode = sgc::makeGc&lt;EnvironmentNode&gt;();</div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pEnvironmentNode);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Configure environment settings.</span></div>
<div class="line">        pEnvironmentNode-&gt;setAmbientLight(glm::vec3(0.1F, 0.1F, 0.1F)); <span class="comment">// add small ambient lighting</span></div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p >Note that your world can only have 1 active environment node. If you will spawn another environment node you will get a warning in the logs that will tell you that settings of your newly spawned environment node will be ignored.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Creating a character and working with input</h2>
<h3><a class="anchor" id="autotoc_md34"></a>
Creating a simple flying character node</h3>
<p >In this section we will start with the most simplest character node: a node that has a camera and can fly around using WASD and mouse movement.</p>
<p >Let's create new files <code>FlyingCharacter.h</code> and <code>FlyingCharacter.cpp</code> inside of our new directory named <code>private/node</code> to our library target (we pick our library target since generally library targets will contain all functionality (so that it can be used in multiple executable targets such as <code>tests</code>) while executable targets generally will only contain <code>main.cpp</code>). Open <code>CMakeLists.txt</code> of your library target and add new files to <code>PROJECT_SOURCES</code>:</p>
<div class="fragment"><div class="line">## `CMakeLists.txt`</div>
<div class="line">## ... some code here ...</div>
<div class="line"> </div>
<div class="line">## Specify project sources.</div>
<div class="line">set(PROJECT_SOURCES</div>
<div class="line">    ## ... some files here ...</div>
<div class="line">    private/node/FlyingCharacter.h</div>
<div class="line">    private/node/FlyingCharacter.cpp</div>
<div class="line">    ## add your .h/.cpp files here</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">## Define target.</div>
<div class="line">add_library(${PROJECT_NAME} STATIC ${PROJECT_SOURCES})</div>
<div class="line"> </div>
<div class="line">## ... some code here ...</div>
</div><!-- fragment --><p >Now make sure CMake configuration was run, for example, Qt Creator runs CMake configuration after your make modifications to a <code>CMakeLists.txt</code> file and save it.</p>
<p >Now let's create our character node. We have two choises: we can derive our flying character node from <code>CameraNode</code> (it derives from <code>SpatialNode</code> so it has a location/rotation/scale in 3D world) or derive from <code>SpatialNode</code> and attach a <code>CameraNode</code> to it. Since more complicated characters will require multiple nodes such as: collision node, mesh node, camera node that will be somehow attached we will derive from <code>SpatialNode</code> and demonstrate how you can attach a <code>CameraNode</code>.</p>
<p >We will start with the most basic node header file:</p>
<div class="fragment"><div class="line"><span class="comment">// FlyingCharacter.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/node/SpatialNode.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Using engine namespace.</span></div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>FlyingCharacterNode : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1SpatialNode.html">SpatialNode</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FlyingCharacterNode();</div>
<div class="line">    FlyingCharacterNode(<span class="keyword">const</span> std::string&amp; sNodeName);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> ~FlyingCharacterNode() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassne_1_1SpatialNode_html"><div class="ttname"><a href="classne_1_1SpatialNode.html">ne::SpatialNode</a></div><div class="ttdef"><b>Definition:</b> SpatialNode.h:12</div></div>
</div><!-- fragment --><p >As you can see we created 2 constructors, engine's node classes have 2 constructors (1 without a name and 1 with a name) so we will also define 2 constructors just to be consistent with the engine (although you are not required to do this).</p>
<p >Now the .cpp file:</p>
<div class="fragment"><div class="line"><span class="comment">// FlyingCharacter.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.h&quot;</span></div>
<div class="line"> </div>
<div class="line">FlyingCharacterNode::FlyingCharacterNode() : FlyingCharacterNode(<span class="stringliteral">&quot;Flying Character Node&quot;</span>) {}</div>
<div class="line"> </div>
<div class="line">FlyingCharacterNode::FlyingCharacterNode(<span class="keyword">const</span> std::string&amp; sNodeName) : <a class="code hl_class" href="classne_1_1SpatialNode.html">SpatialNode</a>(sNodeName) {</div>
<div class="line">    <span class="comment">// constructor logic</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Engine's nodes do the same thing as we did here: their constructor without parameters is delegating constructor that calls constructor with a name and provides a default node name (and does nothing). The actual construction logic happens in the constructor that accepts a node name.</p>
<p >Now let's add reflection to our node so that the editor will be able to recognize our node and the engine will be able to save/load our node when we are using it as part of some node tree.</p>
<div class="fragment"><div class="line"><span class="comment">// FlyingCharacter.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/node/SpatialNode.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.generated.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;0f84de3a-b5bb-42c7-aeea-aef89d31ed63&quot;</span>)) FlyingCharacterNode : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1SpatialNode.html">SpatialNode</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FlyingCharacterNode();</div>
<div class="line">    FlyingCharacterNode(<span class="keyword">const</span> std::string&amp; sNodeName);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> ~FlyingCharacterNode() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    FlyingCharacterNode_GENERATED</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">File_FlyingCharacter_GENERATED</div>
</div><!-- fragment --><p >Note </p><blockquote class="doxtable">
<p >&zwj;<code>FlyingCharacterNode_GENERATED</code> and <code>File_FlyingCharacter_GENERATED</code> are different, one defines a <code>Node</code> class and the other defines a file name. </p>
</blockquote>
<p>We followed instructions from one of the previous sections in the manual where we discussed reflection. Also don't forget to update our <code>.cpp</code> file:</p>
<div class="fragment"><div class="line"><span class="comment">// FlyingCharacter.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.generated_impl.h&quot;</span> <span class="comment">// &lt;- new include, should be last</span></div>
<div class="line"> </div>
<div class="line">FlyingCharacterNode::FlyingCharacterNode() : FlyingCharacterNode(<span class="stringliteral">&quot;Flying Character Node&quot;</span>) {}</div>
<div class="line"> </div>
<div class="line">FlyingCharacterNode::FlyingCharacterNode(<span class="keyword">const</span> std::string&amp; sNodeName) : <a class="code hl_class" href="classne_1_1SpatialNode.html">SpatialNode</a>(sNodeName) {</div>
<div class="line">    <span class="comment">// constructor logic</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >As we said earlier your IDE might highlight new code as errors since the reflection headers were not generated yet. It's compile our project so that reflection headers will be generated.</p>
<p >Node </p><blockquote class="doxtable">
<p >&zwj;If your compilation fails at &lsquo;Cannot open include file: 'FlyingCharacter.generated.h&rsquo;: No such file or directory` this might indicate that either the reflection generator was not run or your CMake target does not have reflection generator enabled - see one of the previous sections about reflection for possible solutions. </p>
</blockquote>
<p >Now before moving to handling user input let's add a camera node. There are several ways on how we can do this and we will discuss various ways in one of the following sections, for now let's just create a camera node in our character's constructor. Let's create a new field in our class to store a <code>gc</code> pointer to the camera node:</p>
<div class="fragment"><div class="line"><span class="comment">// FlyingCharacter.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/node/SpatialNode.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.generated.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>ne {</div>
<div class="line">    <span class="keyword">class </span><a class="code hl_class" href="classne_1_1CameraNode.html">CameraNode</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;0f84de3a-b5bb-42c7-aeea-aef89d31ed63&quot;</span>)) FlyingCharacterNode : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1SpatialNode.html">SpatialNode</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FlyingCharacterNode();</div>
<div class="line"> </div>
<div class="line">    FlyingCharacterNode(<span class="keyword">const</span> std::string&amp; sNodeName);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> ~FlyingCharacterNode() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    sgc::GcPtr&lt;CameraNode&gt; pCameraNode;</div>
<div class="line"> </div>
<div class="line">    FlyingCharacterNode_GENERATED</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">File_FlyingCharacter_GENERATED</div>
<div class="ttc" id="aclassne_1_1CameraNode_html"><div class="ttname"><a href="classne_1_1CameraNode.html">ne::CameraNode</a></div><div class="ttdef"><b>Definition:</b> CameraNode.h:11</div></div>
</div><!-- fragment --><p >Note </p><blockquote class="doxtable">
<p >&zwj;We also added forward declaration of the camera node type <code>class CameraNode;</code>. </p>
</blockquote>
<p>Since nodes only use <code>gc</code> pointers we use it instead of some other smart pointer types.</p>
<p >Now let's create a camera node in our constructor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/node/CameraNode.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.generated_impl.h&quot;</span></div>
<div class="line"> </div>
<div class="line">FlyingCharacterNode::FlyingCharacterNode() : FlyingCharacterNode(<span class="stringliteral">&quot;Flying Character Node&quot;</span>) {}</div>
<div class="line"> </div>
<div class="line">FlyingCharacterNode::FlyingCharacterNode(<span class="keyword">const</span> std::string&amp; sNodeName) : <a class="code hl_class" href="classne_1_1SpatialNode.html">SpatialNode</a>(sNodeName) {</div>
<div class="line">    <span class="comment">// Create our camera node.</span></div>
<div class="line">    pCameraNode = sgc::makeGc&lt;CameraNode&gt;(<span class="stringliteral">&quot;Player Camera&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Attach the camera to the character.</span></div>
<div class="line">    addChildNode(pCameraNode, AttachmentRule::KEEP_RELATIVE, AttachmentRule::KEEP_RELATIVE);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Now let's compile our program and make sure we have a world, in our <code>GameInstance::onGameStarted</code> create an empty world:</p>
<div class="fragment"><div class="line"><span class="comment">// MyGameInstance.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;MyGameInstance.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;game/node/MeshNode.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;misc/PrimitiveMeshGenerator.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;nodes/FlyingCharacter.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted() {</div>
<div class="line">    <span class="comment">// Create world.</span></div>
<div class="line">    createWorld([<span class="keyword">this</span>](<span class="keyword">const</span> std::optional&lt;Error&gt;&amp; optionalWorldError) {</div>
<div class="line">        <span class="comment">// Check if there was an error.</span></div>
<div class="line">        <span class="keywordflow">if</span> (optionalWorldError.has_value()) [[unlikely]] {</div>
<div class="line">            auto error = optionalWorldError.value();</div>
<div class="line">            error.addCurrentLocationToErrorStack();</div>
<div class="line">            error.showError();</div>
<div class="line">            throw std::runtime_error(error.getFullErrorMessage());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Prepare a sample mesh.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pMeshNode = sgc::makeGc&lt;MeshNode&gt;();</div>
<div class="line">        pMeshNode-&gt;setMeshData(PrimitiveMeshGenerator::createCube(1.0F));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn mesh node.</span></div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pMeshNode);</div>
<div class="line">        pMeshNode-&gt;setWorldLocation(glm::vec3(1.0F, 0.0F, 0.0F));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn character node.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pCharacter = sgc::makeGc&lt;FlyingCharacterNode&gt;();</div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pCharacter);</div>
<div class="line">        pCharacter-&gt;setWorldLocation(glm::vec3(-1.0F, 0.0F, 0.0F));</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p >If you would compile and run your project now you still wouldn't be able to see anything. This is because we need to explicitly make character's camera active.</p>
<p >The documentation for <code>CameraNode::makeActive</code> says that "Only spawned camera nodes can be primary (active), otherwise an error will be shown." let's then override <code>Node::onSpawning</code> in our character. Add the following code to our character's header file:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onSpawning() <span class="keyword">override</span>;</div>
</div><!-- fragment --><p >The documentation for <code>Node::onSpawning</code> says "This node will be marked as spawned before this function is called." this means that when <code>Node::onSpawning</code> is called our node is already considered as spawned. Also the documentation says "If overriding you must call the parent's version of this function first (before executing your login) to execute parent's logic." so let's implement this function. In the <code>.cpp</code> file of our character add the following code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FlyingCharacterNode::onSpawning() {</div>
<div class="line">    SpatialNode::onSpawning(); <span class="comment">// call super class</span></div>
<div class="line"> </div>
<div class="line">    pCameraNode-&gt;makeActive(); <span class="comment">// make camera active</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >If you would compile and run your project now you will get an error saying "camera node "Player Camera" needs to be spawned in order to make it the active camera". If we would look at the documentation for <code>Node::onSpawning</code> again, we will see that it also says "This function is called before any of the child nodes are spawned. If you need to do some logic after child nodes are spawned use @ref onChildNodesSpawned." and since the camera node is a child node of our character when character node is spawning its child nodes are still waiting to be spawned. Thus let's use <code>onChildNodesSpawned</code> instead.</p>
<p >Replace <code>onSpawning</code> function with <code>onChildNodesSpawned</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FlyingCharacterNode::onChildNodesSpawned() {</div>
<div class="line">    SpatialNode::onChildNodesSpawned(); <span class="comment">// also change super call</span></div>
<div class="line"> </div>
<div class="line">    pCameraNode-&gt;makeActive();</div>
<div class="line">}</div>
</div><!-- fragment --><p >Now compile and run your project. There should be no errors but still black screen. This is because we forgot about the lighting. Let's create the Sun for our world. In our game instance add code to spawn a directional light:</p>
<div class="fragment"><div class="line"><span class="comment">// MyGameInstance.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;MyGameInstance.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;game/node/MeshNode.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;misc/PrimitiveMeshGenerator.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;nodes/FlyingCharacter.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/node/light/DirectionalLightNode.h&quot;</span> <span class="comment">// &lt;- new include</span></div>
<div class="line"><span class="preprocessor">#include &quot;math/MathHelpers.hpp&quot;</span>                    <span class="comment">// &lt;- new include</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted() {</div>
<div class="line">    <span class="comment">// Create world.</span></div>
<div class="line">    createWorld([<span class="keyword">this</span>](<span class="keyword">const</span> std::optional&lt;Error&gt;&amp; optionalWorldError) {</div>
<div class="line">        <span class="comment">// ... some code here ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn character node.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pCharacter = sgc::makeGc&lt;FlyingCharacterNode&gt;();</div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pCharacter);</div>
<div class="line">        pCharacter-&gt;setWorldLocation(glm::vec3(-1.0F, 0.0F, 0.0F));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Spawn directional light.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pDirectionalLightNode = sgc::makeGc&lt;DirectionalLightNode&gt;();</div>
<div class="line">        pDirectionalLightNode-&gt;setWorldRotation(</div>
<div class="line">            MathHelpers::convertDirectionToRollPitchYaw(glm::normalize(glm::vec3(1.0F, -1.0F, -1.0F))));</div>
<div class="line">        getWorldRootNode()-&gt;addChildNode(pDirectionalLightNode);</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p >You can also add other types of light sources or configure ambient lighting using <code>EnvironmentNode</code> but we will stick with the minimum for now.</p>
<p >If you run your project now you should see a cube. Now close your project, look at your console/logs and make sure there are no warnings/errors reported in the end.</p>
<p >We can now continue and work on handling user input to allow our character to fly.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
Working with user input</h3>
<h4><a class="anchor" id="autotoc_md36"></a>
Input events</h4>
<p >The usual way to handle user input is by binding to action/axis events and doing your processing once these events are triggered.</p>
<p >Each input event (action/axis event) is a pair:</p><ul>
<li>action event contains:<ul>
<li>action ID (<code>unsigned int</code>, for example 0, 1, 2, ...)</li>
<li>array of keys (for example key <code>W</code> and <code>ArrowUp</code>) that trigger the event</li>
</ul>
</li>
<li>axis event contains:<ul>
<li>axis ID (<code>unsigned int</code>, for example 0, 1, 2, ...)</li>
<li>array of key pairs (for example <code>W</code> and <code>S</code>, <code>ArrowUp</code> and <code>ArrowDown</code>) that trigger that event and define +1.0 and -1.0 states of the axis event</li>
</ul>
</li>
</ul>
<p >Action events are used for input that can only have 2 states: pressed and not pressed (for example a jump action), and axis events are used for input that can have a "smooth"/floating state (from -1.0 to +1.0, think about gamepad thumbsticks or <code>W</code>/<code>S</code> button combination for moving forward/backward).</p>
<p >Action events are a perfect case for, say, Jump or Fire/Shoot event since those can only have 2 states: on and off. So when you use an action event your input callback will receive input as a <code>bool</code> value (pressed/not pressed).</p>
<p >Axis events can be used for gamepad input and to replace 2 keyboard action events. You can have 2 action events: "moveForward" on <code>W</code> and "moveBackward" on <code>S</code> or just 1 axis event "moveForward" with <code>W</code> as +1.0 input and <code>S</code> as -1.0 input. So when you use an axis event your input callback will receive input as a <code>float</code> value (from +1.0 to -1.0).</p>
<p >Let's consider 2 examples for axis events:</p><ul>
<li>If we have gamepad thumbstick we can use 2 axis events: one for X movement and one for Y movement. As you might expect the X movement axis event will trigger +1.0 value when you move your thumbstick fully to the right and your axis event will trigger -1.0 when your thumbstick is moved fully to the left. You will receive 0.0 input when the thumbstick remains in its default (centered) state.</li>
<li>If you use a keyboard for moving your character you can use 2 axis events: one for right/left movement and one for forward/backward movement. When the user presses the button for moving forward you will receive +1.0 value and when the user presses the button for moving backward you will receive -1.0 value, same goes for right/left movement. When no button is pressed you will receive 0.0 value. For movement, since it has 2 directions on each axis it's better to use one axis event for each direction instead of 2 action events for each direction to simplify your code. In addition if in the future you will decide to add gamepad support if you have axis events for movement it will be very easy to bind gamepad input to movement while if you use action events you would have to rewrite them to use axis events.</li>
</ul>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;A so-called "repeat" input is disabled in the engine. "Repeat" input happens when use hold some button, while you hold it the window keeps receiving "repeat" input events with this button but the engine will ignore them and so if you will hold a button only pressed/released events will be received by your code. </p>
</blockquote>
<p>Note </p><blockquote class="doxtable">
<p >&zwj;We don't have gamepad support yet. </p>
</blockquote>
<p>Mouse movement is handled using <code>GameInstance::onMouseMove</code> function or <code>Node::onMouseMove</code> function. There are other mouse related functions like <code>onMouseScrollMove</code> that you might find useful.</p>
<h4><a class="anchor" id="autotoc_md37"></a>
Handling input event IDs</h4>
<p >In the next sections you will learn that you can bind to input events in game instance and in nodes. As it was said earlier input events use IDs to be distinguished. This means that you need to have an application-global collection of unique IDs for input events.</p>
<p >Prefer to describe input event IDs of your application in a separate file using enums, for example:</p>
<div class="fragment"><div class="line"><span class="comment">// GameInputEventIds.hpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>GameInputEventIds {</div>
<div class="line">    <span class="keyword">enum class</span> Action : <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> {</div>
<div class="line">        CAPTURE_MOUSE_CURSOR = 0, <span class="comment">//&lt; Capture mouse cursor.</span></div>
<div class="line">        INCREASE_CAMERA_SPEED,    <span class="comment">//&lt; Increase camera&#39;s speed.</span></div>
<div class="line">        DECREASE_CAMERA_SPEED,    <span class="comment">//&lt; Decrease camera&#39;s speed.</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">enum class</span> Axis : <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> {</div>
<div class="line">        MOVE_CAMERA_FORWARD = 0, <span class="comment">//&lt; Move camera forward/back.</span></div>
<div class="line">        MOVE_CAMERA_RIGHT,       <span class="comment">//&lt; Move camera right/left.</span></div>
<div class="line">        MOVE_CAMERA_UP,          <span class="comment">//&lt; Move camera up/down.</span></div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p >This file will store all input IDs that your game needs, even if you have switchable controls like "walking" or "in vehice" all input event IDs should be generally stored like that to make sure they all have unique IDs because all your input events will be registered in the same input manager.</p>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;We will talk about switchable controls like "walking" or "in vehice" and how to handle them in one of the next sections. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md38"></a>
Binding to input events in game instance</h4>
<p >Since input events are identified using unique IDs we should create a special struct for our input IDs:</p>
<div class="fragment"><div class="line"><span class="comment">// GameInputEventIds.hpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>GameInputEventIds {</div>
<div class="line">    <span class="keyword">enum class</span> Action : <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> {</div>
<div class="line">        ACTION_EVENT1 = 0,</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">enum class</span> Axis : <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> {</div>
<div class="line">        AXIS_EVENT1 = 0,</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p >Let's see how we can bind to input events in our <code>GameInstance</code> class.</p>
<div class="fragment"><div class="line"><span class="comment">// MyGameInstance.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;GameInputEventIds.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::MyGameInstance(</div>
<div class="line">    <a class="code hl_class" href="classne_1_1Window.html">Window</a>* pWindow, <a class="code hl_class" href="classne_1_1GameManager.html">GameManager</a>* pGameManager, <a class="code hl_class" href="classne_1_1InputManager.html">InputManager</a>* pInputManager)</div>
<div class="line">    : <a class="code hl_class" href="classne_1_1GameInstance.html">GameInstance</a>(pWindow, pGameManager, pInputManager) {</div>
<div class="line">    <span class="comment">// Register action event.</span></div>
<div class="line">    <span class="keyword">auto</span> optionalError = pInputManager-&gt;<a class="code hl_function" href="classne_1_1InputManager.html#a8c6376e3d7b39c34d71b685584d8c1d4">addActionEvent</a>(</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Action::ACTION_EVENT1),</div>
<div class="line">        {KeyboardKey::KEY_F});</div>
<div class="line">    <span class="keywordflow">if</span> (optionalError.has_value()) [[unlikely]] {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Register axis event.</span></div>
<div class="line">    optionalError = pInputManager-&gt;<a class="code hl_function" href="classne_1_1InputManager.html#a937f8a855ed96b1c17f34393e4314994">addAxisEvent</a>(</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Action::AXIS_EVENT1),</div>
<div class="line">        {{KeyboardKey::KEY_A, KeyboardKey::KEY_D}});</div>
<div class="line">    <span class="keywordflow">if</span> (optionalError.has_value()) [[unlikely]] {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now let&#39;s bind callback functions to our events.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind action events.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pActionEvents = getActionEventBindings();</div>
<div class="line">        std::scoped_lock guard(pActionEvents-&gt;first);</div>
<div class="line"> </div>
<div class="line">        pActionEvents-&gt;second[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Action::ACTION_EVENT1)]</div>
<div class="line">            = [](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">bool</span> bIsPressedDown) {</div>
<div class="line">            Logger::get().info(std::format(<span class="stringliteral">&quot;action event triggered, state: {}&quot;</span>, bIsPressedDown));</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind axis events.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pAxisEvents = getAxisEventBindings();</div>
<div class="line">        std::scoped_lock guard(pAxisEvents-&gt;first);</div>
<div class="line"> </div>
<div class="line">        pAxisEvents-&gt;second[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Action::AXIS_EVENT1)]</div>
<div class="line">            = [](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">float</span> input) {</div>
<div class="line">            Logger::get().info(std::format(<span class="stringliteral">&quot;axis event triggered, value: {}&quot;</span>, input));</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassne_1_1InputManager_html_a8c6376e3d7b39c34d71b685584d8c1d4"><div class="ttname"><a href="classne_1_1InputManager.html#a8c6376e3d7b39c34d71b685584d8c1d4">ne::InputManager::addActionEvent</a></div><div class="ttdeci">std::optional&lt; Error &gt; addActionEvent(unsigned int iActionId, const std::vector&lt; std::variant&lt; KeyboardKey, MouseButton &gt; &gt; &amp;vKeys)</div><div class="ttdef"><b>Definition:</b> InputManager.cpp:14</div></div>
<div class="ttc" id="aclassne_1_1InputManager_html_a937f8a855ed96b1c17f34393e4314994"><div class="ttname"><a href="classne_1_1InputManager.html#a937f8a855ed96b1c17f34393e4314994">ne::InputManager::addAxisEvent</a></div><div class="ttdeci">std::optional&lt; Error &gt; addAxisEvent(unsigned int iAxisEventId, const std::vector&lt; std::pair&lt; KeyboardKey, KeyboardKey &gt; &gt; &amp;vAxis)</div><div class="ttdef"><b>Definition:</b> InputManager.cpp:40</div></div>
<div class="ttc" id="aclassne_1_1KeyboardModifiers_html"><div class="ttname"><a href="classne_1_1KeyboardModifiers.html">ne::KeyboardModifiers</a></div><div class="ttdef"><b>Definition:</b> KeyboardKey.hpp:10</div></div>
</div><!-- fragment --><p >As you can see we are using game instance constructor and we don't create a separate function to "add" our input events. This is done intentionally because once input events were added you should not add the same input events again, thus no function - we don't want anybody to accidentally add input events again.</p>
<p >At this point you will be able to trigger registered action/axis events by pressing the specified keyboard buttons.</p>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;Although you can process input events in <code>GameInstance</code> it's not really recommended because input events should generally be processed in nodes such as in your character node so that your nodes will be self-contained and modular. </p>
</blockquote>
<p>Note </p><blockquote class="doxtable">
<p >&zwj;You can register/bind input events even when world does not exist or not created yet. </p>
</blockquote>
<p>Note </p><blockquote class="doxtable">
<p >&zwj;You can bind to input events before registering input events - this is perfectly fine. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md39"></a>
Binding to input events in nodes</h4>
<p >This is the most common use case for input events. The usual workflow goes like this:</p><ol type="1">
<li>Register action/axis events with some default keys in your <code>GameInstance</code> constructor.</li>
<li>Bind to input processing callbacks in your nodes.</li>
</ol>
<p >Let's define 2 axis events in our game instance: one for moving right/left and one for moving forward/backward:</p>
<div class="fragment"><div class="line"><span class="comment">// GameInputEventIds.hpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>GameInputEventIds {</div>
<div class="line">    <span class="keyword">enum class</span> Action : <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> {</div>
<div class="line">        CLOSE_APP = 0,</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">     <span class="keyword">enum class</span> Axis : <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> {</div>
<div class="line">        MOVE_RIGHT = 0,</div>
<div class="line">        MOVE_FORWARD,</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p >Now let's register and bind to those events:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;GameInputEventIds.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::MyGameInstance(</div>
<div class="line">    <a class="code hl_class" href="classne_1_1Window.html">Window</a>* pWindow, <a class="code hl_class" href="classne_1_1GameManager.html">GameManager</a>* pGameManager, <a class="code hl_class" href="classne_1_1InputManager.html">InputManager</a>* pInputManager)</div>
<div class="line">    : <a class="code hl_class" href="classne_1_1GameInstance.html">GameInstance</a>(pWindow, pGameManager, pInputManager) {</div>
<div class="line">    <span class="comment">// Register &quot;moveRight&quot; axis event.</span></div>
<div class="line">    <span class="keyword">auto</span> optionalError = pInputManager-&gt;<a class="code hl_function" href="classne_1_1InputManager.html#a937f8a855ed96b1c17f34393e4314994">addAxisEvent</a>(</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Axis::MOVE_RIGHT),</div>
<div class="line">        {{KeyboardKey::KEY_D, KeyboardKey::KEY_A}});</div>
<div class="line">    <span class="keywordflow">if</span> (optionalError.has_value()) [[unlikely]] {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register &quot;moveForward&quot; axis event.</span></div>
<div class="line">    optionalError = pInputManager-&gt;<a class="code hl_function" href="classne_1_1InputManager.html#a937f8a855ed96b1c17f34393e4314994">addAxisEvent</a>(</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Axis::MOVE_FORWARD),</div>
<div class="line">        {{KeyboardKey::KEY_W, KeyboardKey::KEY_S}});</div>
<div class="line">    <span class="keywordflow">if</span> (optionalError.has_value()) [[unlikely]] {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Register &quot;closeApp&quot; action event.</span></div>
<div class="line">    optionalError = pInputManager-&gt;<a class="code hl_function" href="classne_1_1InputManager.html#a8c6376e3d7b39c34d71b685584d8c1d4">addActionEvent</a>(</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Action::CLOSE_APP),</div>
<div class="line">        {KeyboardKey::KEY_ESCAPE});</div>
<div class="line">    <span class="keywordflow">if</span> (optionalError.has_value()) [[unlikely]] {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >In our node create 2 new private fields and one new function that we will use:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onBeforeNewFrame(<span class="keywordtype">float</span> timeSincePrevFrameInSec) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    glm::vec2 lastInputDirection = glm::vec2(0.0F, 0.0F);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> movementSpeed = 5.0F;</div>
</div><!-- fragment --><p >Now in our node's constructor let's bind to input events. We don't need to care about register/bind order because you can bind to input events before registering input events - this is perfectly fine.</p>
<div class="fragment"><div class="line"><span class="comment">// FlyingCharacter.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom.</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/node/CameraNode.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;GameInputEventIds.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;FlyingCharacter.generated_impl.h&quot;</span></div>
<div class="line"> </div>
<div class="line">FlyingCharacterNode::FlyingCharacterNode() : FlyingCharacterNode(<span class="stringliteral">&quot;Flying Character Node&quot;</span>) {}</div>
<div class="line"> </div>
<div class="line">FlyingCharacterNode::FlyingCharacterNode(<span class="keyword">const</span> std::string&amp; sNodeName) : <a class="code hl_class" href="classne_1_1SpatialNode.html">SpatialNode</a>(sNodeName) {</div>
<div class="line">    <span class="comment">// Create our camera node.</span></div>
<div class="line">    pCameraNode = sgc::makeGc&lt;CameraNode&gt;(<span class="stringliteral">&quot;Player Camera&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Attach the camera to the character.</span></div>
<div class="line">    addChildNode(pCameraNode, AttachmentRule::KEEP_RELATIVE, AttachmentRule::KEEP_RELATIVE);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make our node to receive user input. Input will be received only when the node is spawned.</span></div>
<div class="line">    setIsReceivingInput(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make our node to be called every frame so that we can apply input to movement.</span></div>
<div class="line">    <span class="comment">// Node will be called every frame only while it&#39;s spawned.</span></div>
<div class="line">    setIsCalledEveryFrame(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind to axis events.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pAxisEvents = getAxisEventBindings();</div>
<div class="line">        std::scoped_lock guard(pAxisEvents-&gt;first);</div>
<div class="line"> </div>
<div class="line">        pAxisEvents-&gt;second[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Axis::MOVE_FORWARD)]</div>
<div class="line">            = [<span class="keyword">this</span>](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">float</span> input) {</div>
<div class="line">            lastInputDirection.x = input;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        pAxisEvents-&gt;second[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Axis::MOVE_RIGHT)]</div>
<div class="line">            = [<span class="keyword">this</span>](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">float</span> input) {</div>
<div class="line">            lastInputDirection.y = input;</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> FlyingCharacterNode::onChildNodesSpawned() {</div>
<div class="line">    SpatialNode::onChildNodesSpawned();</div>
<div class="line"> </div>
<div class="line">    pCameraNode-&gt;makeActive();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> FlyingCharacterNode::onBeforeNewFrame(<span class="keywordtype">float</span> timeSincePrevFrameInSec) {</div>
<div class="line">    <span class="comment">// Check for early exit.</span></div>
<div class="line">    <span class="comment">// Also make sure input direction is not zero to avoid NaNs during `normalize` (see below).</span></div>
<div class="line">    <span class="keywordflow">if</span> (glm::all(glm::epsilonEqual(lastInputDirection, glm::vec2(0.0F, 0.0F), 0.0001F))) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Normalize direction to avoid speed up on diagonal movement and apply speed.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> movementDirection =</div>
<div class="line">        glm::normalize(lastInputDirection) * timeSincePrevFrameInSec * movementSpeed;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get node&#39;s world location.</span></div>
<div class="line">    <span class="keyword">auto</span> newWorldLocation = getWorldLocation();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Calculate new world location.</span></div>
<div class="line">    newWorldLocation += getWorldForwardDirection() * movementDirection.x;</div>
<div class="line">    newWorldLocation += getWorldRightDirection() * movementDirection.y;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Apply movement.</span></div>
<div class="line">    setWorldLocation(newWorldLocation);</div>
<div class="line">}</div>
</div><!-- fragment --><p >As you can see we have decided to apply input movement not instantly but once a frame. The motivation for this is that we now have <code>timeSincePrevFrameInSec</code> (also known as deltatime - time in seconds that has passed since the last frame was rendered) to eliminate a speed up that occurs on diagonal movement (length of the vector becomes ~1.41 on diagonal movement while we expect the length of the vector to be in the range [0.0; 1.0]).</p>
<p >In addition to this it may happen that a button is pressed/released multiple times during one frame (this is even more likely when use have a gamepad and use thumbsticks for movement) which will cause our input callbacks to be triggered multiple times during one frame, so if we process the movement instantly this might affect the performance. <b>Note that movement input is special because we can process it like that but it does not mean that all other input should be handled like this, for example an action to Fire/Shoot should be processed instantly or an action Open/Interact should also be processed instantly, in addition "look" or "rotation" mouse events should also be processed instantly.</b></p>
<p >Compile and run your project now, you can try modifying <code>movementSpeed</code> variable to fit your needs or even make it non-constant if you want.</p>
<p >Let's now make our character to look/rotate using mouse movement. Add a new protected function and a private field in your node:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onMouseMove(<span class="keywordtype">double</span> xOffset, <span class="keywordtype">double</span> yOffset) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">double</span> rotationSpeed = 0.1;</div>
</div><!-- fragment --><p >And implementation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FlyingCharacterNode::onMouseMove(<span class="keywordtype">double</span> xOffset, <span class="keywordtype">double</span> yOffset) {</div>
<div class="line">    <span class="keyword">auto</span> currentRotation = getRelativeRotation();</div>
<div class="line"> </div>
<div class="line">    currentRotation.z += <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(xOffset * rotationSpeed); <span class="comment">// modify &quot;yaw&quot;</span></div>
<div class="line">    currentRotation.y -= <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(yOffset * rotationSpeed); <span class="comment">// modify &quot;pitch&quot;</span></div>
<div class="line"> </div>
<div class="line">    setRelativeRotation(currentRotation);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Note </p><blockquote class="doxtable">
<p >&zwj;Make sure to use relative rotation and not world rotation. </p>
</blockquote>
<p>And let's hide the cursor.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FlyingCharacterNode::onChildNodesSpawned() {</div>
<div class="line">    SpatialNode::onChildNodesSpawned();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Hide (capture) mouse cursor.</span></div>
<div class="line">    getGameInstance()-&gt;getWindow()-&gt;setCursorVisibility(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Enable camera.</span></div>
<div class="line">    pCameraNode-&gt;makeActive();</div>
<div class="line">}</div>
</div><!-- fragment --><p >Compile and run. You should be able to rotate our character using mouse input.</p>
<p >As the final step let's finish by implementing "closeApp" action event, this one is very simple:</p>
<div class="fragment"><div class="line">FlyingCharacterNode::FlyingCharacterNode(<span class="keyword">const</span> std::string&amp; sNodeName) : <a class="code hl_class" href="classne_1_1SpatialNode.html">SpatialNode</a>(sNodeName) {</div>
<div class="line">    <span class="comment">// ... some code here ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind to axis events.</span></div>
<div class="line">    <span class="comment">// ... some code here ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind to action events.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pActionEvents = getActionEventBindings();</div>
<div class="line">        std::scoped_lock guard(pActionEvents-&gt;first);</div>
<div class="line"> </div>
<div class="line">        pActionEvents-&gt;second[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Action::CLOSE_APP)]</div>
<div class="line">            = [](<a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a> modifiers, <span class="keywordtype">bool</span> bIsPressed) {</div>
<div class="line">            getGameInstance()-&gt;getWindow()-&gt;close();</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >If you read the documentation for <code>Node::setIsReceivingInput</code> you would know that we can change whether we receive input or not while spawned. This can be handy if your game has (for example) a car that your character can drive, once your character enters a car you can use <code>PlayerNode::setIsReceivingInput(false)</code> and <code>CarNode::setIsReceivingInput(true)</code> and when the character leaves a car do the opposite <code>CarNode::setIsReceivingInput(false)</code> and <code>PlayerNode::setIsReceivingInput(true)</code>. Although if your character can still use some of his controls while driving a car you might want to implement some states like <code>bool bIsDrivingCar</code> and in some input callbacks in <code>PlayerNode</code> check this variable to decide whether an action should be executed or not.</p>
<p >This will be enough for now. Later we will talk about using <code>InputManager</code> in a slightly better way and also talk about saving/loading inputs.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Working with timers</h2>
<h3><a class="anchor" id="autotoc_md41"></a>
Timers and GameInstance</h3>
<p >Let's consider an example where you need to trigger some logic after some time in your <code>GameInstance</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted()<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Create a timer.</span></div>
<div class="line">    pTimer = createTimer(<span class="stringliteral">&quot;custom&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// (optional) Let&#39;s set timer to wait 1 second (1000 ms) before calling our callback.</span></div>
<div class="line">    pTimer-&gt;setCallbackForTimeout(1000, []() { </div>
<div class="line">        Logger::get().info(<span class="stringliteral">&quot;Hello from timer callback!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Timer was not set as `looping` so there is no need to explicitly stop it.</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start the timer.</span></div>
<div class="line">    pTimer-&gt;start();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... some code here ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let&#39;s see how much time has passed.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> iTimePassedInMs = pTimer-&gt;getElapsedTimeInMs();</div>
<div class="line">}</div>
</div><!-- fragment --><p >As the documentation for <code>Timer::setCallbackForTimeout</code> says your callback will be called on the main thread so can safely use all engine functions from it. Moreover, the engine does some additional work for you and guarantees that this callback will never be called on deleted <code>GameInstance</code> (see function documentation for more details).</p>
<p >We store a <code>Timer* pTimer = nullptr</code> in the header file of our game instance to reuse that timer. <b>There's currently no <code>removeTimer</code> function (and may even never be) so it might be a good idea to reuse your timers instead of creating new timers again and again.</b> Returned raw pointer <code>Timer*</code> is guaranteed to be valid while the game instance is valid.</p>
<p >Using timer callbacks in game instance is pretty safe and you generally shouldn't worry about anything. And as always if you have any questions you might look at the documentation of the timer class and at the timer tests at <code>src/engine_tests/game/GameInstance.cpp</code>.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
Timers and Node</h3>
<p >Same timer functions are used in nodes:</p>
<div class="fragment"><div class="line">MyDerivedNode() {</div>
<div class="line">    <span class="comment">// Create a timer in constructor to reuse it later.</span></div>
<div class="line">    pTimer = createTimer(<span class="stringliteral">&quot;custom&quot;</span>);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDerivedNode::onSpawning()<span class="keyword"> override</span>{</div>
<div class="line">    Node::onSpawning(); <span class="comment">// don&#39;t forget to call parent&#39;s version</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// (optional) Let&#39;s set timer to wait 1 second (1000 ms) before calling our callback.</span></div>
<div class="line">    pTimer-&gt;setCallbackForTimeout(1000, []() { </div>
<div class="line">        Logger::get().info(<span class="stringliteral">&quot;Hello from timer callback!&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Timer was not set as `looping` so there is no need to explicitly stop it.</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start the timer.</span></div>
<div class="line">    pTimer-&gt;start();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... some code here ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let&#39;s see how much time has passed.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> iTimePassedInMs = pTimer-&gt;getElapsedTimeInMs();</div>
<div class="line">}</div>
</div><!-- fragment --><p >Some things about timers in nodes:</p><ul>
<li>Timers in nodes can only be <code>Timer::start</code>ed while the node is spawned any attempt to start a timer while the node is despawned (or not spawned yet) will result in an error being logged.</li>
<li>Created timers will be automatically stopped before <code>Node::onDespawning</code>.</li>
<li>Timer's callback will only be called while the timer is running and your node is spawned. This means that when your timer's callback is started you know that the node is still spawned.</li>
<li>Timer's callback will be called on the main thread.</li>
</ul>
<p >Again, we store a <code>Timer* pTimer = nullptr</code> in the header file of our node to reuse that timer. <b>There's currently no <code>removeTimer</code> function (and may even never be) so it might be a good idea to reuse your timers instead of creating new timers again and again.</b> Returned raw pointer <code>Timer*</code> is guaranteed to be valid while the node is valid.</p>
<p >As with game instance using timer callbacks in nodes is pretty safe and you generally shouldn't worry about anything. And as always if you have any questions you might look at the documentation of the timer class and at the timer tests at <code>src/engine_tests/misc/Timer.cpp</code>.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Node callbacks (including asynchronous tasks)</h2>
<p >In your game you would most likelly want to use callbacks to trigger custom logic in nodes when some event happens, for example when your character's collision hits/overlaps with something you might want the collision node to notify the character node to do some custom logic.</p>
<p >When you think of callbacks you might think of <code>std::function</code> but the problem is that <code>std::function</code> has no guarantees if the node is spawned or not, or if it was deleted (freed). In order to avoid issues like that the engine provides <code>NodeFunction</code> - it's an <code>std::function</code> wrapper used for <code>Node</code> functions/lambdas with an additional check (compared to the usual <code>std::function</code>): once the callback is called <code>NodeFunction</code> will first safely check if the node, the callback function points to, is still spawned or not, and if not spawned then the callback function will not be called to avoid running functions on despawned nodes or hitting deleted memory.</p>
<p >That "safely check" means that the engine does not use your node for the check because the node might be deleted and calling any functions on it might lead to undefined behaviour.</p>
<p >So when you need callbacks for triggering custom logic in <code>Node</code>s it's highly recommended to use the <code>NodeFunction</code> instead of the <code>std::function</code>.</p>
<p >Additionally, when you use asynchronous requests (for example when you make asynchronous requests to remote backend server) for triggering some <code>Node</code> callbacks to process asynchronous results you should also use <code>NodeFunction</code>. This would protect you from running into despawned/deleted nodes if the asynchronous result was received unexpectedly late (for example) so you don't need to check if the node is still valid or not. Your code then will look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Inside of some `Node`:</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// note that `Node::getNodeId()` below will return empty if the node is not spawned and</span></div>
<div class="line"><span class="comment">// we use `.value()` directly just to simplify our example</span></div>
<div class="line"><span class="keyword">auto</span> onFinished = <a class="code hl_class" href="classne_1_1NodeFunction.html">NodeFunction&lt;void(bool, int)&gt;</a>(getNodeId().value(), [<span class="keyword">this</span>](<span class="keywordtype">bool</span> bSomeParameter, <span class="keywordtype">int</span> iSomeParameter){</div>
<div class="line">    <span class="comment">// Asynchronous call was finished successfully and `this` node is still spawned.</span></div>
<div class="line">    <span class="comment">// Do some logic here.</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">SomeSystem-&gt;DoAsynchronousQuery(</div>
<div class="line">    someData,</div>
<div class="line">    [onFinished](<span class="keywordtype">bool</span> bSomeParameter, <span class="keywordtype">int</span> iSomeParameter){</div>
<div class="line">        onFinished(bSomeParameter, iSomeParameter); <span class="comment">// won&#39;t call the callback if the node is despawned or deleted</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclassne_1_1NodeFunction_html"><div class="ttname"><a href="classne_1_1NodeFunction.html">ne::NodeFunction</a></div><div class="ttdef"><b>Definition:</b> NodeFunction.hpp:11</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md44"></a>
Safely using the publisher-subscriber pattern with nodes</h2>
<p >Every game has custom game events, in this engine some nodes can subscribe to a specific publisher object, this way subscriber nodes can be notified when a specific event happens. For example, if your character node wants to know when its collision hits something we can use the publisher-subscriber pattern. When the publisher object decides that the event has happend it notifies all subscriber nodes and calls <code>NodeFunction</code> callbacks of all subscribed nodes.</p>
<p >In the engine the publisher-subscriber pattern is implemented by the <code>NodeNotificationBroadcaster</code> class. <code>Node</code> class already has a built-in functionality to use these broadcasters. You can use <code>Node::createNotificationBroadcaster</code> to create such broadcasters, allow other nodes to subscribe by specifying their <code>NodeFunction</code> callbacks and notify subscribers by calling the <code>broadcast</code> method. Here is a simplified example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyNode : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1Node.html">Node</a>{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyNode(){</div>
<div class="line">        <span class="comment">// Create broadcaster.</span></div>
<div class="line">        pEventBroadcaster = createNotificationBroadcaster&lt;void(bool, int)&gt;();</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> ~MyNode() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Allow other nodes to subscribe to the event.</span></div>
<div class="line">    <span class="comment">// Return a unique binding ID if other node wants to unsubscribe later.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> subscribeToEvent(<span class="keyword">const</span> <a class="code hl_class" href="classne_1_1NodeFunction.html">NodeFunction</a>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">bool</span>, <span class="keywordtype">int</span>)&gt;&amp; callback){</div>
<div class="line">        <span class="keywordflow">return</span> pEventBroadcaster-&gt;subscribe(callback);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Allow other nodes to unsubscribe from the event.</span></div>
<div class="line">    <span class="keywordtype">void</span> unsubscribeFromEvent(<span class="keywordtype">size_t</span> iBindingId){</div>
<div class="line">        pEventBroadcaster-&gt;unsubscribe(iBindingId);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> onAfterSomeGameEvent(<span class="keywordtype">bool</span> bSomeParameter, <span class="keywordtype">int</span> iSomeParameter){</div>
<div class="line">        <span class="comment">// Notify subscribers (queues a deferred task in which calls all subscribed callbacks).</span></div>
<div class="line">        pEventBroadcaster-&gt;broadcast(bSomeParameter, iSomeParameter);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classne_1_1NodeNotificationBroadcaster.html">NodeNotificationBroadcaster</a>&lt;void(<span class="keywordtype">bool</span>, <span class="keywordtype">int</span>)&gt;* pEventBroadcaster = <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// inside of some other spawned (!) node (otherwise `getNodeId()` returns empty):</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> iBindingId = pPublisherNode-&gt;subscribeToEvent(</div>
<div class="line">    <a class="code hl_class" href="classne_1_1NodeFunction.html">NodeFunction</a>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">bool</span>, <span class="keywordtype">int</span>)&gt;(getNodeId().value(), [<span class="keyword">this</span>](<span class="keywordtype">bool</span> bSomeParameter, <span class="keywordtype">int</span> iSomeParameter){</div>
<div class="line">    <span class="comment">// event occurred</span></div>
<div class="line">}));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... later (if we need to) ...</span></div>
<div class="line"> </div>
<div class="line">pPublisherNode-&gt;unsubscribeFromEvent(iBindingId);</div>
<div class="ttc" id="aclassne_1_1NodeNotificationBroadcaster_html"><div class="ttname"><a href="classne_1_1NodeNotificationBroadcaster.html">ne::NodeNotificationBroadcaster</a></div><div class="ttdef"><b>Definition:</b> NodeNotificationBroadcaster.hpp:45</div></div>
<div class="ttc" id="aclassne_1_1Node_html"><div class="ttname"><a href="classne_1_1Node.html">ne::Node</a></div><div class="ttdef"><b>Definition:</b> Node.h:39</div></div>
</div><!-- fragment --><p >Note that you don't need to unsubscribe when your subscribed node is being despawned/destroyed as this is done automatically. Each <code>broadcast</code> call removes callbacks of despawned nodes.</p>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;Because <code>broadcast</code> call simply loops over all registered callbacks extra care should be taken when you subscribe to pair events such as "on started overlapping" / "on finished overlapping" because the order of these events may be incorrect in some special situations. When subscribing to such "pair" events it's recommended to add checks in the beginning of your callbacks that make sure the order is correct (as expected), otherwise show an error message so that you will instantly notice that and fix it. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md45"></a>
Saving and loading user's input settings</h2>
<p ><code>InputManager</code> allows creating input events and axis events, i.e. allows binding names with multiple input keys. When working with input the workflow for creating, modifying, saving and loading inputs goes like this:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted(){</div>
<div class="line">    <span class="comment">// On each game start, create action/axis events with default keys.</span></div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::pair&lt;KeyboardKey, KeyboardKey&gt;&gt; vMoveForwardKeys = {</div>
<div class="line">        std::make_pair&lt;KeyboardKey, KeyboardKey&gt;(KeyboardKey::KEY_W, KeyboardKey::KEY_S),</div>
<div class="line">        std::make_pair&lt;KeyboardKey, KeyboardKey&gt;(KeyboardKey::KEY_UP, KeyboardKey::KEY_DOWN)</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> optionalError = getInputManager()-&gt;addAxisEvent(</div>
<div class="line">        <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Axis::MOVE_FORWARD),</div>
<div class="line">        vMoveForwardKeys);</div>
<div class="line">    <span class="keywordflow">if</span> (optionalError.has_value()){</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... add more default events here ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// After we defined all input events with default keys:</span></div>
<div class="line">    <span class="comment">// Load modifications that the user previously saved (if exists).</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> pInputFilename = <span class="stringliteral">&quot;input&quot;</span>; <span class="comment">// filename &quot;input&quot; is just an example, you can use other filename</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pathToFile</div>
<div class="line">        = ConfigManager::getCategoryDirectory(ConfigCategory::SETTINGS) / pInputFilename</div>
<div class="line">            + ConfigManager::getConfigFormatExtension();</div>
<div class="line">    <span class="keywordflow">if</span> (std::filesystem::exists(pathToFile)){</div>
<div class="line">        optionalError = getInputManager()-&gt;loadFromFile(pInputFilename);</div>
<div class="line">        <span class="keywordflow">if</span> (optionalError.has_value()){</div>
<div class="line">            <span class="comment">// ... handle error ...</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Finished.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later, the user modifies some keys:</span></div>
<div class="line">optionalError = getInputManager()-&gt;modifyAxisEventKey(</div>
<div class="line">    <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(GameInputEventIds::Axis::MOVE_FORWARD),</div>
<div class="line">    oldKey,</div>
<div class="line">    newKey);</div>
<div class="line"><span class="keywordflow">if</span> (optionalError.has_value()){</div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The key is now modified in the memory (in the input manager) but if we restart our game the modified key will</span></div>
<div class="line"><span class="comment">// be the same (non-modified), in order to fix this:</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// After a key is modified we save the modified inputs to the disk to load modified inputs on the next game start.</span></div>
<div class="line">optionalError = getInputManager()-&gt;saveToFile(pInputFilename);</div>
<div class="line"><span class="keywordflow">if</span> (optionalError.has_value()){</div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >As it was shown <code>InputManager</code> can be acquired using <code>GameInstance::getInputManager()</code>, so both game instance and nodes (using <code>getGameInstance()-&gt;getInputManager()</code>) can work with the input manager.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Configuring graphics settings</h2>
<p >Graphics settings are configured using the <code>RenderSettings</code> class. In order to get render settings from a game instance you need to use the following approach:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyGameInstance::foo(){</div>
<div class="line">    <span class="comment">// Get renderer.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pRenderer = getWindow()-&gt;getRenderer();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get render settings.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> mtxRenderSettings = pRenderer-&gt;getRenderSettings();</div>
<div class="line">    std::scoped_lock guard(*mtxRenderSettings.first);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get supported render resolutions.</span></div>
<div class="line">    <span class="keyword">auto</span> result = pRenderer-&gt;getSupportedRenderResolutions();</div>
<div class="line">    <span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(result)){</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> supportedRenderResolutions = std::get&lt;...&gt;(std::move(result));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... display `supportedRenderResolutions` on screen ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Later, when user wants to change render resolution:</span></div>
<div class="line">    mtxRenderSettings.second-&gt;setRenderResolution(someRenderResolution);</div>
<div class="line">}</div>
</div><!-- fragment --><p >When use change something in <code>RenderSettings</code> (for example render resolution) that change is instantly saved on the disk in the renderer config so you don't need to save them manually, on the next startup last applied settings will be restored.</p>
<p >You can find renderer's config file at:</p><ul>
<li>(on Windows) <code>%localappdata%/nameless-engine/*yourtarget*/engine/render.toml</code></li>
<li>(on Linux) <code>~/.config/nameless-engine/*yourtarget*/engine/render.toml</code></li>
</ul>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;You can change values in the specified config files to quicky change settings for testing purposes. Note that changes made in the config files will only be applied locally (only for your computer). </p>
</blockquote>
<p>Note that some render settings might not be supported depending on the OS/renderer/hardware. Let's consider another example, this one uses anti-aliasing:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyGameInstance::foo(){</div>
<div class="line">    <span class="comment">// Get renderer.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pRenderer = getWindow()-&gt;getRenderer();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get render settings.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> mtxRenderSettings = pRenderer-&gt;getRenderSettings();</div>
<div class="line">    std::scoped_lock guard(*mtxRenderSettings.first);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get maximum supported AA quality.</span></div>
<div class="line">    <span class="keyword">auto</span> result = mtxRenderSettings.second-&gt;getMaxSupportedAntialiasingQuality();</div>
<div class="line">    <span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(result)){</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> maxQuality = std::get&lt;std::optional&lt;AntialiasingQuality&gt;&gt;(result); <span class="comment">// empty if AA is not supported</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... display all `AntialiasingQuality` values on the screen but don&#39;t exceed `maxQuality` ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Later, when user wants to change AA:</span></div>
<div class="line">    mtxRenderSettings.second-&gt;setAntialiasingQuality(selectedQuality);</div>
<div class="line">}</div>
</div><!-- fragment --><p >As always if you forget something or pass unsupported value the engine will let you know by logging an error so pay attention to the logs/console.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Saving and loading user's progress data</h2>
<h3><a class="anchor" id="autotoc_md48"></a>
Overview</h3>
<p >There are 2 ways to save/load custom data:</p><ul>
<li>using <code>ConfigManager</code> (<code><a class="el" href="ConfigManager_8h_source.html">io/ConfigManager.h</a></code>) - this approach is generally used when you have just 1-2 simple variables that you want to save or when you don't want to / can't create a type and use reflection</li>
<li>using reflection - this approach is generally used more often than <code>ConfigManager</code> and it provides great flexibility</li>
</ul>
<p >Let's start with the most commonly used approach.</p>
<h3><a class="anchor" id="autotoc_md49"></a>
Saving and loading data using reflection</h3>
<h4><a class="anchor" id="autotoc_md50"></a>
Overview</h4>
<p >One of the previous sections of the manual taught you how to use reflection for your types so at this point you should know how to add reflection to your type. Now we will talk about additional steps that you need to do in order to use serialization/deserialization. As you might guess we will use some C++ types (that store some user data) and serialize them to file.</p>
<p >Reflection serialization uses <code>TOML</code> file format so if you don't know how this format looks like you can search it right now on the Internet. <code>TOML</code> format generally looks like <code>INI</code> format but with more features.</p>
<p >Let's consider an example that shows various serialization features and then explain some details:</p>
<div class="fragment"><div class="line"><span class="comment">// PlayerSaveData.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;PlayerSaveData.generated_impl.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// PlayerSaveData.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;io/Serializable.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;PlayerSaveData.generated.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;a34a8047-d7b4-4c70-bb9a-429875a8cd26&quot;</span>)) InventorySaveData : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1Serializable.html">Serializable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    InventorySaveData() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> ~InventorySaveData() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> addOneItem(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> iItemId) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> it = items.find(iItemId);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (it == items.end()) {</div>
<div class="line">            items[iItemId] = 1;</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        it-&gt;second += 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> removeOneItem(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> iItemId) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> it = items.find(iItemId);</div>
<div class="line">        <span class="keywordflow">if</span> (it == items.end())</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (it-&gt;second &lt;= 1) {</div>
<div class="line">            items.erase(it);</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        it-&gt;second -= 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> getItemAmount(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> iItemId) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> it = items.find(iItemId);</div>
<div class="line">        <span class="keywordflow">if</span> (it == items.end())</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    std::unordered_map&lt;unsigned long long, unsigned long long&gt; items;</div>
<div class="line"> </div>
<div class="line">    InventorySaveData_GENERATED</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;36063853-79b1-41e6-afa6-6923c8b24811&quot;</span>)) Ability : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1Serializable.html">Serializable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Ability() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> ~Ability() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    Ability(<span class="keyword">const</span> std::string&amp; sAbilityName) { this-&gt;sAbilityName = sAbilityName; }</div>
<div class="line"> </div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    std::string sAbilityName;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... maybe some other code/fields here ...</span></div>
<div class="line"> </div>
<div class="line">    Ability_GENERATED</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;36063853-79b1-41e6-afa6-6923c8b24815&quot;</span>)) PlayerSaveData : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1Serializable.html">Serializable</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PlayerSaveData() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> ~PlayerSaveData() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    std::string sCharacterName;</div>
<div class="line"> </div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> iCharacterLevel = 0;</div>
<div class="line"> </div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> iExperiencePoints = 0;</div>
<div class="line"> </div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    InventorySaveData inventory;</div>
<div class="line"> </div>
<div class="line">    RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;Ability&gt;&gt; vAbilities;</div>
<div class="line"> </div>
<div class="line">    PlayerSaveData_GENERATED</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">File_PlayerSaveData_GENERATED</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ---------------------------------------</span></div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Somewhere in the game code.</span></div>
<div class="line">    std::unique_ptr&lt;PlayerSaveData&gt; pPlayerSaveData = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... if the user creates a new player profile ...</span></div>
<div class="line">    pPlayerSaveData = std::make_unique&lt;PlayerSaveData&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Fill save data with some information.</span></div>
<div class="line">    pPlayerSaveData-&gt;sCharacterName = <span class="stringliteral">&quot;Player 1&quot;</span>;</div>
<div class="line">    pPlayerSaveData-&gt;iCharacterLevel = 42;</div>
<div class="line">    pPlayerSaveData-&gt;iExperiencePoints = 200;</div>
<div class="line">    pPlayerSaveData-&gt;vAbilities = {std::make_unique&lt;Ability&gt;(<span class="stringliteral">&quot;Fire&quot;</span>), std::make_unique&lt;Ability&gt;(<span class="stringliteral">&quot;Wind&quot;</span>)};</div>
<div class="line">    pPlayerSaveData-&gt;inventory.addOneItem(42);</div>
<div class="line">    pPlayerSaveData-&gt;inventory.addOneItem(42); <span class="comment">// now have two items with ID &quot;42&quot;</span></div>
<div class="line">    pPlayerSaveData-&gt;inventory.addOneItem(102);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Prepare a new unique file name for the new save file.</span></div>
<div class="line">    <span class="keyword">const</span> std::string sNewProfileName = ConfigManager::getFreeProgressProfileName();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Serialize.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pathToFile = ConfigManager::getCategoryDirectory(ConfigCategory::PROGRESS) / sNewProfileName;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> optionalError = pPlayerSaveData-&gt;serialize(pathToFile, <span class="keyword">true</span>); <span class="comment">// `true` to enable backup file</span></div>
<div class="line">    <span class="keywordflow">if</span> (optionalError.has_value()) [[unlikely]] {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... when the game is started next time ...</span></div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Get all save files.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vProfiles = ConfigManager::getAllFileNames(ConfigCategory::PROGRESS);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... say the user picks the first profile ...</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> sProfileName = vProfiles[0];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Deserialize.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pathToFile = ConfigManager::getCategoryDirectory(ConfigCategory::PROGRESS) / sProfileName;</div>
<div class="line">    <span class="keyword">auto</span> result = Serializable::deserialize&lt;std::unique_ptr&lt;PlayerSaveData&gt;&gt;(pathToFile);</div>
<div class="line">    <span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(result)) [[unlikely]] {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pPlayerSaveData = std::get&lt;std::unique_ptr&lt;PlayerSaveData&gt;&gt;(std::move(result));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Everything is deserialized:</span></div>
<div class="line">    assert(pPlayerSaveData-&gt;sCharacterName == <span class="stringliteral">&quot;Player 1&quot;</span>);</div>
<div class="line">    assert(pPlayerSaveData-&gt;iCharacterLevel == 42);</div>
<div class="line">    assert(pPlayerSaveData-&gt;iExperiencePoints == 200);</div>
<div class="line">    assert(pPlayerSaveData-&gt;vAbilities.size() == 2);</div>
<div class="line">    assert(pPlayerSaveData-&gt;vAbilities[0]-&gt;sAbilityName == <span class="stringliteral">&quot;Fire&quot;</span>);</div>
<div class="line">    assert(pPlayerSaveData-&gt;vAbilities[1]-&gt;sAbilityName == <span class="stringliteral">&quot;Wind&quot;</span>);</div>
<div class="line">    assert(pPlayerSaveData-&gt;inventory.getItemAmount(42) == 2);</div>
<div class="line">    assert(pPlayerSaveData-&gt;inventory.getItemAmount(102) == 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Let's now describe what needs to be do in order to use serialization and deserialization in your reflected type:</p><ol type="1">
<li>Derive from <code>Serializable</code> (<code><a class="el" href="Serializable_8h_source.html">io/Serializable.h</a></code>) in order to have <code>serialize</code>/<code>deserialize</code> and similar functions. Note that base <code>Node</code> class already derives from <code>Serializable</code> so you might already derive from this class.</li>
<li>Make sure your type has a constructor without parameters (make sure that it's not deleted) as it's required for deserialization. Use can override <code>Serializable::onAfterDeserialized</code> to do post-deserialization logic (just make sure to read this function's docs first).</li>
<li>Don't forget to override destructor, for example: <code>virtual ~T() override = default;</code>.</li>
</ol>
<ol type="1">
<li>Add <code>Guid</code> property to your type's <code>RCLASS</code>/<code>RSTRUCT</code> macro with a random GUID (just search something like "generate GUID" on the Internet), this GUID will be saved in the file so that when the engine reads the file it will know what type to use. In debug builds when the engine starts it checks uniqueness of all GUIDs so you shouldn't care about GUID uniqueness.</li>
</ol>
<ol type="1">
<li>Mark fields that you want to be serialized/deserialized with <code>Serialize</code> property on <code>RPROPERTY</code> macro.</li>
<li>Make sure that all fields marked with <code>RPROPERTY(Serialize)</code> that have primitive types have initialization values, for example: <code>long long iCharacterLevel = 0;</code> otherwise you might serialize a "garbage value" (since primitive types don't have initialization unlike <code>std::string</code> for example) and then after deserialization be suprised to see a character of level <code>-123215315115</code> or something like that.</li>
</ol>
<p >And here are some notes about serialization/deserialization:</p><ul>
<li>If you released your game and in some update you added a new <code>Serialize</code> field then everything (saving/loading) will work fine, the new field just needs to have initialization value for old save files that don't have this value (again, if it's a primitive type just initialize it otherwise you are fine).</li>
<li>If you released your game and in some update you removed/renamed some <code>Serialize</code> field then everything (saving/loading) will work fine and if some old save file will have that old removed/renamed field it will be ignored.</li>
<li>If you released your game it's highly recommended to not change your type's GUID otherwise the engine will not be able to deserialize the data since it will no longer know what type to use.</li>
</ul>
<p >If you look in the file <code><a class="el" href="SerializeProperty_8h_source.html">src/engine_lib/public/io/properties/SerializeProperty.h</a></code> you might find that <code>Serialize</code> has a constructor that accepts <code>FieldSerializationType</code> which is <code>FST_WITH_OWNER</code> by default and as the documentation says it means that "Field is serialized in the same file as the owner object". There is also an option to use <code>FST_AS_EXTERNAL_FILE</code> or <code>FST_AS_EXTERNAL_BINARY_FILE</code> like so:</p>
<div class="fragment"><div class="line">RPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>(FST_AS_EXTERNAL_BINARY_FILE)) <span class="comment">// allow VCSs to treat this file in a special way</span></div>
<div class="line"><a class="code hl_class" href="classne_1_1MeshData.html">MeshData</a> meshData;</div>
<div class="ttc" id="aclassne_1_1MeshData_html"><div class="ttname"><a href="classne_1_1MeshData.html">ne::MeshData</a></div><div class="ttdef"><b>Definition:</b> MeshData.h:93</div></div>
</div><!-- fragment --><p >And again, as the documentation says it means that "Field is serialized in a separate file located next to the file of owner object. The only difference between these two is that `FST_AS_EXTERNAL_FILE` serializes into a `TOML` file and `FST_AS_EXTERNAL_BINARY_FILE` serializes into a binary file using special binary field serilaizers. Some fields from engine types are stored as external binary files in order to provide smaller file size and faster deserialization (although sacrificing readability of the file). Only fields of types that derive from `Serializable` can be marked with this type". Generally we use the default <code>FST_WITH_OWNER</code> but there might be situations where you might want to use additional options.</p>
<p >There are various types that you can mark as <code>Serialize</code> as you can see you can mark some primitive types, <code>std::string</code>, <code>std::vector</code>, <code>std::unordered_map</code> and more, but note that when we talk about containers (such as <code>std::vector</code>) their serialization depends on the contained type. Here is a small description of <b>some types</b> that you can use for serialization:</p><ul>
<li><code>bool</code></li>
<li><code>int</code></li>
<li><code>unsigned int</code></li>
<li><code>long long</code></li>
<li><code>unsigned long long</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>std::string</code></li>
<li><code>T</code> (where <code>T</code> is any type that derives from Serializable)</li>
<li>and more!</li>
</ul>
<p >See the directory <code>src/engine_lib/public/io/serializers</code> for available field serializers (you don't need to use them directly, they will be automatically picked when you use <code>serialize</code> function).</p>
<p >If you can't find some desired type in available field serializers don't worry, you can write your own field serializer (it's not that hard) to support new field types to be serialized/deserialized but we will talk about this later in one of the next sections.</p>
<p >As it was previously said our reflection serialization system uses <code>TOML</code> file format so if you need even more flexibility you can serialize <code>toml::value</code> structures directly. Under the hood we use <a href="https://github.com/ToruNiina/toml11">https://github.com/ToruNiina/toml11</a> for working with <code>TOML</code> files so if you want to serialize something very complicated in a very special way you can read the documentation for this library and serialize <code>toml::value</code>s yourself or use a combination of raw <code>toml::value</code>s and our serialization system by using various overloads of <code>Serializable::serialize</code> that use <code>toml::value</code>.</p>
<p >In the end let's consider one more (this time very simplified) example where we serialize multiple objects into one file:</p>
<div class="fragment"><div class="line"><span class="comment">// Serialize 2 objects in 1 file.</span></div>
<div class="line"><a class="code hl_class" href="classne_1_1Node.html">Node</a> node1(<span class="stringliteral">&quot;My Cool Node 1&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classne_1_1Node.html">Node</a> node2(<span class="stringliteral">&quot;My Cool Node 2&quot;</span>);</div>
<div class="line"><a class="code hl_struct" href="structne_1_1SerializableObjectInformation.html">SerializableObjectInformation</a> node1Info(&amp;node1, <span class="stringliteral">&quot;0&quot;</span>, {{sNode1CustomAttributeName, <span class="stringliteral">&quot;1&quot;</span>}}); <span class="comment">// will have ID 0</span></div>
<div class="line"><a class="code hl_struct" href="structne_1_1SerializableObjectInformation.html">SerializableObjectInformation</a> node2Info(&amp;node2, <span class="stringliteral">&quot;1&quot;</span>, {{sNode2CustomAttributeName, <span class="stringliteral">&quot;2&quot;</span>}}); <span class="comment">// will have ID 1</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> optionalError = Serializable::serializeMultiple(pathToFile, {node1Info, node2Info}, <span class="keyword">false</span>);</div>
<div class="line"><span class="keywordflow">if</span> (optionalError.has_value()) {</div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deserialize.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> result = Serializable::deserializeMultiple&lt;sgc::GcPtr&lt;Serializable&gt;&gt;(pathToFile);</div>
<div class="line"><span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(result)) {</div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> vDeserializedObjects</div>
<div class="line">    = std::get&lt;std::vector&lt;DeserializedObjectInformation&lt;sgc::GcPtr&lt;Serializable&gt;&gt;&gt;&gt;(std::move(result));</div>
<div class="ttc" id="astructne_1_1SerializableObjectInformation_html"><div class="ttname"><a href="structne_1_1SerializableObjectInformation.html">ne::SerializableObjectInformation</a></div><div class="ttdef"><b>Definition:</b> Serializable.h:31</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md51"></a>
Reflection limitations</h4>
<p >Currently used version of the reflection library has some issues with multiple inheritance. If you are deriving from two classes one of which is <code>Serializable</code> (or a class/struct that derives from it) and the other is not an interface class (contains fields) then you might want to derive from <code>Serializable</code> first and then from that non-interface class. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IMyInterface{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> bar() = 0;</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo2() = 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyParentClass{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> myFoo();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">int</span> iAnswer = 42;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// might fail when attempting to get reflected fields&#39; values (will just read garbage)</span></div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;...&quot;</span>)) MyClass : <span class="keyword">public</span> MyParentClass, <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1Serializable.html">Serializable</a>{ </div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// should work fine</span></div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;...&quot;</span>)) MyClass : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1Serializable.html">Serializable</a>, <span class="keyword">public</span> IMyInterface{</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// should work fine</span></div>
<div class="line"><span class="keyword">class </span>RCLASS(<a class="code hl_class" href="classne_1_1Guid.html">Guid</a>(<span class="stringliteral">&quot;...&quot;</span>)) MyClass : <span class="keyword">public</span> <a class="code hl_class" href="classne_1_1Serializable.html">Serializable</a>, <span class="keyword">public</span> MyParentClass{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p >Just keep this in mind when using reflection for serialization/deserialization.</p>
<h3><a class="anchor" id="autotoc_md52"></a>
Saving and loading data using ConfigManager</h3>
<p ><code>ConfigManager</code> (just like reflection serialization) uses <code>TOML</code> file format so if you don't know how this format looks like you can search it right now on the Internet. <code>TOML</code> format generally looks like <code>INI</code> format but with more features.</p>
<p >Here is an example of how you can save and load data using <code>ConfigManager</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;io/ConfigManager.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write some data.</span></div>
<div class="line"><a class="code hl_class" href="classne_1_1ConfigManager.html">ConfigManager</a> manager;</div>
<div class="line">manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#a96cb16396d2789a15ef1e0bec6c8c144">setValue</a>&lt;std::string&gt;(<span class="stringliteral">&quot;section name&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, <span class="stringliteral">&quot;optional comment&quot;</span>);</div>
<div class="line">manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#a96cb16396d2789a15ef1e0bec6c8c144">setValue</a>&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;section name&quot;</span>, <span class="stringliteral">&quot;my bool&quot;</span>, <span class="keyword">true</span>, <span class="stringliteral">&quot;this should be true&quot;</span>);</div>
<div class="line">manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#a96cb16396d2789a15ef1e0bec6c8c144">setValue</a>&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;section name&quot;</span>, <span class="stringliteral">&quot;my double&quot;</span>, 3.14159, <span class="stringliteral">&quot;this is a pi value&quot;</span>);</div>
<div class="line">manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#a96cb16396d2789a15ef1e0bec6c8c144">setValue</a>&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;section name&quot;</span>, <span class="stringliteral">&quot;my long&quot;</span>, 42); <span class="comment">// notice no comment here</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Save to file.</span></div>
<div class="line"><span class="keyword">auto</span> optionalError = manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#aafc4701dd102d93a0f23d277821600c0">saveFile</a>(ConfigCategory::SETTINGS, <span class="stringliteral">&quot;my file&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (optionalError.has_value()) {</div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// -----------------------------------------</span></div>
<div class="line"><span class="comment">// Let&#39;s say that somewhere in other place of your game you want to read these values:</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classne_1_1ConfigManager.html">ConfigManager</a> manager;</div>
<div class="line"><span class="keyword">auto</span> optionalError = manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#a27345612b4ee53e154f32e951b219438">loadFile</a>(ConfigCategory::SETTINGS, <span class="stringliteral">&quot;my file&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (optionalError.has_value()) {</div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read string.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> realString = manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#ac355a5fa94ada2919d3e75a5246a94d2">getValue</a>&lt;std::string&gt;(<span class="stringliteral">&quot;section name&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>, <span class="stringliteral">&quot;default value&quot;</span>);</div>
<div class="line">assert(realString == <span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read bool.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> realBool = manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#ac355a5fa94ada2919d3e75a5246a94d2">getValue</a>&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;section name&quot;</span>, <span class="stringliteral">&quot;my bool&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line">assert(realBool == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> realDouble = manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#ac355a5fa94ada2919d3e75a5246a94d2">getValue</a>&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;section name&quot;</span>, <span class="stringliteral">&quot;my double&quot;</span>, 0.0);</div>
<div class="line">assert(realDouble &gt;= 3.13);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> realLong = manager.<a class="code hl_function" href="classne_1_1ConfigManager.html#ac355a5fa94ada2919d3e75a5246a94d2">getValue</a>&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;section name&quot;</span>, <span class="stringliteral">&quot;my long&quot;</span>, 0);</div>
<div class="line">assert(realLong == 42);</div>
<div class="ttc" id="aclassne_1_1ConfigManager_html"><div class="ttname"><a href="classne_1_1ConfigManager.html">ne::ConfigManager</a></div><div class="ttdef"><b>Definition:</b> ConfigManager.h:27</div></div>
<div class="ttc" id="aclassne_1_1ConfigManager_html_a27345612b4ee53e154f32e951b219438"><div class="ttname"><a href="classne_1_1ConfigManager.html#a27345612b4ee53e154f32e951b219438">ne::ConfigManager::loadFile</a></div><div class="ttdeci">std::optional&lt; Error &gt; loadFile(ConfigCategory category, std::string_view sFileName)</div><div class="ttdef"><b>Definition:</b> ConfigManager.cpp:116</div></div>
<div class="ttc" id="aclassne_1_1ConfigManager_html_a96cb16396d2789a15ef1e0bec6c8c144"><div class="ttname"><a href="classne_1_1ConfigManager.html#a96cb16396d2789a15ef1e0bec6c8c144">ne::ConfigManager::setValue</a></div><div class="ttdeci">void setValue(std::string_view sSection, std::string_view sKey, T value, std::string_view sComment=&quot;&quot;)</div><div class="ttdef"><b>Definition:</b> ConfigManager.h:378</div></div>
<div class="ttc" id="aclassne_1_1ConfigManager_html_aafc4701dd102d93a0f23d277821600c0"><div class="ttname"><a href="classne_1_1ConfigManager.html#aafc4701dd102d93a0f23d277821600c0">ne::ConfigManager::saveFile</a></div><div class="ttdeci">std::optional&lt; Error &gt; saveFile(ConfigCategory category, std::string_view sFileName)</div><div class="ttdef"><b>Definition:</b> ConfigManager.cpp:199</div></div>
<div class="ttc" id="aclassne_1_1ConfigManager_html_ac355a5fa94ada2919d3e75a5246a94d2"><div class="ttname"><a href="classne_1_1ConfigManager.html#ac355a5fa94ada2919d3e75a5246a94d2">ne::ConfigManager::getValue</a></div><div class="ttdeci">T getValue(std::string_view sSection, std::string_view sKey, T defaultValue) const</div><div class="ttdef"><b>Definition:</b> ConfigManager.h:369</div></div>
</div><!-- fragment --><p >As you can see <code>ConfigManager</code> is a very simple system for very simple tasks. Generally only primitive types and some STL types are supported, you can of course write a serializer for some STL type by using documentation from <a href="https://github.com/ToruNiina/toml11">https://github.com/ToruNiina/toml11</a> as <code>ConfigManager</code> uses this library under the hood.</p>
<p ><code>ConfigManager</code> also has support for backup files and some other interesting features (see documentation for <code>ConfigManager</code>).</p>
<h2><a class="anchor" id="autotoc_md53"></a>
Adding external dependencies</h2>
<p >In CMake we modify our <code>CMakeLists.txt</code> to add external dependencies. This generally comes down to something like this:</p>
<div class="fragment"><div class="line">message(STATUS &quot;${PROJECT_NAME}: adding external dependency \&quot;FMT\&quot;...&quot;)</div>
<div class="line">add_subdirectory(${RELATIVE_EXT_PATH}/fmt ${DEPENDENCY_BUILD_DIR_NAME}/fmt SYSTEM)</div>
<div class="line">target_link_libraries(${PROJECT_NAME} PUBLIC fmt)</div>
<div class="line">set_target_properties(fmt PROPERTIES FOLDER ${EXTERNAL_FOLDER})</div>
</div><!-- fragment --><p >Note </p><blockquote class="doxtable">
<p >&zwj;This manual expects that you know what the code from above does as it's a usual CMake usage. </p>
</blockquote>
<p>Note </p><blockquote class="doxtable">
<p >&zwj;As you can see we mark external dependencies with <code>SYSTEM</code> so that clang-tidy (enabled in release builds) will not analyze source code of external dependencies. </p>
</blockquote>
<p>As it was said earlier you might need to do one additional step: if your target uses reflection (has <code>add_refureku</code> command) then you also need to tell the reflection generator about included headers of your external dependency:</p>
<div class="fragment"><div class="line">## Write project include directories for Refureku.</div>
<div class="line">set(REFUREKU_INCLUDE_DIRECTORIES</div>
<div class="line">    ${ABSOLUTE_EXT_PATH}</div>
<div class="line">    ${ABSOLUTE_EXT_PATH}/fmt/include     ## &lt;- new dependency</div>
<div class="line">    ${CMAKE_CURRENT_SOURCE_DIR}/public</div>
<div class="line">    ${CMAKE_CURRENT_SOURCE_DIR}/private</div>
<div class="line">)</div>
<div class="line">add_refureku(</div>
<div class="line">    ## some code here</div>
</div><!-- fragment --><p >If you compile your project after adding a new external dependency and the compilation fails with something like this:</p>
<div class="fragment"><div class="line">[Error] While processing the following file: .../MyHeaderThatUsesExternalDependency.h: &#39;fmt/core.h&#39; file not found (.../MyHeaderThatUsesExternalDependency.h, line 10, column 10), : 0:0</div>
</div><!-- fragment --><p >this is because you forgot to tell the reflection generator about some directory of your external dependency.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Importing custom meshes</h2>
<p >Generally you would import meshes using the editor but we will show how to do it in C++.</p>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;We only support import from GLTF/GLB format. </p>
</blockquote>
<p>In order to import your file you need to use <code>MeshImporter</code> like so:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;io/MeshImporter.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> optionalError = MeshImporter::importMesh(</div>
<div class="line">    <span class="stringliteral">&quot;C:\\models\\DamagedHelmet.glb&quot;</span>,       <span class="comment">// importing GLB as an example, you can import GLTF in the same way</span></div>
<div class="line">    <span class="stringliteral">&quot;game/models&quot;</span>,                         <span class="comment">// path to the output directory relative `res` (should exist)</span></div>
<div class="line">    <span class="stringliteral">&quot;helmet&quot;</span>,                              <span class="comment">// name of the new directory that will be created (should not exist yet)</span></div>
<div class="line">    [](std::string_view sState) {</div>
<div class="line">        Logger::get().info(sState);</div>
<div class="line">    });</div>
<div class="line"><span class="keywordflow">if</span> (optionalError.has_value()) [[unlikely]] {</div>
<div class="line">    <span class="comment">// ... process error ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >If the import process went without errors you can then find your imported model in form of a node tree inside of the resulting directory. You can then deserialize that node tree and use it in your game using the following code:</p>
<div class="fragment"><div class="line"><span class="comment">// Deserialize node tree.</span></div>
<div class="line"><span class="keyword">auto</span> result = Node::deserializeNodeTree(</div>
<div class="line">    ProjectPaths::getPathToResDirectory(ResourceDirectory::ROOT) / <span class="stringliteral">&quot;game/models/helmet/helmet.toml&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(result)) {</div>
<div class="line">    <span class="comment">// ... process errorr ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> pImportedRootNode = std::get&lt;sgc::GcPtr&lt;Node&gt;&gt;(std::move(result));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn node tree.</span></div>
<div class="line">getWorldRootNode()-&gt;addChildNode(pImportedRootNode);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md55"></a>
Configuring export settings for your mesh in Blender</h3>
<p >Usually the only thing that you need to do is to untick the "+Y up" checkbox in "Transform" section (since we use +Z as our UP axis).</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Procedurally generating meshes</h2>
<p >The most simple example of procedurally generated geometry is the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;misc/PrimitiveMeshGenerator.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn procedural cube mesh.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pMeshNode = sgc::makeGc&lt;MeshNode&gt;();</div>
<div class="line">pMeshNode-&gt;setMeshData(PrimitiveMeshGenerator::createCube(1.0F));</div>
<div class="line">getWorldRootNode()-&gt;addChildNode(pMeshNode);</div>
</div><!-- fragment --><p >If you would look into how <code>PrimitiveMeshGenerator::createCube</code> is implemented you would see that it just constructs a <code>MeshData</code> by filling all positions, normals, UVs, etc. In the same way you can create a procedural mesh by constructing a <code>MeshData</code> object. After we assigned a new mesh data to our mesh node we can set materials and shaders to it.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Working with materials</h2>
<h3><a class="anchor" id="autotoc_md58"></a>
Working with materials in C++</h3>
<p >Each <code>MeshNode</code> uses a default engine material (if other material is not specified) which means that if we have a <code>MeshNode</code> it already has a material.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;material/Material.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;shader/general/EngineShaderNames.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set mesh&#39;s diffuse color to red.</span></div>
<div class="line">pMeshNode-&gt;getMaterial()-&gt;setDiffuseColor(glm::vec(1.0F, 0.0F, 0.0F));</div>
</div><!-- fragment --><p >You can also assign a new material to your <code>MeshNode</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;material/Material.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;shader/general/EngineShaderNames.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> result = Material::create(</div>
<div class="line">  EngineShaderNames::MeshNode::sVertexShaderName, <span class="comment">// since we change `MeshNode`&#39;s material we use `MeshNode` shaders</span></div>
<div class="line">  EngineShaderNames::MeshNode::sPixelShaderName,</div>
<div class="line">  <span class="keyword">false</span>); <span class="comment">// create with transparency disabled</span></div>
<div class="line"><span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(result)) {</div>
<div class="line">  <span class="comment">// ... handle error ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> pMaterial = std::get&lt;std::unique_ptr&lt;Material&gt;&gt;(std::move(result));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assign this material to your mesh node.</span></div>
<div class="line">pMeshNode-&gt;setMaterial(std::move(pMaterial));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set mesh&#39;s diffuse color to red.</span></div>
<div class="line">pMeshNode-&gt;getMaterial()-&gt;setDiffuseColor(glm::vec(1.0F, 0.0F, 0.0F));</div>
</div><!-- fragment --><p >As you can see you can specify custom shaders when creating a new material (use will talk about custom shaders in another section).</p>
<p >Please note that each "Material" here should not be considered as some "big thing" that you need to reuse on multiple meshes - no, each material here is just a collection of small parameters such as diffuse color. You can think of the material here as "material properties" or a "material instance" if you want. If you have multiple materials that use the same shaders it's perfectly fine because under the hood the engine will not duplicate any loaded shaders or similar resources so these materials will just reference 1 set of shaders.</p>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;This also means that you cannot just simply clone/duplicate/share a material between multiple meshes. Unfortunatelly, at the time of writing this, we can't just use <code>std::shared_ptr</code> for materials because it might create a false assumption when you have 2 meshes that reference a single material, serialize and deserialize them - would result in both meshes having a separate (unique) material and they will no longer reference a single material. Thus we use <code>std::unique_ptr</code> to avoid false assumptions. But generally there wouldn't be such a need for this. When you import some mesh in the engine (this information is covered in another section) it's imported as a node tree (an asset file) where you generally only have a mesh node, then when this asset (node tree) is used in some level it's added to your level as external node tree and if you have multiple assets that were taken from the same node tree it's enough to modify the material in the asset's node tree to then see changes in all assets on the level. </p>
</blockquote>
<p>In order to enable transparency and use <code>Material::setOpacity</code> function you need to either create a material with transparency enabled (see example from above) or enable transparency using <code>Material::setEnableTransparency</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;material/Material.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;shader/general/EngineShaderNames.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enable transparency.</span></div>
<div class="line">pMeshNode-&gt;getMaterial()-&gt;setEnableTransparency(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set opacity.</span></div>
<div class="line">pMeshNode-&gt;getMaterial()-&gt;setOpacity(0.5F);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set mesh&#39;s diffuse color to red.</span></div>
<div class="line">pMeshNode-&gt;getMaterial()-&gt;setDiffuseColor(glm::vec(1.0F, 0.0F, 0.0F));</div>
</div><!-- fragment --><p >Note </p><blockquote class="doxtable">
<p >&zwj;Transparent materials have very serious impact on the performance so you might want to avoid using them. </p>
</blockquote>
<p>In order to use textures in your material you need to first import the textures you want to use. Most of the time you will import new textures through the editor using its GUI but we will show how to do it in C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;io/TextureImporter.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Import some texture to be used as a diffuse texture in our materials.</span></div>
<div class="line"><span class="keyword">auto</span> optionalError = TextureImporter::importTexture(</div>
<div class="line">    <span class="stringliteral">&quot;C:\\somedirectory\\textures\\mytexture.png&quot;</span>, <span class="comment">// file to import</span></div>
<div class="line">    TextureImportFormat::RGBA,                    <span class="comment">// import format</span></div>
<div class="line">    <span class="stringliteral">&quot;game/player/textures&quot;</span>,                       <span class="comment">// will be imported to &quot;res/game/player/textures/&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;diffuse&quot;</span>);                                   <span class="comment">// &quot;res/game/player/textures/diffuse/&quot; will be created during import</span></div>
<div class="line"><span class="keywordflow">if</span> (optionalError.has_value()) {</div>
<div class="line">    <span class="comment">// ... process error ...</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// texture is imported</span></div>
</div><!-- fragment --><p >In the example above after the image is imported the directory <code>res/game/player/textures/diffuse</code> will have multiple files with <code>DDS</code> and <code>KTX</code> extensions. Both formats are special GPU image formats with compression and mipmaps (if you heard about them). The <code>DDS</code> files are used by the DirectX renderer and the <code>KTX</code> files are used by the Vulkan renderer.</p>
<p >Let's now see how we can use this texture in our material:</p>
<div class="fragment"><div class="line">pMeshNode-&gt;getMaterial()-&gt;setDiffuseTexture(<span class="stringliteral">&quot;game/player/textures/diffuse&quot;</span>);</div>
</div><!-- fragment --><p >As you can see we specify a path to the directory with <code>DDS</code> and <code>KTX</code> files relative to our <code>res</code> directory and we don't need to point to a specific file because the engine will automatically use the appropriate file according to the currently used renderer.</p>
<p >Note if a texture is requested it will be loaded from disk, then if some other part of the game needs this texture it won't be loaded from disk again, it will just be used from the memory and finally when all parts of your game finish using a specific texture so that it's no longer used the texture will be automatically released from the memory.</p>
<p >Mesh nodes can have multiple materials assigned to different parts of the mesh. Both <code>MeshNode::getMaterial</code> and <code>MeshNode::setMaterial</code> have a default argument <code>iMaterialSlot = 0</code>. Each parts of the mesh that needs to have a separate material defines its own material slot, default cube only uses 1 material so it only has 1 material slot.</p>
<p >In order to query available material slots use <code>MeshNode::getAvailableMaterialSlotCount</code>. In order to create more material slots you need to define mesh that has multiple "parts". Information about these "parts" is stored in <code>MeshData</code>, here is an example:</p>
<div class="fragment"><div class="line"><span class="comment">// Create mesh node.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pMeshNode = sgc::makeGc&lt;MeshNode&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Generate cube mesh data.</span></div>
<div class="line"><span class="keyword">auto</span> meshData = PrimitiveMeshGenerator::createCube(1.0F);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Most importantly `MeshData` stores:</span></div>
<div class="line"><span class="comment">// - `std::vector&lt;MeshVertex&gt;` vVertices - vertices of the mesh</span></div>
<div class="line"><span class="comment">// - `std::vector&lt;std::vector&lt;meshindex_t&gt;&gt;` vIndices - array that stores indices of the mesh per material slot</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Generated cube only has 1 material slot...</span></div>
<div class="line">assert(meshData.<a class="code hl_function" href="classne_1_1MeshData.html#a35c1b75b662b7f56364ae01d7f15130c">getIndices</a>()-&gt;size() == 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... and it has some indices in this slot (which is what we expect).</span></div>
<div class="line">assert(meshData.<a class="code hl_function" href="classne_1_1MeshData.html#a35c1b75b662b7f56364ae01d7f15130c">getIndices</a>()-&gt;at(0)-&gt;size() &gt; 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set mesh data to our mesh node.</span></div>
<div class="line">pMeshNode-&gt;setMeshData(std::move(meshData));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Mesh data that we set has only 1 material slot so our mesh node now has only 1 material slot available</span></div>
<div class="line"><span class="comment">// (all new slots use engine default material).</span></div>
<div class="line">assert(pMeshNode-&gt;getAvailableMaterialSlotCount() == 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn mesh node.</span></div>
<div class="line">getWorldRootNode()-&gt;addChildNode(pMeshNode);</div>
<div class="ttc" id="aclassne_1_1MeshData_html_a35c1b75b662b7f56364ae01d7f15130c"><div class="ttname"><a href="classne_1_1MeshData.html#a35c1b75b662b7f56364ae01d7f15130c">ne::MeshData::getIndices</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; meshindex_t &gt; &gt; * getIndices()</div><div class="ttdef"><b>Definition:</b> MeshNode.cpp:771</div></div>
</div><!-- fragment --><p >Now let's split the cube in 2 material slots so that 1 special face of the cube will use one material and other faces will use other material:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> meshData = PrimitiveMeshGenerator::createCube(1.0F);</div>
<div class="line">meshData.<a class="code hl_function" href="classne_1_1MeshData.html#a35c1b75b662b7f56364ae01d7f15130c">getIndices</a>()-&gt;at(0) =  {</div>
<div class="line">    0,  1,  2,  3,  2,  1,  <span class="comment">// +X face.</span></div>
<div class="line">    8,  9,  10, 11, 10, 9,  <span class="comment">// +Y face.</span></div>
<div class="line">    12, 13, 14, 15, 14, 13, <span class="comment">// -Y face.</span></div>
<div class="line">    16, 17, 18, 19, 18, 17, <span class="comment">// +Z face.</span></div>
<div class="line">    20, 21, 22, 23, 22, 21  <span class="comment">// -Z face.</span></div>
<div class="line">};</div>
<div class="line">meshData.<a class="code hl_function" href="classne_1_1MeshData.html#a35c1b75b662b7f56364ae01d7f15130c">getIndices</a>()-&gt;push_back({4,  5,  6,  7,  6,  5}); <span class="comment">// -X face.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set mesh data to our mesh node.</span></div>
<div class="line">pMeshNode-&gt;setMeshData(std::move(meshData));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We now have 2 material slots.</span></div>
<div class="line">assert(pMeshNode-&gt;getAvailableMaterialSlotCount() == 2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Modify first material slot.</span></div>
<div class="line">pMeshNode-&gt;getMaterial(0)-&gt;setDiffuseColor(glm::vec3(1.0F, 0.0F, 0.0F));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Modify second material slot.</span></div>
<div class="line">pMeshNode-&gt;getMaterial(1)-&gt;setDiffuseColor(glm::vec3(0.0F, 1.0F, 0.0F));</div>
<div class="line">pMeshNode-&gt;getMaterial(1)-&gt;setEnableTransparency(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Spawn mesh node.</span></div>
<div class="line">getWorldRootNode()-&gt;addChildNode(pMeshNode);</div>
</div><!-- fragment --><p >Generally you won't need to directly modify mesh data or material slots as this will happen automatically when you import some mesh from a (for example) GLTF/GLB file but it's good if you know what they are and where there are created/stored.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Render statistics</h2>
<p >If you want to know your game's FPS or other similar statistics you can use <code>Renderer::getRenderStatistics</code>. For example, you can display the FPS on your game's UI for debugging purposes:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyUiNode::onLoopingTimerTimeout() {</div>
<div class="line"><span class="preprocessor">#if defined(DEBUG)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> iFps = getWindow()-&gt;getRenderer()-&gt;getRenderStatistics()-&gt;getFramesPerSecond();</div>
<div class="line">    <span class="comment">// ... display on UI ...</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md60"></a>
Using profiler</h2>
<p >The engine has <a href="https://github.com/Celtoys/Remotery">https://github.com/Celtoys/Remotery</a> integrated and you can use this profiler in order to detect slow parts of your game.</p>
<p >By default profiler is disabled in order to enable it you need to create a file at <code>*project_root*/src/engine_settings.cmake</code> and add the following variable to it:</p>
<div class="fragment"><div class="line">set(ENABLE_PROFILER ON)</div>
</div><!-- fragment --><p >Then you need to re-run cmake configuration and if everything is correct during the configuration you might see a message like <code>adding external dependency "Remotery"</code>. Note that when <code>ENABLE_PROFILER</code> is set profiler will be enabled only in debug builds.</p>
<p >Compile and run your project, during initialization you should see a message <code>profiler enabled</code> in the log.</p>
<p >Here are a few examples on how to use profiler:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;misc/Profiler.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyNode::onBeforeNewFrame(<span class="keywordtype">float</span> timeSincePrevFrameInSec){</div>
<div class="line">    Node::onBeforeNewFrame(timeSincePrevFrameInSec);</div>
<div class="line"> </div>
<div class="line">    PROFILE_FUNC;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... some code here ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onMouseMove(<span class="keywordtype">double</span> xOffset, <span class="keywordtype">double</span> yOffset) {</div>
<div class="line">    PROFILE_FUNC;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... some code here ...</span></div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        PROFILE_SCOPE(MyScope);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// ... some code here ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    PROFILE_SCOPE_START(MyScope); <span class="comment">// same as `PROFILE_SCOPE(MyScope)` but needs to be finished with `PROFILE_SCOPE_END`</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... some code here ...</span></div>
<div class="line"> </div>
<div class="line">    PROFILE_SCOPE_END;</div>
<div class="line">}</div>
</div><!-- fragment --><p >You can use these macros interchangeably.</p>
<p >After you add profiling macros you need to run your app and open <code>*project_root*/ext/Remotery/vis/index.html</code> in your browser. When your app is running with profiler enabled you will see time measurements for profiled functions.</p>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;If you don't see any time measurements you might need to refresh the page, then wait 5-10 seconds and try again if nothing shows up. </p>
</blockquote>
<p>In the browser page near the text "Main Thread" (in "Sample Timeline" panel) you can click on buttons "+" and "-" to show/hide hierarchy (inner time measurements). You can also click on "Pause" button in the top-right corner to pause receiving of the new data. You can also expand a panel named "Main Thread" (usually in the bottom-right corner) to view hierarchy of calls you selected in "Sample Timeline" and their time measurements.</p>
<p >Note </p><blockquote class="doxtable">
<p >&zwj;It's recommended to use profiler for a short amount of time to identify slow parts of your code because the profiler has proved to cause freezes at startup and sometimes memory leaks. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md61"></a>
Simulating input for automated tests</h2>
<p >Your game has a <code>..._tests</code> target for automated testing (which relies on <a href="https://github.com/catchorg/Catch2">https://github.com/catchorg/Catch2</a>) and generally it will be very useful to simulate user input. Here is an example on how to do that:</p>
<div class="fragment"><div class="line"><span class="comment">// Simulate input.</span></div>
<div class="line">getWindow()-&gt;onKeyboardInput(KeyboardKey::KEY_A, <a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>(0), <span class="keyword">true</span>); <span class="comment">// simulate keyboard &quot;A&quot; pressed</span></div>
<div class="line">getWindow()-&gt;onKeyboardInput(KeyboardKey::KEY_A, <a class="code hl_class" href="classne_1_1KeyboardModifiers.html">KeyboardModifiers</a>(0), <span class="keyword">false</span>); <span class="comment">// simulate keyboard &quot;A&quot; released</span></div>
</div><!-- fragment --><p >Once such function is called it will trigger register input bindings in your game instance and nodes.</p>
<p >There are also other <code>on...</code> function in <code>Window</code> that you might find handy in simulating user input.</p>
<p >For more examples see <code>src/engine_tests/game/node/Node.cpp</code>, there are some tests that simulate user input.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
Exporting your game</h2>
<p >If you want to distribute a version of your game you need to switch to the <code>release</code> build mode in your IDE to switch CMake to <code>release</code> build configuration (make sure CMake is now using a <code>release</code> configuration). Then build your project as usual, it will take much longer since we have <code>clang-tidy</code> enabled for <code>release</code> builds. <code>clang-tidy</code> can fail the build if it finds some issues in your code. It's expected that you build your game in <code>release</code> mode regularly to fix <code>clang-tidy</code> warnings/errors (if there are any).</p>
<p >Once your project is built in <code>release</code> mode go to the directory where the root <code>CMakeLists.txt</code> file is located and directories like <code>ext</code> and <code>res</code>. Depending on your setup you need to open the directory where built binaries are located, this is typically <code>build</code> directory (or it may be called differently, for example <code>out</code>). Inside of this directory you will see a directory named <code>OUTPUT</code> - this is where all built CMake targets are located. Inside of the <code>OUTPUT</code> directory you should find a directory named after your game's target. Inside of that directory will be located the final executable (or it will be located in the directory named <code>Release</code>). If you would try to run that executable you will get an error saying that the <code>res</code> directory is not found. This is expected as there are some additional steps that you need to do.</p>
<p >After you have your built executable you might notice a file named something like <code>COPY_UPDATED_RES_DIRECTORY_HERE</code> next to your game's executable. This is a "reminder" file that you need to manually copy the <code>res</code> directory from the root of your project directory next to the executable. Note that you need to make an actual copy, don't make symlinks and don't cut-paste it, you need to make a copy. This copy is a snapshot of the game's resources for this specific game version. After you've copied the <code>res</code> directory you can remove the "reminder" file named <code>COPY_UPDATED_RES_DIRECTORY_HERE</code>. At this point if you run the executable your game should start. The only thing left to do is to remove non-game related files from this directory.</p>
<p >In order to remove non-game related files next to the built executable there will be a directory named <code>delete_nongame_files</code>, open it and you will find a Go script in it. Read the <code>README.md</code> file next to the script file and run the script. It will interactively ask you if you want to delete non-game related files and etc. Once the script is finished it will tell you that you can delete the directory with this script as it's no longer needed. You should now try starting your game using the built executable to see if everything works after all non-game related files were deleted.</p>
<p >As you might have noticed next to the built executable of your game there is an <code>ext</code> directory. This directory contains license files of all external dependencies that you have in your project's root <code>ext</code> directory, plus there is a copy of engine's license file. You are required to distribute this directory as part of your build - do not delete this directory. You don't need to list these licenses in your EULA or somewhere else, you just need to distribute them as part of your build - nothing more.</p>
<p >That's it! Your game is ready to be distributed. You can archive the directory with the built executable and send it to a friend or upload it on the Internet.</p>
<p >At the time of writing this there is no compression/encryption of the game's resources. All game's resources are distributed as-is.</p>
<h1><a class="anchor" id="autotoc_md63"></a>
Regular reading</h1>
<p >This part of the manual groups sections that you might want to re-read regularly in the future.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Tips to note when working with nodes</h2>
<p >Prefer to start your custom nodes like this:</p>
<div class="fragment"><div class="line">MyDerivedNode() : MyDerivedNode(<span class="stringliteral">&quot;My Derived Node&quot;</span>) {};</div>
<div class="line">MyDerivedNode(<span class="keyword">const</span> std::string&amp; sNodeName) : ParentNodeClass(sNodeName) {</div>
<div class="line">  <span class="comment">// constructor logic</span></div>
<div class="line">}</div>
<div class="line"><span class="keyword">virtual</span> ~MyDerivedNode() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
</div><!-- fragment --><p >If you override some <code>virtual</code> function in node it's very likely (read the documentation for the functions you are overriding) that <b>you need to call the parent's version</b>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> FlyingCharacterNode::onChildNodesSpawned() {</div>
<div class="line">    SpatialNode::onChildNodesSpawned(); <span class="comment">// &lt;- calling parent&#39;s version</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... your code ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Don't forget about <code>Node::getChildNodeOfType</code> and <code>Node::getParentNodeOfType</code> as they might be useful.</p>
<p ><b>Remember that <code>World</code> is inaccessable when the node is not spawned and thus <code>Node::getWorldRootNode</code> is <code>nullptr</code>.</b></p>
<p >If you have a character node with some child nodes and you want the player to explore the world by walking on his feet or by riding a car you can use <code>pCarNode-&gt;addChildNode(pCharacterNode)</code> to attach your already spawned player (which is attached to the world's root node) to the car node when the player gets in the car or detach it from the car by using something like <code>getWorldRootNode()-&gt;addChildNode(pCharacterNode)</code> to make it attached to the world's root node again. By using <code>addChildNode</code> you can not only add child nodes but also attach and detach existing ones even if they already have a parent.</p>
<p >The order in which <code>Node::onBeforeNewFrame</code> are called on nodes is kind of random. If you need a specific node's <code>onBeforeNewFrame</code> to be called before <code>onBeforeNewFrame</code> of some other node consider using <code>Node::setTickGroup</code>. For example if your game have a functionality to focus the camera on some world entity you might want to put the "focusing" logic in the later tick group to make sure that all world entities processed their movement before you rotate (focus) the camera.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
Important things to keep in mind</h2>
<p >This section contains a list of important things that you need to regularly check while developing a game to minimize the amount of bugs/crashes in your game. All information listed below is documented in the manual and in the engine code (just duplicating the most important things here, see more details in other sections of the manual or in the engine code documentation).</p>
<h3><a class="anchor" id="autotoc_md66"></a>
General</h3>
<ul>
<li>always read the documentation for the functions you are using (documentation comments in the code), this generally saves you from all issues listed here</li>
<li>always check the logs, if something goes wrong the engine will let you know in the logs, after your game is closed if there were any warnings/errors the last message in the log (before the application is closed) will be the total number of warnings/errors produced (if there were any) so you don't have to scroll through the logs or use search every time</li>
<li>from time to time check your console output's beginning when you start your game for special warnings like <code>[Refureku] WARNING: Double registration detected</code> which are not captured by our logging system, these might occur in very special cases, report these if found</li>
</ul>
<h3><a class="anchor" id="autotoc_md67"></a>
Garbage collection and GC pointers</h3>
<ul>
<li>never capture <code>gc</code> pointers in <code>std::function</code></li>
<li>never store <code>gc</code> pointers in STL containers, store <code>gc</code> pointers only in "gc containers"</li>
</ul>
<h3><a class="anchor" id="autotoc_md68"></a>
Multiple inheritance</h3>
<ul>
<li>using <code>gc</code> pointers on types that use multiple inheritance is not supported and will cause exceptions, leaks and crashes</li>
<li>if you use multiple inheritance with serialization (not using <code>gc</code> pointers), make sure to derive from the <code>Serializable</code> class (or derived, for ex. <code>Node</code>) first and only then from other non <code>Serializable</code> classes (order matters, otherwise garbage data will be serialized instead of the actual data)</li>
</ul>
<h3><a class="anchor" id="autotoc_md69"></a>
Serialization/deserialization</h3>
<ul>
<li>initialize almost all <code>RPROPERTY(Serialize)</code> fields, for example: <div class="fragment"><div class="line"><span class="comment">// MyHeader.h</span></div>
<div class="line">UPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line"><span class="keywordtype">long</span> <span class="keywordtype">long</span> iCharacterLevel = 0; <span class="comment">// initialize because it can get garbage value</span></div>
<div class="line"> </div>
<div class="line">UPROPERTY(<a class="code hl_class" href="classne_1_1Serialize.html">Serialize</a>)</div>
<div class="line">std::string sMyText; <span class="comment">// `std::string` can&#39;t get garbage value since it&#39;s initialized in std::string&#39;s constructor</span></div>
</div><!-- fragment --> otherwise you might serialize a garbage value and then deserialize it as a garbage value which might cause unexpected reaction</li>
</ul>
<h3><a class="anchor" id="autotoc_md70"></a>
Node</h3>
<ul>
<li>always check <code>getWorldRootNode</code> for <code>nullptr</code> before using it, <code>nullptr</code> here typically means that the node is not spawned or the world is being destroyed</li>
<li>always remember to call parent's virtual function in the beginning of your override (note that this is not always needed but is required for some <code>Node</code> functions)</li>
<li>use <code>NodeFunction</code> instead of <code>std::function</code> when you need callbacks in nodes</li>
<li>use <code>NodeNotificationBroadcaster</code> when you need publisher-subscriber pattern</li>
<li>it's highly recommended to not do any logic if the node is not spawned to avoid running into <code>nullptr</code>s (or deleted memory when on a non-main thread, use <code>getSpawnDespawnMutex()</code> mutex for non-main thread functions)</li>
</ul>
<h3><a class="anchor" id="autotoc_md71"></a>
Multithreading</h3>
<ul>
<li>when using thread pool tasks remember that all thread pool tasks will be stopped during the game destruction before GameInstance is destroyed, there are no other checks for thread pool tasks to be stopped so in other cases you need to make sure your async task will not hit deleted memory:<ul>
<li>if you're using <code>Node</code> member functions in async task make sure the task is finished in your Node::onDespawning,</li>
<li>if you're using <code>GameInstance</code> member functions in async task you only might care about world being changed, for this use promise/future or something else to guarantee that the callback won't be called on a deleted object</li>
</ul>
</li>
<li>use <code>NodeFunction</code> instead of <code>std::function</code> when you need to process asynchronous results in nodes</li>
<li>submitting a deferred task from a <b>non-main thread</b> where in deferred task you operate on a <code>gc</code> controlled object such as Node can be dangerous as you may operate on a deleted (freed) memory, in this case use additional checks in the beginning of your deferred task to check if the node you want to use is still valid: <div class="fragment"><div class="line"><span class="comment">// We are on a non-main thread inside of a node:</span></div>
<div class="line">addDeferredTask([<span class="keyword">this</span>, iNodeId](){ <span class="comment">// capturing `this` to use `Node` (self) functions, also capturing self ID</span></div>
<div class="line">    <span class="comment">// We are inside of a deferred task (on the main thread) and we don&#39;t know if the node (`this`)</span></div>
<div class="line">    <span class="comment">// was garbage collected or not because we submitted our task from a non-main thread.</span></div>
<div class="line">    <span class="comment">// REMEMBER: we can&#39;t capture `gc` pointers in `std::function`, this is not supported</span></div>
<div class="line">    <span class="comment">// and will cause memory leaks/crashes!</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pGameManager = GameManager::get(); <span class="comment">// using engine&#39;s private class `GameManager`</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// `pGameManager` is guaranteed to be valid inside of a deferred task.</span></div>
<div class="line">    <span class="comment">// Otherwise, if running this code outside of a deferred task you need to do 2 checks:</span></div>
<div class="line">    <span class="comment">// if (pGameManager == nullptr) return;</span></div>
<div class="line">    <span class="comment">// if (pGameManager-&gt;isBeingDestroyed()) return;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!pGameManager-&gt;<a class="code hl_function" href="classne_1_1GameManager.html#af183d6afc41ca41a4687f3073504f0fe">isNodeSpawned</a>(iNodeId)){</div>
<div class="line">        <span class="comment">// Node was despawned and it may be dangerous to run the callback.</span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Can safely interact with `this` (self) - we are on the main thread.</span></div>
<div class="line">});</div>
<div class="ttc" id="aclassne_1_1GameManager_html_af183d6afc41ca41a4687f3073504f0fe"><div class="ttname"><a href="classne_1_1GameManager.html#af183d6afc41ca41a4687f3073504f0fe">ne::GameManager::isNodeSpawned</a></div><div class="ttdeci">bool isNodeSpawned(size_t iNodeId)</div><div class="ttdef"><b>Definition:</b> GameManager.cpp:598</div></div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md72"></a>
Advanced topics</h1>
<h2><a class="anchor" id="autotoc_md73"></a>
Writing custom shaders</h2>
<h3><a class="anchor" id="autotoc_md74"></a>
Introduction</h3>
<p >This section expects that you have knowledge in writing programs in HLSL and/or GLSL.</p>
<p >Note: currently we are looking for a solution that will make writing custom shaders easier but right now writing custom shaders is not that simple: </p><blockquote class="doxtable">
<p >&zwj;Right now if you want to go beyond what Material provides to you and achieve some special look of your meshes you would have to write shaders in both HLSL and GLSL if you want your game to support both DirectX and Vulkan renderers that we have because each graphics API (like DirectX or Vulkan) has its own shading language. If you know that you don't want Vulkan support and don't care about Linux and other non-Windows platforms then you might just write a shader in HLSL and ignore GLSL, this would mean that any attempt to run your game using Vulkan renderer will fail with an error. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md75"></a>
Shader formatter</h3>
<p >Similar to <code>clang-format</code> we use a special formatter for shaders: <a href="https://github.com/Flone-dnb/vscode-shader-formatter">https://github.com/Flone-dnb/vscode-shader-formatter</a></p>
<p >Make sure you use it when writing shaders.</p>
<h3><a class="anchor" id="autotoc_md76"></a>
Writing custom vertex/pixel/fragment shaders</h3>
<p >We will talk about creating a custom pixel/fragment shader but the same idea applies to creating custom vertex shaders. Here are the steps to create a new custom shader:</p>
<ol type="1">
<li>Create a new shader file somewhere in the <code>res</code> directory, for example: <code>res/game/shaders/hlsl/CustomMeshNode.frag.hlsl</code> or in <code>glsl</code> directory with <code>.frag.glsl</code> extension if you want to create a GLSL shader.</li>
<li><code>#include</code> an engine shader file that your shader "derives" from. For example if you want to create a custom shader for <code>MeshNode</code> you need to include <code>MeshNode.frag.hlsl</code>. For example: <code>#include "../../../engine/shaders/hlsl/include/MeshNode.frag.hlsl"</code>.<ol type="a">
<li>1. For GLSL you need to include <code>#include "../../../engine/shaders/glsl/include/MeshNode.frag.glsl"</code>.</li>
</ol>
</li>
<li>Define pixel shader function, you can copy-paste their signature from the included engine shader file, it may be named as <code>psMeshNode</code> or <code>fsMeshNode</code>.</li>
<li>As the first line of your shader function, call a function from the included engine shader, again it may be named as <code>psMeshNode</code> or <code>fsMeshNode</code>, and pass any input parameters if your function has them.</li>
<li>Modify resulting data as you want.</li>
</ol>
<p >In order to compile your shader you need to use the <code>ShaderManager</code> object, here is an example on how to do it using HLSL shaders:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;shader/ShaderManager.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;shader/general/EngineShaders.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted(){</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pixelShader = <a class="code hl_struct" href="structne_1_1ShaderDescription.html">ShaderDescription</a>(</div>
<div class="line">        <span class="stringliteral">&quot;game.meshnode.fs&quot;</span>,                               <span class="comment">// global unique shader name</span></div>
<div class="line">        <span class="stringliteral">&quot;res/game/shaders/hlsl/CustomMeshNode.frag.hlsl&quot;</span>, <span class="comment">// path to shader file, using custom pixel shader</span></div>
<div class="line">        ShaderType::FRAGMENT_SHADER,                      <span class="comment">// shader type</span></div>
<div class="line">        VertexFormat::MESH_NODE,                          <span class="comment">// vertex structure layout</span></div>
<div class="line">        <span class="stringliteral">&quot;fsCustomMeshNode&quot;</span>,                               <span class="comment">// shader entry function name</span></div>
<div class="line">        EngineShaders::MeshNode::getFragmentShader(<span class="keyword">false</span>) <span class="comment">// macros: since we are &quot;deriving&quot; from MeshNode shader we use</span></div>
<div class="line">            .definedShaderMacros);                        <span class="comment">// engine shader&#39;s macros (but we can also add our macros)</span></div>
<div class="line">        <span class="comment">// (you don&#39;t need to define all macros that engine shader files use (like PS_USE_DIFFUSE_TEXTURE) because they</span></div>
<div class="line">        <span class="comment">// will be automatically defined by the engine when needed)</span></div>
<div class="line"> </div>
<div class="line">    std::vector vShaders = {pixelShader};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> onProgress = [](<span class="keywordtype">size_t</span> iCompiledShaderCount, <span class="keywordtype">size_t</span> iTotalShadersToCompile) {</div>
<div class="line">        <span class="comment">// show progress here</span></div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> onError = [](<a class="code hl_struct" href="structne_1_1ShaderDescription.html">ShaderDescription</a> shaderDescription, std::variant&lt;std::string, Error&gt; errorInfo) {</div>
<div class="line">        <span class="keywordflow">if</span> (std::holds_alternative&lt;std::string&gt;(errorInfo)){</div>
<div class="line">            <span class="comment">// shader compilation error</span></div>
<div class="line">        }<span class="keywordflow">else</span>{</div>
<div class="line">            <span class="comment">// internal error</span></div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> onCompleted = []() {</div>
<div class="line">        <span class="comment">// do final logic here</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// shader compilation is done asynchronously by using engine&#39;s thread pool</span></div>
<div class="line">    getWindow()-&gt;getRenderer()-&gt;getShaderManager()-&gt;compileShaders(</div>
<div class="line">        vShaders,</div>
<div class="line">        onProgress,</div>
<div class="line">        onError,</div>
<div class="line">        onCompleted</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="ttc" id="astructne_1_1ShaderDescription_html"><div class="ttname"><a href="structne_1_1ShaderDescription.html">ne::ShaderDescription</a></div><div class="ttdef"><b>Definition:</b> ShaderDescription.h:74</div></div>
</div><!-- fragment --><p >For HLSL you would do the same thing (<code>ShaderType::FRAGMENT_SHADER</code> is considered as "pixel shader" when compiling HLSL shaders).</p>
<p >You should not remove the code to compile your shaders (<code>ShaderManager::compileShaders</code>) from your game. This code not only compiles the shaders but also adds them to the global "shader registry". If some shader was previously compiled then this means that the results of that compilation were cached and the next time you will call <code>compileShaders</code> instead of compiling it again the results will be retrived from the cache. If you change your shader code or something else the cache might be automatically invalidated (inside <code>ShaderManager::compileShaders</code>) and your shader will be automatically recompiled so if you do any changes in the shader file (or in any files that your shader includes) you just need to restart the game to see your changes.</p>
<p >Please note: </p><blockquote class="doxtable">
<p >&zwj;If you got an idea of displaying a splash screen using a separate <code>GameInstance</code> (before starting your game's <code>GameInstance</code>) in order to compile your shaders inside of that splash screen game instance it would be a bad idea because <code>compileShaders</code> will be called twice (inside of your splash screen game instance and inside of your game's game instance) which means that even if no shader was changed the shader cache will be checked twice which might take some time if you have lots of shaders. </p>
</blockquote>
<p>As you might have noticed in the <code>res/engine/shaders/include</code> directory there are <code>.glsl</code> shaders outside of the <code>glsl</code>/<code>hlsl</code> directory. These shaders contain code that can be used in both HLSL and GLSL. Before passing shader code to a shader compiler we parse the code from disk using a special but simple parser (see <a href="https://github.com/Flone-dnb/combined-shader-language-parser">https://github.com/Flone-dnb/combined-shader-language-parser</a>). It allows mixing HLSL and GLSL code. You can also use such functionality and have just one shader file instead of separate HLSL and GLSL files if you want.</p>
<h3><a class="anchor" id="autotoc_md77"></a>
Writing custom compute shaders</h3>
<p >Shader compilation for compute shaders is the same as from the previous section that described custom vertex/pixel/fragment shaders. What's different is how we interact with compute shaders.</p>
<p >After you have compiled your compute shader you need to create a special "interface" object to interact with your compute shader (specify input/output resources, dispatch it and etc.). Let's consider an example where you want to calculate some data (stored in a resource) that will be used during the rendering:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;shader/ComputeShaderInterface.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyGameInstance::onGameStarted(){</div>
<div class="line">    <span class="comment">// ... compile compute shader ...</span></div>
<div class="line">    <span class="comment">// on compilation finished:</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create shader interface.</span></div>
<div class="line">    <span class="keyword">auto</span> computeInterfaceResult = ComputeShaderInterface::createUsingGraphicsQueue(</div>
<div class="line">        getWindow()-&gt;getRenderer(),</div>
<div class="line">        <span class="stringliteral">&quot;my.compute.shader.name&quot;</span>, </div>
<div class="line">        ComputeExecutionStage::AFTER_DEPTH_PREPASS);</div>
<div class="line">    <span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(computeInterfaceResult)) {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line">    pComputeShaderInterface = std::get&lt;std::unique_ptr&lt;ComputeShaderInterface&gt;&gt;(std::move(computeInterfaceResult));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a resource that we will use in compute shader.</span></div>
<div class="line">    <span class="keyword">auto</span> resourceCreationResult = getWindow()-&gt;getRenderer()-&gt;getResourceManager()-&gt;createResourceWithData(...);</div>
<div class="line">    <span class="keywordflow">if</span> (std::holds_alternative&lt;Error&gt;(resourceCreationResult)) {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">auto</span> pComputeResource = std::get&lt;std::unique_ptr&lt;GpuResource&gt;&gt;(std::move(resourceCreationResult));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bind resource to be available in compute shader.</span></div>
<div class="line">    optionalError = pComputeShaderInterface-&gt;bindResource(</div>
<div class="line">        pComputeResource.get(), <span class="stringliteral">&quot;result&quot;</span>, ComputeResourceUsage::READ_WRITE_ARRAY_BUFFER);</div>
<div class="line">    <span class="keywordflow">if</span> (optionalError.has_value()) {</div>
<div class="line">        <span class="comment">// ... handle error ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Submit our shader.</span></div>
<div class="line">    pComputeShaderInterface-&gt;submitForExecution(1, 2, 3);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Here our shader will be run only once before the first frame is rendered, if you want to regularly run your shader you just need to re<code>submitForExecution</code> it in your <code>onBeforeNewFrame</code> (for example). For more information, see function documentation.</p>
<h3><a class="anchor" id="autotoc_md78"></a>
Shader packs and shader variants</h3>
<p >If you looked in the engine shader files you might have noticed that some parts of the shader code are used only when a specific macro is defined (for example <code>#ifdef PS_USE_DIFFUSE_TEXTURE</code>). This is how engine shaders do branching (mostly), so instead of doing an actual runtime <code>if</code> the engine shader rely on predefined macros because runtime branching on GPUs can cause performance issues.</p>
<p >When you or the engine submits a shader to be compiled the engine creates a special object <code>ShaderPack</code>. Then depending on the shader type (vertex/pixel/fragment/compute/etc) the engine retrieves a special collection of compatible macro combinations, for pixel/fragment shader these combinations may be:</p>
<ul>
<li>[] (no macros),</li>
<li>[PS_USE_DIFFUSE_TEXTURE] (opaque material with diffuse texture set),</li>
<li>[PS_USE_DIFFUSE_TEXTURE, PS_USE_MATERIAL_TRANSPARENCY] (transparent material with diffuse texture set),</li>
<li>[PS_USE_MATERIAL_TRANSPARENCY] (transparent material without diffuse texture),</li>
<li>etc.</li>
</ul>
<p >For every combination of macros the engine compiles one shader variant with only specific macros defined and then stores all shader variants in the shader pack object. Shader pack is then saved on the disk (cached) to be used on the next startup (so that the engine will just read shader bytecode from disk instead of compiling the shaders again). You can see information about all compiled shaders and their variants if you look in the following directory:</p>
<ul>
<li>[Windows] localappdata%/nameless-engine/*targetname*/shader_cache</li>
<li>[Linux] ~/.config/nameless-engine/*targetname*/shader_cache</li>
</ul>
<p >In the shader cache directory you will find one directory per shader. Inside of the shader specific directory you will find multiple files but you should focus on the files with the <code>.toml</code> extension. Each TOML file describes one shader variant and if you open that TOML file in your text editor you might learn some information about a shader (like which macros were defined and etc).</p>
<p >At runtime when, for example, some material is created it requests a pair of vertex and pixel/fragment shaders (it actually requests a graphics pipeline but we will omit this for simplicity). The engine then asks the renderer on which macros should be defined right now (depending on the current render settings) and plus the material also tells which macros it defines (for example <code>PS_USE_MATERIAL_TRANSPARENCY</code> when transparency is enabled), then <code>ShaderManager</code> looks for a shader pack for the specified shaders and returns a specific shader from the pack that corresponds with the requested macros. This is how a material receives its shader. If material changes its settings (like transparency) or something global (like render settings) is changed, if there is a shader macro that should be added/removed due to these changes, materials' shaders are being changed by getting another shader variant from the shader pack.</p>
<p >This is why you should not define some shader macros that are used in the engine shader files as they will be "defined" automatically when needed.</p>
<h3><a class="anchor" id="autotoc_md79"></a>
Debugging custom shaders</h3>
<p >You can use your usual shader debugging software (<code>PIX</code>, <code>RenderDoc</code>, <code>NVIDIA Nsight</code>, etc.) to debug your custom shaders. Just make sure your game is built in the <code>Debug</code> mode.</p>
<h3><a class="anchor" id="autotoc_md80"></a>
Using custom shader resources</h3>
<h4><a class="anchor" id="autotoc_md81"></a>
Introduction to using custom resources</h4>
<p >Let's consider a simple example of passing a buffer from C++ into your custom shader which looks like this:</p>
<div class="fragment"><div class="line">#include &quot;../../../engine/shaders/hlsl/include/MeshNode.frag.hlsl&quot;</div>
<div class="line"> </div>
<div class="line">cbuffer customData : register(b1) // register index/space can be different (as long as no other resource is using it)</div>
<div class="line">{</div>
<div class="line">    float4x4 someMatrix;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// your HLSL code</div>
</div><!-- fragment --><div class="fragment"><div class="line">#include &quot;../../../engine/shaders/glsl/include/MeshNode.frag.glsl&quot;</div>
<div class="line"> </div>
<div class="line">struct CustomData {</div>
<div class="line">    mat4 someMatrix; </div>
<div class="line">};</div>
<div class="line">layout(std140, binding = 9) readonly buffer CustomDataBuffer{ // binding index can be different (same as in HLSL)</div>
<div class="line">    CustomData array[];  // stores data for all objects (meshes) that use this shader</div>
<div class="line">} customData;</div>
<div class="line"> </div>
<div class="line">#additional_shader_constants</div>
<div class="line">{</div>
<div class="line">    uint customData; // named as your `readonly buffer`, case sensitive,</div>
<div class="line">                     // used to access element specific to the current object (mesh)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    fsMeshNode(); // call &quot;parent&quot; function</div>
<div class="line"> </div>
<div class="line">    // Define a short macro for simplicity.</div>
<div class="line">    #define MY_DATA customData.array[arrayIndices.customData]</div>
<div class="line"> </div>
<div class="line">    // Access our matrix.</div>
<div class="line">    glm::mat4x4 myMatrix = MY_DATA.someMatrix;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Note </p><blockquote class="doxtable">
<p >&zwj;If you want to use the same shader resource in both vertex and pixel/fragment shaders make sure that resource is using the same binding register/index in both shaders, when the engine finds a shader resource that was specified in both vertex and pixel/fragment shaders with the same name and the same binding register/index it will understand that it's the same resource and will avoid double-registration of the resource. It's recommended to move that resource's definition into a separate file and then include that file in your vertex and pixel/fragment shaders to guarantee that resource's binding register/index is the same. Engine shaders are using the same approach. </p>
</blockquote>
<p>Then in C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;shader/VulkanAlignmentConstants.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;math/GLMath.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ne;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>CustomMeshShaderConstants {</div>
<div class="line">    <span class="keyword">alignas</span>(iVkMat4Alignment) glm::mat4x4 someMatrix = glm::identity&lt;glm::mat4x4&gt;();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using mutex for example purposes, you are not required to use a mutex here</span></div>
<div class="line">std::pair&lt;std::recursive_mutex, CustomMeshShaderConstants&gt; mtxShaderData;</div>
</div><!-- fragment --><p >As you can see we use <code>alignas</code> to satisfy Vulkan aligning requirements and at the same time keep track of HLSL packing rules. If you only want to stick with some specific shading language (only GLSL or only HLSL) then you just need to keep track of your language specific packing rules.</p>
<p >Note that if you don't find a <code>iVk...Alignment</code> variable matching your type's name this means that you should avoid using this type, this includes types such as <code>vec3</code> and <code>mat3</code>, instead use <code>vec4</code> and <code>mat4</code> so you will avoid a bunch of alignment/packing issues.</p>
<p >Generally if you specify <code>alignas</code> to all fields (of a type that will be directly copied to the GPU) you should be pretty safe in terms of both Vulkan alignment requirements and HLSL packing rules.</p>
<p >In most cases there are only 2 things that you need to keep track of:</p>
<ol type="1">
<li>Order matters, that is the padding that <code>alignas</code> might introduce, for example:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CustomMeshShaderConstants {</div>
<div class="line">    <span class="keyword">alignas</span>(iVkScalarAlignment) <span class="keywordtype">float</span> test = 0.0F;    <span class="comment">// has 12 bytes of padding to satisfy next `iVkMat4Alignment`</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">alignas</span>(iVkMat4Alignment) glm::mat4x4 somematrix = glm::identity&lt;glm::mat4x4&gt;();</div>
<div class="line">};</div>
</div><!-- fragment --><p >Note </p><blockquote class="doxtable">
<p >&zwj;If you are using Qt Creator IDE you can see field alignment (plus padding if there is one) by hovering your mouse cursor over a field's name, which is very useful for such cases. </p>
</blockquote>
<p>In order to avoid this you might want to prefer to put "big types" (types with bigger alignment such as <code>mat</code>s and <code>vec</code>s) first and only then "small types" (such as <code>float</code>s and etc). Otherwise you might have lots of unused padding bytes that might bloat your data.</p>
<ol type="1">
<li>Extra padding on the last field might cause alignment problems in HLSL <code>StructuredBuffer</code>s:</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ShaderConstants {</div>
<div class="line">    <span class="keyword">alignas</span>(iVkVec4Alignment) glm::vec4 color = glm::vec4(1.0F, 1.0F, 1.0F, 1.0F);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">alignas</span>(iVkScalarAlignment) <span class="keywordtype">float</span> somevar = 0.0F;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 12 bytes of padding here</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >HLSL structured buffer will look like this:</p>
<div class="fragment"><div class="line">struct MyData {</div>
<div class="line">    vec4 color;</div>
<div class="line">    </div>
<div class="line">    float somevar;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">StructuredBuffer&lt;MyData&gt; myData : register(t0);</div>
</div><!-- fragment --><p >If you store more than 1 element in this structured buffer your second element will be aligned incorrectly because in C++ you have that 12 bytes of padding at the end but HLSL <code>StructuredBuffer</code>s are tightly-packed and there's no 12 bytes of padding in the end so your second element in the structured buffer will reference padding bytes in its <code>color</code> field.</p>
<p >In order to avoid such issues just add explicit padding like <code>float pad[3]</code> and <code>vec3 pad</code> in C++ and HLSL.</p>
<p >Now let's tell the engine how to pass your buffer to shaders:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CustomMeshNode::onSpawning(){</div>
<div class="line">    SpatialNode::onSpawning();</div>
<div class="line"> </div>
<div class="line">    setShaderCpuWriteResourceBinding(       <span class="comment">// call this function only in `onSpawning`, see function docs</span></div>
<div class="line">        <span class="stringliteral">&quot;customData&quot;</span>,                       <span class="comment">// name of the resource written in your shader file (HLSL/GLSL)</span></div>
<div class="line">        <span class="keyword">sizeof</span>(CustomMeshShaderConstants),  <span class="comment">// size of your buffer</span></div>
<div class="line">        [<span class="keyword">this</span>]() -&gt; <span class="keywordtype">void</span>* { <span class="keywordflow">return</span> onStartedUpdatingShaderConstants(); },</div>
<div class="line">        [<span class="keyword">this</span>]() { onFinishedUpdatingShaderConstants(); }</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><p >Then implement "updating" functions that will be automatically called by the engine when it needs to copy our data from RAM to VRAM:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span>* CustomMeshNode::onStartedUpdatingShaderConstants() {</div>
<div class="line">    mtxShaderData.first.lock();  <span class="comment">// don&#39;t unlock yet</span></div>
<div class="line">    <span class="keywordflow">return</span> &amp;mtxShaderData.second;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> CustomMeshNode::onFinishedUpdatingShaderConstants() {</div>
<div class="line">    mtxShaderData.first.unlock(); <span class="comment">// copying is finished</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >Then in any place of your custom mesh node (even when it's not spawned yet) when you need to copy your data to shaders:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CustomMeshNode::onSomeEvent() {</div>
<div class="line">    <span class="comment">// Update our data.</span></div>
<div class="line">    std::scoped_lock guard(mtxShaderData.first);</div>
<div class="line">    mtxShaderData.second.somematrix = getSomeMatrix();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Mark data to be copied to the GPU.</span></div>
<div class="line">    markShaderCpuWriteResourceToBeCopiedToGpu(<span class="stringliteral">&quot;customData&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p ><code>markShaderCpuWriteResourceToBeCopiedToGpu</code> will notify the engine if your node is spawned, otherwise it won't do anything so that your "update" functions will only be called while your node is spawned. After the engine was notified it will mark that resource as "needs update" and call your "update" functions before the next frame is submitted to be rendered (when the engine will be ready to update GPU resources).</p>
<p >If you assigned your custom shaders to the material of your <code>CustomMeshNode</code> then we don't need to do anything else.</p>
<h4><a class="anchor" id="autotoc_md82"></a>
Using custom textures</h4>
<p >Similar approach is used for custom textures. First, define a shader:</p>
<div class="fragment"><div class="line">// ... some code here ...</div>
<div class="line"> </div>
<div class="line">#hlsl Texture2D customTexture : register(t5, space5);</div>
<div class="line">#glsl layout(binding = 8) uniform sampler2D customTexture[];</div>
<div class="line"> </div>
<div class="line">#additional_shader_constants{</div>
<div class="line">    uint customTexture; // access it using `constants.customTexture`</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void main(){</div>
<div class="line">... some code here ...</div>
<div class="line"> </div>
<div class="line">#hlsl float4 color = customTexture.Sample(textureSampler, pin.uv);</div>
<div class="line">#glsl vec4 color   = texture(customTexture[constants.customTexture], fragmentUv);</div>
<div class="line"> </div>
<div class="line">... some code here ...</div>
<div class="line">}</div>
</div><!-- fragment --><p >Then assign a material that uses this pixel/fragment shader to your custom mesh node (use default vertex shader). Now, import a texture, use can use the editor or pure C++ for this step:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;material/TextureManager.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> optionalError = TextureManager::importTexture(</div>
<div class="line">    <span class="stringliteral">&quot;C:\\images\\stone.png&quot;</span>, TextureType::DIFFUSE, <span class="stringliteral">&quot;game&quot;</span>, <span class="stringliteral">&quot;stone&quot;</span>, importTextureProgress);</div>
<div class="line"><span class="keywordflow">if</span> (optionalError.has_value()) [[unlikely]] {</div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `importTextureProgress` signature and definition is skipped to simplify the example</span></div>
</div><!-- fragment --><p >Once you have a texture in your <code>res</code> directory you need to bind the file to the shader:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyMeshNode::onSpawning(){</div>
<div class="line">    MeshNode::onSpawning();</div>
<div class="line"> </div>
<div class="line">    setShaderTextureResourceBinding(    <span class="comment">// call this function only in `onSpawning`, see function docs</span></div>
<div class="line">        <span class="stringliteral">&quot;customTexture&quot;</span>,                <span class="comment">// name of the resource</span></div>
<div class="line">        <span class="stringliteral">&quot;game/stone&quot;</span>                    <span class="comment">// path relative `res`</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><p >Now your mesh's pixel/fragment shader will have a custom texture binded.</p>
<h2><a class="anchor" id="autotoc_md83"></a>
Adding support for new types for serialization/deserialization</h2>
<p >When you use <code>Serializable::serialize</code> function all fields marked with <code>RPROPERTY(Serialize)</code> will be checked for serialization. Serialization for fields is achieved by implementing the <code>IFieldSerializer</code> interface. Thanks to field serializers you can, for example, serialize fields that have primitive types (bool, int, long long, etc.) because there is a <code>PrimitiveFieldSerializer</code> that implements <code>IFieldSerializer</code>. Field serializers are located in the <code>io/serializers</code> directory, you can look how they are implemented. Back to the beginning, when you use <code>serialize</code> function the engine goes through each reflected field marked with <code>Serialize</code> property and basically does this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pSerializer : vFieldSerializers) {</div>
<div class="line">    <span class="keywordflow">if</span> (pSerializer-&gt;isFieldTypeSupported(&amp;field)) {</div>
<div class="line">        pSerializer-&gt;serializeField(&amp;field);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >So if you want to add support for a new field type for serialization, you just need to implement <code>IFieldSerializer</code> interface and register your serializer like so:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;io/FieldSerializerManager.h&quot;</span></div>
<div class="line"> </div>
<div class="line">FieldSerializerManager::addFieldSerializer(std::make_unique&lt;MyFieldSerializer&gt;());</div>
</div><!-- fragment --><p >After this, when you use <code>serialize</code> functions your serializer will be used.</p>
<p >In addition to the usual <code>IFieldSerializer</code> serializers we also have <code>IBinaryFieldSerializer</code> interface that works the same way but used for fields marked as <code>FST_AS_EXTERNAL_BINARY_FILE</code> and serializes into a binary file for smaller file size and faster deserialization.</p>
<h2><a class="anchor" id="autotoc_md84"></a>
Creating new reflection properties</h2>
<p >You can create custom reflection properties like <code>Guid</code> or <code>Serialize</code> that we currently have. All engine reflection properties are located at <code>io/properties</code> so you can look at them to see an example.</p>
<p >You can find instructions for creating custom properties here: <a href="https://github.com/jsoysouvanh/Refureku/wiki/Create-custom-properties">https://github.com/jsoysouvanh/Refureku/wiki/Create-custom-properties</a></p>
<h2><a class="anchor" id="autotoc_md85"></a>
Serialization internals</h2>
<p >Note: </p><blockquote class="doxtable">
<p >&zwj;Information described in this section might not be up to date, please notify the developers if something is not right / outdated. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md86"></a>
General overview</h3>
<p >Most of the game assets are stored in the human-readable <code>TOML</code> format. This format is similar to <code>INI</code> format but has more features. This means that you can use any text editor to view or edit your asset files if you need to.</p>
<p >When you serialize a serializable object (an object that derives from <code>Serializable</code>) the general TOML structure will look like this (comments start with #):</p>
<div class="fragment"><div class="line">## &lt;unique_id&gt; is an integer, used to globally differentiate objects in the file</div>
<div class="line">## (in case they have the same type (same GUID)), if you are serializing only 1 object the ID is 0 by default</div>
<div class="line">[&quot;&lt;unique_id&gt;.&lt;type_guid&gt;&quot;]       ## section that describes an object with GUID</div>
<div class="line">&lt;field_name&gt; = &lt;field_value&gt;      ## not all fields will have their values stored like that</div>
<div class="line">&lt;field_name&gt; = &lt;field_value&gt;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">[&quot;&lt;unique_id&gt;.&lt;type_guid&gt;&quot;]       ## some other object</div>
<div class="line">&lt;field_name&gt; = &lt;field_value&gt;      ## some other field</div>
<div class="line">&quot;..parent_node_id&quot; = &lt;unique_id&gt;  ## keys that start with two dots are &quot;custom attributes&quot; (user-specified)</div>
<div class="line">                                  ## that you pass into `serialize`, they are used to store additional info</div>
<div class="line">&lt;field_name&gt; = &quot;reflected type, see other sub-section&quot;  ## this field derives from `Serializable` and so we store</div>
<div class="line">                                                        ## its data in a separate section</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">[&quot;&lt;unique_parent_object_id&gt;.&lt;unique_subobject_id&gt;.&lt;type_guid&gt;&quot;] ## section of an object</div>
<div class="line">                                                                ## &lt;unique_subobject_id&gt; is unique only within</div>
<div class="line">                                                                ## the parent object</div>
<div class="line">&quot;.field_name&quot; = &lt;field_name&gt;      ## keys that start with one dot are &quot;internal attributes&quot; they are used for storing </div>
<div class="line">                                  ## internal info, in this case this key describes the name of the field this section </div>
<div class="line">                                  ## represents in `&lt;unique_parent_object_id&gt;` object</div>
</div><!-- fragment --><p >Here is a more specific example:</p>
<div class="fragment"><div class="line">[&quot;0.2a721c37-3c22-450c-8dad-7b6985cbbd61&quot;]</div>
<div class="line">sName = &quot;Node&quot;</div>
<div class="line"> </div>
<div class="line">[&quot;1.550ea9f9-dd8a-4089-a717-0fe4e351a687&quot;]</div>
<div class="line">bBoolValue2 = true</div>
<div class="line">&quot;..parent_node_id&quot; = &quot;0&quot;                              ## means that this section describes a node that has</div>
<div class="line">                                                      ## a parent node</div>
<div class="line">entity = &quot;reflected type, see other sub-section&quot;</div>
<div class="line">&quot;.path_relative_to_res&quot; = &quot;test/custom_node.toml&quot;     ## means that this section contains only changed fields compared</div>
<div class="line">                                                      ## to the specified file (original entity)</div>
<div class="line"> </div>
<div class="line">[&quot;1.0.550ea9f9-dd8a-4089-a717-0fe4e351a686&quot;]</div>
<div class="line">iIntValue2 = 42</div>
<div class="line">&quot;.field_name&quot; = &quot;entity&quot;</div>
<div class="line">vVectorValue2 = [</div>
<div class="line">&quot;Hello&quot;,</div>
<div class="line">&quot;World&quot;,</div>
<div class="line">]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md87"></a>
Storing only changed fields</h3>
<p >Some <code>Serializable::serialize</code> overloads allow you to specify <code>Serializable* pOriginalObject</code>, when such object is specified each field of the object that is being serialized will be compared to this original object and only fields that were changed compared to the original object will be serialized. To keep the information about all other fields in this case we add an internal attribute like so:</p>
<div class="fragment"><div class="line">[&quot;1.550ea9f9-dd8a-4089-a717-0fe4e351a687&quot;]</div>
<div class="line">bBoolValue2 = true</div>
<div class="line">&quot;.path_relative_to_res&quot; = &quot;test/custom_node.toml&quot;</div>
</div><!-- fragment --><p >This attribute points to a file located in the <code>res</code> directory, specifically at <code>res/test/custom_node.toml</code>. This all will work only if the original object was previously deserialized from a file located in the <code>res</code> directory (see <code>Serializable::getPathDeserializedFromRelativeToRes</code>).</p>
<h3><a class="anchor" id="autotoc_md88"></a>
Referencing external node tree</h3>
<p >Imagine you had a serialized node tree then you deserialize it and in the engine/editor add it to some node of some other node tree (we'll call it a parent node tree), thus the parent node tree is seeing your previously deserialized node tree (that you attached) as an extrenal node tree.</p>
<p >During the serialization of the node tree that uses an external node tree this external node tree is saved in a special way, that is, only the root node of the external node tree is saved with the parent node tree and the information about external node tree's child nodes is stored as a path to the external node tree file.</p>
<p >This means that when we reference an external node tree, only changes to external node tree's root node will be saved. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
