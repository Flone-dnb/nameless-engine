<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nameless Engine: ne::PipelineManager::ComputePipelines Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nameless Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structne_1_1PipelineManager_1_1ComputePipelines.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="structne_1_1PipelineManager_1_1ComputePipelines-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ne::PipelineManager::ComputePipelines Struct Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines_1_1Resources.html">Resources</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad9c85435528aee5b81c0a804f93eb25"><td class="memItemLeft" align="right" valign="top"><a id="aad9c85435528aee5b81c0a804f93eb25" name="aad9c85435528aee5b81c0a804f93eb25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ComputePipelines</b> (const <a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html">ComputePipelines</a> &amp;)=delete</td></tr>
<tr class="separator:aad9c85435528aee5b81c0a804f93eb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7777801d73c2ef87ef9a6794d302def5"><td class="memItemLeft" align="right" valign="top"><a id="a7777801d73c2ef87ef9a6794d302def5" name="a7777801d73c2ef87ef9a6794d302def5"></a>
<a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html">ComputePipelines</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html">ComputePipelines</a> &amp;)=delete</td></tr>
<tr class="separator:a7777801d73c2ef87ef9a6794d302def5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2597aab9c580a5596d131e6988d8b2b9"><td class="memItemLeft" align="right" valign="top">std::variant&lt; <a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#a2597aab9c580a5596d131e6988d8b2b9">getComputePipelineForShader</a> (<a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> *pPipelineManager, <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *pComputeShaderInterface)</td></tr>
<tr class="separator:a2597aab9c580a5596d131e6988d8b2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9930204f6088be4d835502902924fb"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#a2f9930204f6088be4d835502902924fb">onPipelineNoLongerUsedByComputeShaderInterface</a> (const std::string &amp;sComputeShaderName, <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *pComputeShaderInterface)</td></tr>
<tr class="separator:a2f9930204f6088be4d835502902924fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c2bea4e0194599be414e8050f08282"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#a48c2bea4e0194599be414e8050f08282">queueShaderExecutionOnGraphicsQueue</a> (<a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *pComputeShaderInterface)</td></tr>
<tr class="separator:a48c2bea4e0194599be414e8050f08282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13470d46781385cb1fb755f56c8d3362"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#a13470d46781385cb1fb755f56c8d3362">getComputePipelineCount</a> ()</td></tr>
<tr class="separator:a13470d46781385cb1fb755f56c8d3362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f30fe009055207bca46d93bf124ae4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex *, <a class="el" href="structne_1_1QueuedForExecutionComputeShaders.html">QueuedForExecutionComputeShaders</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#ae8f30fe009055207bca46d93bf124ae4">getComputeShadersForGraphicsQueueExecution</a> ()</td></tr>
<tr class="separator:ae8f30fe009055207bca46d93bf124ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a47b30ad3c21f330ec96bff388f125a0f"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#a47b30ad3c21f330ec96bff388f125a0f">queueComputeShaderInterfaceForExecution</a> (std::unordered_map&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *, std::unordered_set&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> * &gt; &gt; &amp;pipelineShaders, <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *pComputeShaderInterface)</td></tr>
<tr class="separator:a47b30ad3c21f330ec96bff388f125a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad5cf2fef4ef51e069d473d7282917408"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::recursive_mutex, <a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines_1_1Resources.html">Resources</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#ad5cf2fef4ef51e069d473d7282917408">mtxResources</a></td></tr>
<tr class="separator:ad5cf2fef4ef51e069d473d7282917408"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Groups information about compute pipelines. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a13470d46781385cb1fb755f56c8d3362" name="a13470d46781385cb1fb755f56c8d3362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13470d46781385cb1fb755f56c8d3362">&#9670;&#160;</a></span>getComputePipelineCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ne::PipelineManager::ComputePipelines::getComputePipelineCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the total number of existing compute pipelines.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of compute pipelines. </dd></dl>

</div>
</div>
<a id="a2597aab9c580a5596d131e6988d8b2b9" name="a2597aab9c580a5596d131e6988d8b2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2597aab9c580a5596d131e6988d8b2b9">&#9670;&#160;</a></span>getComputePipelineForShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; <a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a>, <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::ComputePipelines::getComputePipelineForShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a> *&#160;</td>
          <td class="paramname"><em>pPipelineManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *&#160;</td>
          <td class="paramname"><em>pComputeShaderInterface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Look for already created pipeline that uses the specified shader and returns it, otherwise creates a new pipeline.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If creating a new pipeline, loads the specified shader from disk into the memory, it will be released from the memory once the pipeline object is destroyed (not the shared pointer) and no other object is using it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPipelineManager</td><td><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> manager. </td></tr>
    <tr><td class="paramname">pComputeShaderInterface</td><td>Compute shader interface to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong, otherwise compute pipeline. </dd></dl>

</div>
</div>
<a id="ae8f30fe009055207bca46d93bf124ae4" name="ae8f30fe009055207bca46d93bf124ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f30fe009055207bca46d93bf124ae4">&#9670;&#160;</a></span>getComputeShadersForGraphicsQueueExecution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::recursive_mutex *, <a class="el" href="structne_1_1QueuedForExecutionComputeShaders.html">QueuedForExecutionComputeShaders</a> * &gt; ne::PipelineManager::ComputePipelines::getComputeShadersForGraphicsQueueExecution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns all compute shaders and their pipelines to be executed on the graphics queue.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not delete (free) returned pointers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Shaders and pipelines. </dd></dl>

</div>
</div>
<a id="a2f9930204f6088be4d835502902924fb" name="a2f9930204f6088be4d835502902924fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9930204f6088be4d835502902924fb">&#9670;&#160;</a></span>onPipelineNoLongerUsedByComputeShaderInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::ComputePipelines::onPipelineNoLongerUsedByComputeShaderInterface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sComputeShaderName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *&#160;</td>
          <td class="paramname"><em>pComputeShaderInterface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the specified compute shader interface and if no other interface references the compute pipeline (that the shader used) also destroys the pipeline.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If you used <a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#a2597aab9c580a5596d131e6988d8b2b9">getComputePipelineForShader</a> to get a compute pipeline for your shader you don't need to call this function as it will be automatically called by <code><a class="el" href="classne_1_1PipelineSharedPtr.html">PipelineSharedPtr</a></code>'s destructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sComputeShaderName</td><td>Name of the compute shader that compute pipeline uses. </td></tr>
    <tr><td class="paramname">pComputeShaderInterface</td><td>Compute shader interface to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a47b30ad3c21f330ec96bff388f125a0f" name="a47b30ad3c21f330ec96bff388f125a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b30ad3c21f330ec96bff388f125a0f">&#9670;&#160;</a></span>queueComputeShaderInterfaceForExecution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::ComputePipelines::queueComputeShaderInterfaceForExecution </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="classne_1_1Pipeline.html">Pipeline</a> *, std::unordered_set&lt; <a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pipelineShaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *&#160;</td>
          <td class="paramname"><em>pComputeShaderInterface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Adds a compute shader interface to the specified map to be executed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Expects that <a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html#ad5cf2fef4ef51e069d473d7282917408">mtxResources</a> is locked during the function call.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineShaders</td><td>Map to add the new interface to. </td></tr>
    <tr><td class="paramname">pComputeShaderInterface</td><td>Interface to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<a id="a48c2bea4e0194599be414e8050f08282" name="a48c2bea4e0194599be414e8050f08282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c2bea4e0194599be414e8050f08282">&#9670;&#160;</a></span>queueShaderExecutionOnGraphicsQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classne_1_1Error.html">Error</a> &gt; ne::PipelineManager::ComputePipelines::queueShaderExecutionOnGraphicsQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classne_1_1ComputeShaderInterface.html">ComputeShaderInterface</a> *&#160;</td>
          <td class="paramname"><em>pComputeShaderInterface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds a compute shader interface to be executed on the graphics queue according to shader's execution stage and group.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Added shader will be executed only once, if you want your shader to be executed again you would need to call this function again but later after a frame was submitted (if you call it right now nothing will happen as it's already queued).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pComputeShaderInterface</td><td>Compute shader interface to queue for execution.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classne_1_1Error.html">Error</a> if something went wrong. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad5cf2fef4ef51e069d473d7282917408" name="ad5cf2fef4ef51e069d473d7282917408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cf2fef4ef51e069d473d7282917408">&#9670;&#160;</a></span>mtxResources</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::recursive_mutex, <a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines_1_1Resources.html">Resources</a>&gt; ne::PipelineManager::ComputePipelines::mtxResources</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classne_1_1Pipeline.html">Pipeline</a> data. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/engine_lib/private/render/general/pipeline/<a class="el" href="PipelineManager_8h_source.html">PipelineManager.h</a></li>
<li>src/engine_lib/private/render/general/pipeline/PipelineManager.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ne</b></li><li class="navelem"><a class="el" href="classne_1_1PipelineManager.html">PipelineManager</a></li><li class="navelem"><a class="el" href="structne_1_1PipelineManager_1_1ComputePipelines.html">ComputePipelines</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
